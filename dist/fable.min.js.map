{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/fable-log/source/Fable-Log-BaseLogger.js","fable.min.js","node_modules/fable-log/source/Fable-Log-DefaultProviders-Web.js","node_modules/fable-log/source/Fable-Log-DefaultStreams.json","node_modules/fable-log/source/Fable-Log-Logger-Console.js","node_modules/fable-log/source/Fable-Log.js","node_modules/fable-settings/source/Fable-Settings-Default.json","node_modules/fable-settings/source/Fable-Settings-TemplateProcessor.js","node_modules/fable-settings/source/Fable-Settings.js","node_modules/fable-uuid/source/Fable-UUID-Random-Browser.js","node_modules/fable-uuid/source/Fable-UUID.js","node_modules/precedent/source/Precedent.js","node_modules/precedent/source/StringParser.js","node_modules/precedent/source/WordTree.js","node_modules/process/browser.js","source/Fable-Browser-Shim.js","source/Fable-Utility-Template.js","source/Fable-Utility.js","source/Fable.js"],"names":["f","exports","module","define","amd","window","global","self","this","Fable","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","constructor","pLogStreamSettings","pFableLog","_Settings","loggerUUID","generateInsecureUUID","levels","tmpDate","Date","getTime","replace","pCharacter","tmpRandomData","Math","random","floor","toString","initialize","trace","pLogText","pLogObject","write","debug","info","warn","error","fatal","pLogLevel","getDefaultProviders","tmpDefaultProviders","console","default","loggertype","streamtype","level","libBaseLogger","super","_ShowTimeStamps","hasOwnProperty","showtimestamps","_FormattedTimeStamps","formattedtimestamps","_ContextMessage","Context","Product","_OutputLogLinesToConsole","outputloglinestoconsole","_OutputObjectsToConsole","outputobjectstoconsole","prefixCache","pLevel","pObject","tmpTimeStamp","toISOString","tmpLogLine","log","JSON","stringify","FableLog","pFableSettings","pFable","tmpSettings","_Providers","_StreamDefinitions","LogStreams","logStreams","logProviders","activeLogStreams","logStreamsTrace","logStreamsDebug","logStreamsInfo","logStreamsWarn","logStreamsError","logStreamsFatal","datumDecorator","pDatum","uuid","addLogger","pLogger","push","setDatumDecorator","fDatumDecorator","pMessage","tmpDecoratedDatum","tmpStreamDefinition","Object","assign","logTime","tmpMessage","tmpTime","getTimeStamp","getTimeDelta","pTimeStamp","logTimeDelta","pTimeDelta","tmpEndTime","logTimeDeltaHuman","tmpMs","parseInt","tmpSeconds","tmpMinutes","tmpHours","logTimeDeltaRelative","pStartTime","logTimeDeltaRelativeHuman","new","pSettings","ProductVersion","ConfigFile","process","pDependencies","templateProcessor","precedent","addPattern","pTemplateValue","tmpTemplateValue","trim","tmpSeparatorIndex","indexOf","tmpDefaultValue","substring","tmpEnvironmentVariableName","env","parseSetting","pString","parseString","_process","libPrecedent","libFableSettingsTemplateProcessor","FableSettings","dependencies","settingsTemplateProcessor","_configureEnvTemplating","buildDefaultSettings","merge","base","parse","DefaultConfigFile","pException","settings","_PerformEnvTemplating","NoEnvReplacement","_resolveEnv","tmpKey","_isObject","value","Array","isArray","_deepMergeObjects","toObject","fromObject","keys","forEach","key","fromValue","toValue","pSettingsFrom","pSettingsTo","tmpSettingsFrom","tmpSettingsTo","tmpSettingsFromCopy","fill","getRandomValues","crypto","bind","msCrypto","generateWhatWGBytes","tmpBuffer","Uint8Array","generateRandomBytes","tmpValue","generate","libRandomByteGenerator","FableUUID","_UUIDModeRandom","UUIDModeRandom","_UUIDLength","UUIDLength","_UUIDRandomDictionary","UUIDDictionary","randomByteGenerator","_HexLookup","substr","bytesToUUID","pBuffer","join","generateUUIDv4","tmpRandomBytes","generateRandom","tmpUUID","charAt","getUUID","libWordTree","libStringParser","WordTree","StringParser","ParseTree","pPatternStart","pPatternEnd","pParser","newParserState","pParseTree","Output","OutputBuffer","Pattern","PatternMatch","PatternMatchOutputBuffer","assignNode","pNode","pParserState","appendOutputBuffer","flushOutputBuffer","checkPatternEnd","PatternEnd","PatternStart","Parse","parseCharacter","tmpParserState","addChild","pTree","pPattern","pIndex","tmpLeaf","pData","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","fun","setTimeout","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","concat","drainQueue","timeout","len","run","marker","runClearTimeout","Item","array","noop","nextTick","args","arguments","prototype","apply","title","browser","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","name","binding","cwd","chdir","dir","umask","libNPMModuleWrapper","pTemplateText","fable","Matchers","Evaluate","Interpolate","Escaper","Unescaper","GuaranteedNonMatch","templateEscapes","u2028","u2029","renderFunction","extend","pDestinationObject","pSourceObjects","renderTemplate","templateFunction","buildTemplateFunction","TemplateSource","pMatch","pCode","decodeURIComponent","Function","TemplateSourceCompiled","libFableUtilityTemplate","template","chunk","pInput","pChunkSize","pChunkCache","tmpInputArray","tmpChunkSize","tmpChunkCache","splice","libFableSettings","libFableUUID","libFableLog","libFableUtility","settingsManager","libUUID","Utility"],"mappings":"CAAA,SAAAA,GAAA,GAAA,iBAAAC,SAAA,oBAAAC,OAAAA,OAAAD,QAAAD,SAAA,GAAA,mBAAAG,QAAAA,OAAAC,IAAAD,OAAA,GAAAH,OAAA,EAAA,oBAAAK,OAAAA,OAAA,oBAAAC,OAAAA,OAAA,oBAAAC,KAAAA,KAAAC,MAAAC,MAAAT,GAAA,CAAA,CAAA,EAAA,WAAA,OAAA,SAAAU,EAAAC,EAAAC,EAAAC,GAAA,SAAAC,EAAAC,EAAAf,GAAA,IAAAY,EAAAG,GAAA,CAAA,IAAAJ,EAAAI,GAAA,CAAA,IAAAC,EAAA,mBAAAC,SAAAA,QAAA,IAAAjB,GAAAgB,EAAA,OAAAA,EAAAD,GAAA,GAAA,GAAAG,EAAA,OAAAA,EAAAH,GAAA,GAAA,IAAAI,EAAA,IAAAC,MAAA,uBAAAL,EAAA,KAAA,MAAAI,EAAAE,KAAA,mBAAAF,CAAA,CAAA,IAAAG,EAAAV,EAAAG,GAAA,CAAAd,QAAA,CAAA,GAAAU,EAAAI,GAAA,GAAAQ,KAAAD,EAAArB,SAAA,SAAAS,GAAA,OAAAI,EAAAH,EAAAI,GAAA,GAAAL,IAAAA,EAAA,GAAAY,EAAAA,EAAArB,QAAAS,EAAAC,EAAAC,EAAAC,EAAA,CAAA,OAAAD,EAAAG,GAAAd,OAAA,CAAA,IAAA,IAAAiB,EAAA,mBAAAD,SAAAA,QAAAF,EAAA,EAAAA,EAAAF,EAAAW,OAAAT,IAAAD,EAAAD,EAAAE,IAAA,OAAAD,CAAA,CAAA,CAAA,CAAA,EAAA,CAAA,SAAAG,EAAAf,EAAAD,GC4FAC,EAAAD;;;;;;;;AApFA,MAEAwB,YAAAC,EAAAC,GAGAnB,KAAAoB,UAAAF,EAKAlB,KAAAqB,WAAArB,KAAAsB,uBAIAtB,KAAAuB,OACA,CACA,QACA,QACA,OACA,OACA,QACA,QAEA,CAGAD,uBAEA,IAAAE,GAAA,IAAAC,MAAAC,UAWA,MAVA,0BAAAC,QAAA,SACAC,IAIA,IAAAC,GAAAL,EAAA,GAAAM,KAAAC,UAAA,GAAA,EAGA,OAFAP,EAAAM,KAAAE,MAAAR,EAAA,KAEA,KAAAI,EAAAC,EAAA,EAAAA,EAAA,GAAAI,SAAA,GAAA,GAGA,CAEAC,aAEA,CAGAC,MAAAC,EAAAC,GAEArC,KAAAsC,MAAA,QAAAF,EAAAC,EACA,CAEAE,MAAAH,EAAAC,GAEArC,KAAAsC,MAAA,QAAAF,EAAAC,EACA,CAEAG,KAAAJ,EAAAC,GAEArC,KAAAsC,MAAA,OAAAF,EAAAC,EACA,CAEAI,KAAAL,EAAAC,GAEArC,KAAAsC,MAAA,OAAAF,EAAAC,EACA,CAEAK,MAAAN,EAAAC,GAEArC,KAAAsC,MAAA,QAAAF,EAAAC,EACA,CAEAM,MAAAP,EAAAC,GAEArC,KAAAsC,MAAA,QAAAF,EAAAC,EACA,CAEAC,MAAAM,EAAAR,EAAAC,GAGA,OAAA,CACA,ECMA,EAAE,CAAC,GAAG,EAAE,CAAC,SAAS5B,EAAQf,EAAOD;;;;;;;;ACtFjCoD,oBAAAA,KAEA,IAAAC,EAAA,CAAA,EAMA,OAJAA,EAAAC,QAAAtC,EAAA,iCAEAqC,EAAAE,QAAAF,EAAAC,QAEAD,CAAA,EAGApD,EAAAD,QAAAoD,qBDiGA,EAAE,CAAC,gCAAgC,IAAI,EAAE,CAAC,SAASpC,EAAQf,EAAOD,GErHlEC,EAAAD,QAAA,CACA,CACAwD,WAAA,UACAC,WAAA,UACAC,MAAA,SFyHA,EAAE,CAAC,GAAG,EAAE,CAAC,SAAS1C,EAAQf,EAAOD,GG7HjC,IAAA2D,EAAA3C,EAAA,6BA+DAf,EAAAD,QA7DA,cAAA2D,EAEAnC,YAAAC,EAAAC,GAEAkC,MAAAnC,GAEAlB,KAAAsD,kBAAApC,EAAAqC,eAAA,mBAAA,GAAArC,EAAAsC,eACAxD,KAAAyD,uBAAAvC,EAAAqC,eAAA,wBAAA,GAAArC,EAAAwC,oBAEA1D,KAAA2D,gBAAAzC,EAAAqC,eAAA,WAAA,IAAArC,EAAA0C,WACAzC,EAAAC,UAAAmC,eAAA,WAAA,IAAApC,EAAAC,UAAAyC,WACA,sBAGA7D,KAAA8D,0BAAA5C,EAAAqC,eAAA,4BAAArC,EAAA6C,wBACA/D,KAAAgE,yBAAA9C,EAAAqC,eAAA,2BAAArC,EAAA+C,uBAGAjE,KAAAkE,YAAA,CAAA,EACA,IAAA,IAAA3D,EAAA,EAAAA,GAAAP,KAAAuB,OAAAP,OAAAT,IAEAP,KAAAkE,YAAAlE,KAAAuB,OAAAhB,IAAA,IAAAP,KAAAuB,OAAAhB,OAAAP,KAAA2D,oBAEA3D,KAAAsD,kBAGAtD,KAAAkE,YAAAlE,KAAAuB,OAAAhB,IAAA,IAAAP,KAAAkE,YAAAlE,KAAAuB,OAAAhB,IAGA,CAEA+B,MAAA6B,EAAA/B,EAAAgC,GAEA,IAAAC,EAAA,GACArE,KAAAsD,iBAAAtD,KAAAyD,qBAEAY,GAAA,IAAA5C,MAAA6C,cAEAtE,KAAAsD,kBAEAe,GAAA,IAAA5C,MAGA,IAAA8C,EAAA,GAAAF,IAAArE,KAAAkE,YAAAC,KAAA/B,IAcA,OAZApC,KAAA8D,0BAEAf,QAAAyB,IAAAD,GAIAvE,KAAAgE,8BAAA,IAAAI,GAEArB,QAAAyB,IAAAC,KAAAC,UAAAN,EAAA,KAAA,IAIAG,CACA,EHkIA,EAAE,CAAC,4BAA4B,IAAI,EAAE,CAAC,SAAS9D,EAAQf,EAAOD;;;;;;;;;AI/K9D,MAAAkF,EAEA1D,YAAA2D,EAAAC,GAEA,IAAAC,EAAA,iBAAAF,EAAAA,EAAA,CAAA,EACA5E,KAAAoB,UAAA0D,EAEA9E,KAAA+E,WAAAtE,EAAA,wCAEAT,KAAAgF,mBAAAF,EAAAvB,eAAA,cAAAuB,EAAAG,WAAAxE,EAAA,mCAEAT,KAAAkF,WAAA,GAIAlF,KAAAmF,aAAA,CAAA,EAGAnF,KAAAoF,iBAAA,CAAA,EAEApF,KAAAqF,gBAAA,GACArF,KAAAsF,gBAAA,GACAtF,KAAAuF,eAAA,GACAvF,KAAAwF,eAAA,GACAxF,KAAAyF,gBAAA,GACAzF,KAAA0F,gBAAA,GAEA1F,KAAA2F,eAAAC,GAAAA,EAEA5F,KAAA6F,KAAA,iBAAAf,EAAAjB,QAAAiB,EAAAjB,QAAA,SACA,CAEAiC,UAAAC,EAAA5B,GAGA,GAAAnE,KAAAoF,iBAAA7B,eAAAwC,EAAA1E,YAEA,OAAA,EAQA,OAJArB,KAAAkF,WAAAc,KAAAD,GACA/F,KAAAoF,iBAAAW,EAAA1E,aAAA,EAGA8C,GAEA,IAAA,QACAnE,KAAAqF,gBAAAW,KAAAD,GACA,IAAA,QACA/F,KAAAsF,gBAAAU,KAAAD,GACA,IAAA,OACA/F,KAAAuF,eAAAS,KAAAD,GACA,IAAA,OACA/F,KAAAwF,eAAAQ,KAAAD,GACA,IAAA,QACA/F,KAAAyF,gBAAAO,KAAAD,GACA,IAAA,QACA/F,KAAA0F,gBAAAM,KAAAD,GAIA,OAAA,CACA,CAEAE,kBAAAC,GAIAlG,KAAA2F,eAFA,mBAAAO,EAEAA,EAIAN,GAAAA,CAEA,CAEAzD,MAAAgE,EAAAP,GAEA,MAAAQ,EAAApG,KAAA2F,eAAAC,GACA,IAAA,IAAArF,EAAA,EAAAA,EAAAP,KAAAqF,gBAAArE,OAAAT,IAEAP,KAAAqF,gBAAA9E,GAAA4B,MAAAgE,EAAAC,EAEA,CAEA7D,MAAA4D,EAAAP,GAEA,MAAAQ,EAAApG,KAAA2F,eAAAC,GACA,IAAA,IAAArF,EAAA,EAAAA,EAAAP,KAAAsF,gBAAAtE,OAAAT,IAEAP,KAAAsF,gBAAA/E,GAAAgC,MAAA4D,EAAAC,EAEA,CAEA5D,KAAA2D,EAAAP,GAEA,MAAAQ,EAAApG,KAAA2F,eAAAC,GACA,IAAA,IAAArF,EAAA,EAAAA,EAAAP,KAAAuF,eAAAvE,OAAAT,IAEAP,KAAAuF,eAAAhF,GAAAiC,KAAA2D,EAAAC,EAEA,CAEA3D,KAAA0D,EAAAP,GAEA,MAAAQ,EAAApG,KAAA2F,eAAAC,GACA,IAAA,IAAArF,EAAA,EAAAA,EAAAP,KAAAwF,eAAAxE,OAAAT,IAEAP,KAAAwF,eAAAjF,GAAAkC,KAAA0D,EAAAC,EAEA,CAEA1D,MAAAyD,EAAAP,GAEA,MAAAQ,EAAApG,KAAA2F,eAAAC,GACA,IAAA,IAAArF,EAAA,EAAAA,EAAAP,KAAAyF,gBAAAzE,OAAAT,IAEAP,KAAAyF,gBAAAlF,GAAAmC,MAAAyD,EAAAC,EAEA,CAEAzD,MAAAwD,EAAAP,GAEA,MAAAQ,EAAApG,KAAA2F,eAAAC,GACA,IAAA,IAAArF,EAAA,EAAAA,EAAAP,KAAA0F,gBAAA1E,OAAAT,IAEAP,KAAA0F,gBAAAnF,GAAAoC,MAAAwD,EAAAC,EAEA,CAEAlE,aAGA,IAAA,IAAA3B,EAAA,EAAAA,EAAAP,KAAAgF,mBAAAhE,OAAAT,IACA,CACA,IAAA8F,EAAAC,OAAAC,OAAA,CAAAtD,WAAA,UAAAC,WAAA,UAAAC,MAAA,QAAAnD,KAAAgF,mBAAAzE,IAEAP,KAAA+E,WAAAxB,eAAA8C,EAAApD,YAMAjD,KAAA8F,UAAA,IAAA9F,KAAA+E,WAAAsB,EAAApD,YAAAoD,EAAArG,MAAAqG,EAAAlD,OAJAJ,QAAAyB,IAAA,sEAAAC,KAAAC,UAAA2B,KAMA,CAGA,IAAA,IAAA9F,EAAA,EAAAA,EAAAP,KAAAkF,WAAAlE,OAAAT,IAEAP,KAAAkF,WAAA3E,GAAA2B,YAEA,CAEAsE,QAAAL,EAAAP,GAEA,IAAAa,OAAA,IAAAN,EAAAA,EAAA,OACAO,EAAA,IAAAjF,KACAzB,KAAAwC,KAAA,GAAAiE,KAAAC,aAAAA,KAAAd,EACA,CAGAe,eAEA,OAAA,IAAAlF,IACA,CAEAmF,aAAAC,GAGA,OADA,IAAApF,KACAoF,CACA,CAGAC,aAAAC,EAAAZ,EAAAP,GAEA,IAAAa,OAAA,IAAAN,EAAAA,EAAA,mBAGAa,GAAA,IAAAvF,KAEAzB,KAAAwC,KAAA,GAAAiE,uBAAAO,YAAAD,OAAAnB,EACA,CAEAqB,kBAAAF,EAAAZ,EAAAP,GAEA,IAAAa,OAAA,IAAAN,EAAAA,EAAA,mBAEAa,GAAA,IAAAvF,KAEAyF,EAAAC,SAAAJ,EAAA,KACAK,EAAAD,SAAAJ,EAAA,IAAA,IACAM,EAAAF,SAAAJ,EAAA,IAAA,IACAO,EAAAH,SAAAJ,EAAA,MAEAG,EAAAA,EAAA,GAAA,KAAAA,EAAAA,EAAA,IAAA,IAAAA,EAAAA,EACAE,EAAAA,EAAA,GAAA,IAAAA,EAAAA,EACAC,EAAAA,EAAA,GAAA,IAAAA,EAAAA,EACAC,EAAAA,EAAA,GAAA,IAAAA,EAAAA,EAEAtH,KAAAwC,KAAA,GAAAiE,uBAAAO,YAAAD,YAAAO,KAAAD,KAAAD,KAAAF,KAAAtB,EACA,CAEA2B,qBAAAC,EAAArB,EAAAP,GAEA5F,KAAA8G,aAAA9G,KAAA4G,aAAAY,GAAArB,EAAAP,EACA,CAEA6B,0BAAAD,EAAArB,EAAAP,GAEA5F,KAAAiH,kBAAAjH,KAAA4G,aAAAY,GAAArB,EAAAP,EACA,EAUAlG,EAAAD,QAAA,CAAAiI,IANA,SAAAC,GAEA,OAAA,IAAAhD,EAAAgD,EACA,EAGAhD,SAAAA,EJiMA,EAAE,CAAC,uCAAuC,EAAE,kCAAkC,IAAI,EAAE,CAAC,SAASlE,EAAQf,EAAOD,GK9a7GC,EAAAD,QAAA,CACAoE,QAAA,sBACA+D,eAAA,QAEAC,YAAA,EAEA5C,WACA,CACA,CACA9B,MAAA,ULobA,EAAE,CAAC,GAAG,EAAE,CAAC,SAAS1C,EAAQf,EAAOD,IACjC,SAAWqI,IAAS,WM9YpBpI,EAAAD;;;;;;;;;;;AArCA,MAEAwB,YAAA8G,GAGA/H,KAAAgI,kBAAA,IAAAD,EAAAE,UAGAjI,KAAAgI,kBAAAE,WAAA,KAAA,KACAC,IAEA,IAAAC,EAAAD,EAAAE,OAEAC,EAAAF,EAAAG,QAAA,KAGAC,EAAAJ,EAAAK,UAAAH,EAAA,GAEAI,EAAAJ,GAAA,EAAAF,EAAAK,UAAA,EAAAH,GAAAF,EAEA,OAAAN,EAAAa,IAAApF,eAAAmF,GAEAZ,EAAAa,IAAAD,GAIAF,CACA,GAEA,CAEAI,aAAAC,GAEA,OAAA7I,KAAAgI,kBAAAc,YAAAD,EACA,ENmcC,GAAE9H,KAAKf,KAAM,GAAEe,KAAKf,KAAKS,EAAQ,YAElC,EAAE,CAACsI,SAAW,KAAK,EAAE,CAAC,SAAStI,EAAQf,EAAOD;;;;;;;;;AOze9C,MAAAuJ,EAAAvI,EAAA,aACAwI,EAAAxI,EAAA,yCAEA,MAAAyI,EAEAjI,YAAA2D,GAGA5E,KAAAmJ,aACA,CACAlB,UAAAe,GAIAhJ,KAAAoJ,0BAAA,IAAAH,EAAAjJ,KAAAmJ,cAGAnJ,KAAAqJ,wBAAAzE,GAEA5E,KAAAgD,QAAAhD,KAAAsJ,uBAGA,IAAAxE,EAAA9E,KAAAuJ,MAAA3E,EAAA5E,KAAAsJ,wBAKA,GAFAtJ,KAAAwJ,KAAA/E,KAAAgF,MAAAhF,KAAAC,UAAAI,IAEAA,EAAA4E,kBAEA,IAGA5E,EAAA9E,KAAAuJ,MAAA9I,EAAAqE,EAAA4E,mBAAA5E,EACA,CACA,MAAA6E,GAIA5G,QAAAyB,IAAA,2HACAzB,QAAAyB,IAAA,2BAAAmF,EACA,CAGA,GAAA7E,EAAA+C,WAEA,IAGA/C,EAAA9E,KAAAuJ,MAAA9I,EAAAqE,EAAA+C,YAAA/C,EACA,CACA,MAAA6E,GAIA5G,QAAAyB,IAAA,mHACAzB,QAAAyB,IAAA,2BAAAmF,EACA,CAGA3J,KAAA4J,SAAA9E,CACA,CAGAwE,uBAEA,OAAA7E,KAAAgF,MAAAhF,KAAAC,UAAAjE,EAAA,6BACA,CAGA4I,wBAAA1B,GAGA3H,KAAA6J,uBAAAlC,IAAA,IAAAA,EAAAmC,gBACA,CAGAC,YAAApC,GAEA,IAAA,MAAAqC,KAAArC,EAEA,iBAAAA,EAAAqC,GAEAhK,KAAA+J,YAAApC,EAAAqC,IAEA,iBAAArC,EAAAqC,KAEArC,EAAAqC,GAAAhK,KAAAoJ,0BAAAR,aAAAjB,EAAAqC,IAGA,CAKAC,UAAAC,GAEA,MAAA,iBAAAA,IAAAC,MAAAC,QAAAF,EACA,CAKAG,kBAAAC,EAAAC,GAEA,GAAAA,GAAAvK,KAAAiK,UAAAM,GAmBA,OAfAjE,OAAAkE,KAAAD,GAAAE,SAAAC,IAEA,MAAAC,EAAAJ,EAAAG,GACA,GAAA1K,KAAAiK,UAAAU,GACA,CACA,MAAAC,EAAAN,EAAAI,GACA,GAAAE,GAAA5K,KAAAiK,UAAAW,GAIA,YADA5K,KAAAqK,kBAAAO,EAAAD,EAGA,CACAL,EAAAI,GAAAC,CAAA,IAEAL,CACA,CAGAf,MAAAsB,EAAAC,GAGA,IAAAC,EAAA,iBAAAF,EAAAA,EAAA,CAAA,EAEAG,EAAA,iBAAAF,EAAAA,EAAA9K,KAAA4J,SAGAqB,EAAAxG,KAAAgF,MAAAhF,KAAAC,UAAAqG,IAUA,OATAC,EAAAhL,KAAAqK,kBAAAW,EAAAC,GAEAjL,KAAA6J,uBAEA7J,KAAA+J,YAAAiB,GAGAhL,KAAAqJ,wBAAA2B,GAEAA,CACA,CAGAE,KAAAL,GAGA,IAAAE,EAAA,iBAAAF,EAAAA,EAAA,CAAA,EAGAI,EAAAxG,KAAAgF,MAAAhF,KAAAC,UAAAqG,IAIA,OAFA/K,KAAA4J,SAAA5J,KAAAqK,kBAAAY,EAAAjL,KAAA4J,UAEA5J,KAAA4J,QACA,EASAlK,EAAAD,QAAA,CAAAiI,IALA,SAAAC,GAEA,OAAA,IAAAuB,EAAAvB,EACA,EAEAuB,cAAAA,EPofA,EAAE,CAAC,2BAA2B,EAAE,wCAAwC,EAAEjB,UAAY,KAAK,EAAE,CAAC,SAASxH,EAAQf,EAAOD,GQpmBtHC,EAAAD;;;;;;;;AArDA,MAEAwB,cAKAjB,KAAAmL,gBAAA,oBAAAC,QAAAA,OAAAD,iBAAAC,OAAAD,gBAAAE,KAAAD,SACA,oBAAAE,UAAA,mBAAAzL,OAAAyL,SAAAH,iBAAAG,SAAAH,gBAAAE,KAAAC,SACA,CAGAC,sBAEA,IAAAC,EAAA,IAAAC,WAAA,IAGA,OADAzL,KAAAmL,gBAAAK,GACAA,CACA,CAGAE,sBAIA,IAAAF,EAAA,IAAAC,WAAA,IAEA,IAAA,IAAAE,EAAApL,EAAA,EAAAA,EAAA,GAAAA,IAEA,IAAA,EAAAA,KAEAoL,EAAA,WAAA7J,KAAAC,UAGAyJ,EAAAjL,GAAAoL,MAAA,EAAApL,IAAA,GAAA,IAGA,OAAAiL,CACA,CAEAI,WAEA,OAAA5L,KAAAmL,gBAEAnL,KAAAuL,sBAIAvL,KAAA0L,qBAEA,ER4qBA,EAAE,CAAC,GAAG,GAAG,CAAC,SAASjL,EAAQf,EAAOD;;;;;;;;;AS3tBlC,IAAAoM,EAAApL,EAAA,0BAEA,MAAAqL,EAEA7K,YAAA0G,GAIA3H,KAAA+L,kBAAA,iBAAApE,IAAAA,EAAApE,eAAA,oBAAA,GAAAoE,EAAAqE,eAGAhM,KAAAiM,YAAA,iBAAAtE,GAAAA,EAAApE,eAAA,cAAAoE,EAAAuE,WAAA,EAAA,EAEAlM,KAAAmM,sBAAA,iBAAAxE,GAAAA,EAAApE,eAAA,kBAAAoE,EAAAyE,eAAA,EAAA,iEAEApM,KAAAqM,oBAAA,IAAAR,EAGA7L,KAAAsM,WAAA,GACA,IAAA,IAAA/L,EAAA,EAAAA,EAAA,MAAAA,EAEAP,KAAAsM,WAAA/L,IAAAA,EAAA,KAAA0B,SAAA,IAAAsK,OAAA,EAEA,CAGAC,YAAAC,GAEA,IAAAlM,EAAA,EAEA,MAAA,CACAP,KAAAsM,WAAAG,EAAAlM,MAAAP,KAAAsM,WAAAG,EAAAlM,MACAP,KAAAsM,WAAAG,EAAAlM,MAAAP,KAAAsM,WAAAG,EAAAlM,MAAA,IACAP,KAAAsM,WAAAG,EAAAlM,MAAAP,KAAAsM,WAAAG,EAAAlM,MAAA,IACAP,KAAAsM,WAAAG,EAAAlM,MAAAP,KAAAsM,WAAAG,EAAAlM,MAAA,IACAP,KAAAsM,WAAAG,EAAAlM,MAAAP,KAAAsM,WAAAG,EAAAlM,MAAA,IACAP,KAAAsM,WAAAG,EAAAlM,MAAAP,KAAAsM,WAAAG,EAAAlM,MAAAP,KAAAsM,WAAAG,EAAAlM,MAAAP,KAAAsM,WAAAG,EAAAlM,MAAAP,KAAAsM,WAAAG,EAAAlM,MAAAP,KAAAsM,WAAAG,EAAAlM,OACAmM,KAAA,GACA,CAGAC,iBAEA,IAAAxC,MAAA,IACA,IAAAyC,EAAA5M,KAAAqM,oBAAAT,WAMA,OAHAgB,EAAA,GAAA,GAAAA,EAAA,GAAA,GACAA,EAAA,GAAA,GAAAA,EAAA,GAAA,IAEA5M,KAAAwM,YAAAI,EACA,CAGAC,iBAEA,IAAAC,EAAA,GAEA,IAAA,IAAAvM,EAAA,EAAAA,EAAAP,KAAAiM,YAAA1L,IAEAuM,GAAA9M,KAAAmM,sBAAAY,OAAAjL,KAAAE,MAAAF,KAAAC,UAAA/B,KAAAmM,sBAAAnL,OAAA,KAGA,OAAA8L,CACA,CAGAE,UAEA,OAAAhN,KAAA+L,gBAEA/L,KAAA6M,iBAIA7M,KAAA2M,gBAEA,EAUAjN,EAAAD,QAAA,CAAAiI,IANA,SAAAC,GAEA,OAAA,IAAAmE,EAAAnE,EACA,EAGAmE,UAAAA,ET8uBA,EAAE,CAAC,yBAAyB,IAAI,GAAG,CAAC,SAASrL,EAAQf,EAAOD;;;;;;;;;;AU50B5D,IAAAwN,EAAAxM,EAAA,iBACAyM,EAAAzM,EAAA,qBAyCAf,EAAAD,QAvCA,MAKAwB,cAEAjB,KAAAmN,SAAA,IAAAF,EAEAjN,KAAAoN,aAAA,IAAAF,EAEAlN,KAAAqN,UAAArN,KAAAmN,SAAAE,SACA,CAUAnF,WAAAoF,EAAAC,EAAAC,GAEA,OAAAxN,KAAAmN,SAAAjF,WAAAoF,EAAAC,EAAAC,EACA,CAQA1E,YAAAD,GAEA,OAAA7I,KAAAoN,aAAAtE,YAAAD,EAAA7I,KAAAqN,UACA,EV21BA,EAAE,CAAC,oBAAoB,GAAG,gBAAgB,KAAK,GAAG,CAAC,SAAS5M,EAAQf,EAAOD,GWhuB3EC,EAAAD;;;;;;;;;;AAjKA,MAKAwB,cAEA,CASAwM,eAAAC,GAEA,MACA,CACAL,UAAAK,EAEAC,OAAA,GACAC,aAAA,GAEAC,SAAA,EAEAC,cAAA,EACAC,yBAAA,GAEA,CAUAC,WAAAC,EAAAC,GAEAA,EAAAJ,aAAAG,EAGAC,EAAAJ,aAAAvK,eAAA,gBAGA2K,EAAAL,QAAAK,EAAAJ,aAEA,CAUAK,mBAAAvM,EAAAsM,GAEAA,EAAAN,cAAAhM,CACA,CAQAwM,kBAAAF,GAEAA,EAAAP,QAAAO,EAAAN,aACAM,EAAAN,aAAA,EACA,CASAS,gBAAAH,GAEAA,EAAAN,aAAA5M,QAAAkN,EAAAL,QAAAS,WAAAtN,OAAAkN,EAAAL,QAAAU,aAAAvN,QACAkN,EAAAN,aAAArB,QAAA2B,EAAAL,QAAAS,WAAAtN,UAAAkN,EAAAL,QAAAS,aAIAJ,EAAAN,aAAAM,EAAAL,QAAAW,MAAAN,EAAAN,aAAArB,OAAA2B,EAAAL,QAAAU,aAAAvN,OAAAkN,EAAAN,aAAA5M,QAAAkN,EAAAL,QAAAU,aAAAvN,OAAAkN,EAAAL,QAAAS,WAAAtN,UAEAhB,KAAAoO,kBAAAF,GAEAA,EAAAL,SAAA,EACAK,EAAAJ,cAAA,EAEA,CASAW,eAAA7M,EAAAsM,IAGAA,EAAAJ,cAAAI,EAAAb,UAAA9J,eAAA3B,IAGA5B,KAAAgO,WAAAE,EAAAb,UAAAzL,GAAAsM,GACAlO,KAAAmO,mBAAAvM,EAAAsM,IAGAA,EAAAJ,cAGAI,EAAAJ,aAAAvK,eAAA3B,IAGA5B,KAAAgO,WAAAE,EAAAJ,aAAAlM,GAAAsM,GAEAlO,KAAAmO,mBAAAvM,EAAAsM,GACAA,EAAAL,SAGA7N,KAAAqO,gBAAAH,IAMAA,EAAAP,QAAA/L,CAEA,CAQAkH,YAAAD,EAAA6E,GAEA,IAAAgB,EAAA1O,KAAAyN,eAAAC,GAEA,IAAA,IAAAnN,EAAA,EAAAA,EAAAsI,EAAA7H,OAAAT,IAGAP,KAAAyO,eAAA5F,EAAAtI,GAAAmO,GAKA,OAFA1O,KAAAoO,kBAAAM,GAEAA,EAAAf,MACA,EXi5BA,EAAE,CAAC,GAAG,GAAG,CAAC,SAASlN,EAAQf,EAAOD,GYr/BlCC,EAAAD;;;;;;;;;;AA1DA,MAKAwB,cAEAjB,KAAAqN,UAAA,CAAA,CACA,CAWAsB,SAAAC,EAAAC,EAAAC,GAKA,OAHAF,EAAArL,eAAAsL,EAAAC,MACAF,EAAAC,EAAAC,IAAA,CAAA,GAEAF,EAAAC,EAAAC,GACA,CASA5G,WAAAoF,EAAAC,EAAAC,GAEA,GAAAF,EAAAtM,OAAA,EACA,OAAA,EAEA,GAAA,iBAAAuM,GAAAA,EAAAvM,OAAA,EACA,OAAA,EAEA,IAAA+N,EAAA/O,KAAAqN,UAGA,IAAA,IAAA9M,EAAA,EAAAA,EAAA+M,EAAAtM,OAAAT,IACAwO,EAAA/O,KAAA2O,SAAAI,EAAAzB,EAAA/M,GAQA,OANAwO,EAAAR,aAAAjB,EACAyB,EAAAT,WAAA,iBAAAf,GAAAA,EAAAvM,OAAA,EAAAuM,EAAAD,EACAyB,EAAAP,MAAA,mBAAAhB,EAAAA,EACA,iBAAAA,EAAA,IAAAA,EACAwB,GAAAA,GAEA,CACA,EZ+jCA,EAAE,CAAC,GAAG,GAAG,CAAC,SAASvO,EAAQf,EAAOD,Ga/nClC,IAOAwP,EACAC,EARApH,EAAApI,EAAAD,QAAA,CAAA,EAUA,SAAA0P,IACA,MAAA,IAAAvO,MAAA,kCACA,CACA,SAAAwO,IACA,MAAA,IAAAxO,MAAA,oCACA,CAqBA,SAAAyO,EAAAC,GACA,GAAAL,IAAAM,WAEA,OAAAA,WAAAD,EAAA,GAGA,IAAAL,IAAAE,IAAAF,IAAAM,WAEA,OADAN,EAAAM,WACAA,WAAAD,EAAA,GAEA,IAEA,OAAAL,EAAAK,EAAA,EACA,CAAA,MAAAnP,GACA,IAEA,OAAA8O,EAAAlO,KAAA,KAAAuO,EAAA,EACA,CAAA,MAAAnP,GAEA,OAAA8O,EAAAlO,KAAAf,KAAAsP,EAAA,EACA,CACA,CAGA,EA5CA,WACA,IAEAL,EADA,mBAAAM,WACAA,WAEAJ,CAEA,CAAA,MAAAhP,GACA8O,EAAAE,CACA,CACA,IAEAD,EADA,mBAAAM,aACAA,aAEAJ,CAEA,CAAA,MAAAjP,GACA+O,EAAAE,CACA,CACA,CAnBA,GAwEA,IAEAK,EAFAC,EAAA,GACAC,GAAA,EAEAC,GAAA,EAEA,SAAAC,IACAF,GAAAF,IAGAE,GAAA,EACAF,EAAAzO,OACA0O,EAAAD,EAAAK,OAAAJ,GAEAE,GAAA,EAEAF,EAAA1O,QACA+O,IAEA,CAEA,SAAAA,IACA,IAAAJ,EAAA,CAGA,IAAAK,EAAAX,EAAAQ,GACAF,GAAA,EAGA,IADA,IAAAM,EAAAP,EAAA1O,OACAiP,GAAA,CAGA,IAFAR,EAAAC,EACAA,EAAA,KACAE,EAAAK,GACAR,GACAA,EAAAG,GAAAM,MAGAN,GAAA,EACAK,EAAAP,EAAA1O,MACA,CACAyO,EAAA,KACAE,GAAA,EAnEA,SAAAQ,GACA,GAAAjB,IAAAM,aAEA,OAAAA,aAAAW,GAGA,IAAAjB,IAAAE,IAAAF,IAAAM,aAEA,OADAN,EAAAM,aACAA,aAAAW,GAEA,IAEA,OAAAjB,EAAAiB,EACA,CAAA,MAAAhQ,GACA,IAEA,OAAA+O,EAAAnO,KAAA,KAAAoP,EACA,CAAA,MAAAhQ,GAGA,OAAA+O,EAAAnO,KAAAf,KAAAmQ,EACA,CACA,CAIA,CA0CAC,CAAAJ,EAlBA,CAmBA,CAgBA,SAAAK,EAAAf,EAAAgB,GACAtQ,KAAAsP,IAAAA,EACAtP,KAAAsQ,MAAAA,CACA,CAWA,SAAAC,IAAA,CA5BAzI,EAAA0I,SAAA,SAAAlB,GACA,IAAAmB,EAAA,IAAAtG,MAAAuG,UAAA1P,OAAA,GACA,GAAA0P,UAAA1P,OAAA,EACA,IAAA,IAAAT,EAAA,EAAAA,EAAAmQ,UAAA1P,OAAAT,IACAkQ,EAAAlQ,EAAA,GAAAmQ,UAAAnQ,GAGAmP,EAAA1J,KAAA,IAAAqK,EAAAf,EAAAmB,IACA,IAAAf,EAAA1O,QAAA2O,GACAN,EAAAU,EAEA,EAOAM,EAAAM,UAAAT,IAAA,WACAlQ,KAAAsP,IAAAsB,MAAA,KAAA5Q,KAAAsQ,MACA,EACAxI,EAAA+I,MAAA,UACA/I,EAAAgJ,SAAA,EACAhJ,EAAAa,IAAA,CAAA,EACAb,EAAAiJ,KAAA,GACAjJ,EAAAkJ,QAAA,GACAlJ,EAAAmJ,SAAA,CAAA,EAIAnJ,EAAAoJ,GAAAX,EACAzI,EAAAqJ,YAAAZ,EACAzI,EAAAsJ,KAAAb,EACAzI,EAAAuJ,IAAAd,EACAzI,EAAAwJ,eAAAf,EACAzI,EAAAyJ,mBAAAhB,EACAzI,EAAA0J,KAAAjB,EACAzI,EAAA2J,gBAAAlB,EACAzI,EAAA4J,oBAAAnB,EAEAzI,EAAA6J,UAAA,SAAAC,GAAA,MAAA,EAAA,EAEA9J,EAAA+J,QAAA,SAAAD,GACA,MAAA,IAAAhR,MAAA,mCACA,EAEAkH,EAAAgK,IAAA,WAAA,MAAA,GAAA,EACAhK,EAAAiK,MAAA,SAAAC,GACA,MAAA,IAAApR,MAAA,iCACA,EACAkH,EAAAmK,MAAA,WAAA,OAAA,CAAA,CbmoCA,EAAE,CAAC,GAAG,GAAG,CAAC,SAASxR,EAAQf,EAAOD,Gc1zClC,IAAAyS,EAAAzR,EAAA,cAEA,iBAAAZ,QAAAA,OAAA0D,eAAA,WAEA1D,OAAAI,MAAAiS,GAGAxS,EAAAD,QAAAyS,Cd4zCA,EAAE,CAAC,aAAa,KAAK,GAAG,CAAC,SAASzR,EAAQf,EAAOD,GextCjDC,EAAAD,QA3GA,MAEAwB,YAAA4D,EAAAsN,GAEAnS,KAAAoS,MAAAvN,EAIA7E,KAAAqS,SACA,CACAC,SAAA,kBACAC,YAAA,mBACAC,QAAA,+BACAC,UAAA,8BAEAC,mBAAA,MAKA1S,KAAA2S,gBAAA,CACA,KAAA,KACA,IAAA,IACAzS,EAAA,KACA,KAAA,IACAE,EAAA,KACA,KAAA,IACAC,EAAA,KACA,KAAA,IACAuS,MAAA,SACA,SAAA,QACAC,MAAA,SACA,SAAA,SAKA7S,KAAA8S,eAAA,IAAA,EACA,CAIAC,OAAAC,KAAAC,GAEA,OAAA3M,OAAAC,OAAAyM,KAAAC,EACA,CAEAC,eAAAlE,GAEA,OAAAhP,KAAA8S,eAAA9D,EACA,CAEAmE,iBAAAnE,GAGA,OADAhP,KAAAkT,eAAA7H,KAAArL,KAEA,CAWAoT,sBAAAjB,EAAAnD,GA2BA,OAvBAhP,KAAAqT,eAAA,SAAAlB,EACAxQ,QAAA3B,KAAAqS,SAAAG,SACAc,GAEA,KAAAtT,KAAA2S,gBAAAW,OAEA3R,QAAA3B,KAAAqS,SAAAE,aAAAvS,KAAAqS,SAAAK,oBACA,CAAAY,EAAAC,IAEA,QAAAC,mBAAAD,YAEA5R,QAAA3B,KAAAqS,SAAAC,UAAAtS,KAAAqS,SAAAK,oBACA,CAAAY,EAAAC,IAEA,OAAAC,mBAAAD,gBACA,OAGAvT,KAAAqT,eAAA,mCAAArT,KAAAqT,oBACArT,KAAAqT,eAAA,oFAAArT,KAAAqT,8BAEArT,KAAA8S,eAAA,IAAAW,SAAA,sBAAAzT,KAAAqT,qBAEA,IAAArE,EAEAhP,KAAA8S,eAAA9D,IAKAhP,KAAA0T,uBAAA,mBAAA1T,KAAAqT,eAAA,IAEArT,KAAAmT,mBACA,Efw0CA,EAAE,CAAC,GAAG,GAAG,CAAC,SAAS1S,EAAQf,EAAOD,GgBh7ClC,MAAAkU,EAAAlT,EAAA,+BAoDAf,EAAAD,QAlDA,MAEAwB,YAAA4D,GAEA7E,KAAAoS,MAAAvN,CACA,CAIAkO,OAAAC,KAAAC,GAEA,OAAA3M,OAAAC,OAAAyM,KAAAC,EACA,CAKAW,SAAAzB,EAAAnD,GAIA,OAFA,IAAA2E,EAAA3T,KAAAoS,MAAAD,GAEAiB,sBAAAjB,EAAAnD,EACA,CAOA6E,MAAAC,EAAAC,EAAAC,GAEA,IAAAC,EAAA,IAAAH,GAEAI,EAAA,iBAAAH,EAAAA,EAAA,EACAI,OAAA,IAAAH,EAAAA,EAAA,GAEA,GAAAE,GAAA,EAEA,OAAAC,EAGA,KAAAF,EAAAjT,QAEAmT,EAAAnO,KAAAiO,EAAAG,OAAA,EAAAF,IAGA,OAAAC,CACA,EhBq7CA,EAAE,CAAC,8BAA8B,KAAK,GAAG,CAAC,SAAS1T,EAAQf,EAAOD;;;;;;AiBj+ClE,MAAA4U,EAAA5T,EAAA,kBAAAyI,cACAoL,EAAA7T,EAAA,cAAAqL,UACAyI,EAAA9T,EAAA,aAAAkE,SAEA6P,EAAA/T,EAAA,sBAmCAf,EAAAD,QAjCA,MAEAwB,YAAA0G,GAEA,IAAA7C,EAAA,IAAAuP,EAAA1M,GAEA3H,KAAAyU,gBAAA3P,EAGA9E,KAAA0U,QAAA,IAAAJ,EAAAtU,KAAAyU,gBAAA7K,UAEA5J,KAAAwE,IAAA,IAAA+P,EAAAvU,KAAAyU,gBAAA7K,UACA5J,KAAAwE,IAAAtC,aAEAlC,KAAA2U,QAAA,IAAAH,EAAAxU,KACA,CAEA4J,eAEA,OAAA5J,KAAAyU,gBAAA7K,QACA,CAEAwI,YAEA,OAAApS,IACA,CAEAgN,UAEA,OAAAhN,KAAA0U,QAAA1H,SACA,EjB2+CA,EAAE,CAAC,qBAAqB,GAAG,YAAY,EAAE,iBAAiB,EAAE,aAAa,MAAM,CAAC,EAAE,CAAC,IFphDnF,CEohDwF,GACxF","file":"fable.min.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","/**\n* Base Logger Class\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\nclass BaseLogger\n{\n\tconstructor(pLogStreamSettings, pFableLog)\n\t{\n\t\t// This should not possibly be able to be instantiated without a settings object\n\t\tthis._Settings = pLogStreamSettings;\n\n\t\t// The base logger does nothing but associate a UUID with itself\n\t\t// We added this as the mechanism for tracking loggers to allow multiple simultaneous streams\n\t\t// to the same provider.\n\t\tthis.loggerUUID = this.generateInsecureUUID();\n\n\t\t// Eventually we can use this array to ompute which levels the provider allows.\n\t\t// For now it's just used to precompute some string concatenations.\n\t\tthis.levels = (\n\t\t\t[\n\t\t\t\t\"trace\",\n\t\t\t\t\"debug\",\n\t\t\t\t\"info\",\n\t\t\t\t\"warn\",\n\t\t\t\t\"error\",\n\t\t\t\t\"fatal\"\n\t\t\t]);\n\t}\n\n\t// This is meant to generate programmatically insecure UUIDs to identify loggers\n\tgenerateInsecureUUID()\n\t{\n\t\tlet tmpDate = new Date().getTime();\n\t\tlet tmpUUID = 'LOGSTREAM-xxxxxx-yxxxxx'.replace(/[xy]/g,\n\t\t\t\t(pCharacter) =>\n\t\t\t\t{\n\t\t\t\t\t// Funny algorithm from w3resource that is twister-ish without the deep math and security\n\t\t\t\t\t// ..but good enough for unique log stream identifiers\n\t\t\t\t\tlet tmpRandomData = (tmpDate + Math.random()*16)%16 | 0;\n\t\t\t\t\ttmpDate = Math.floor(tmpDate/16);\n\n\t\t\t\t\treturn (pCharacter =='x' ? tmpRandomData : (tmpRandomData&0x3|0x8)).toString(16);\n\t\t\t\t});\n\t\treturn tmpUUID;\n\t}\n\n\tinitialize()\n\t{\n\t\t// No operation.\n\t}\n\n\ttrace(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"trace\", pLogText, pLogObject);\n\t}\n\n\tdebug(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"debug\", pLogText, pLogObject);\n\t}\n\n\tinfo(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"info\", pLogText, pLogObject);\n\t}\n\n\twarn(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"warn\", pLogText, pLogObject);\n\t}\n\n\terror(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"error\", pLogText, pLogObject);\n\t}\n\n\tfatal(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"fatal\", pLogText, pLogObject);\n\t}\n\n\twrite(pLogLevel, pLogText, pLogObject)\n\t{\n\t\t// The base logger does nothing.\n\t\treturn true;\n\t}\n}\n\nmodule.exports = BaseLogger;\n","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.Fable = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n/**\n* Base Logger Class\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\nclass BaseLogger\n{\n\tconstructor(pLogStreamSettings, pFableLog)\n\t{\n\t\t// This should not possibly be able to be instantiated without a settings object\n\t\tthis._Settings = pLogStreamSettings;\n\n\t\t// The base logger does nothing but associate a UUID with itself\n\t\t// We added this as the mechanism for tracking loggers to allow multiple simultaneous streams\n\t\t// to the same provider.\n\t\tthis.loggerUUID = this.generateInsecureUUID();\n\n\t\t// Eventually we can use this array to ompute which levels the provider allows.\n\t\t// For now it's just used to precompute some string concatenations.\n\t\tthis.levels = (\n\t\t\t[\n\t\t\t\t\"trace\",\n\t\t\t\t\"debug\",\n\t\t\t\t\"info\",\n\t\t\t\t\"warn\",\n\t\t\t\t\"error\",\n\t\t\t\t\"fatal\"\n\t\t\t]);\n\t}\n\n\t// This is meant to generate programmatically insecure UUIDs to identify loggers\n\tgenerateInsecureUUID()\n\t{\n\t\tlet tmpDate = new Date().getTime();\n\t\tlet tmpUUID = 'LOGSTREAM-xxxxxx-yxxxxx'.replace(/[xy]/g,\n\t\t\t\t(pCharacter) =>\n\t\t\t\t{\n\t\t\t\t\t// Funny algorithm from w3resource that is twister-ish without the deep math and security\n\t\t\t\t\t// ..but good enough for unique log stream identifiers\n\t\t\t\t\tlet tmpRandomData = (tmpDate + Math.random()*16)%16 | 0;\n\t\t\t\t\ttmpDate = Math.floor(tmpDate/16);\n\n\t\t\t\t\treturn (pCharacter =='x' ? tmpRandomData : (tmpRandomData&0x3|0x8)).toString(16);\n\t\t\t\t});\n\t\treturn tmpUUID;\n\t}\n\n\tinitialize()\n\t{\n\t\t// No operation.\n\t}\n\n\ttrace(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"trace\", pLogText, pLogObject);\n\t}\n\n\tdebug(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"debug\", pLogText, pLogObject);\n\t}\n\n\tinfo(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"info\", pLogText, pLogObject);\n\t}\n\n\twarn(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"warn\", pLogText, pLogObject);\n\t}\n\n\terror(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"error\", pLogText, pLogObject);\n\t}\n\n\tfatal(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"fatal\", pLogText, pLogObject);\n\t}\n\n\twrite(pLogLevel, pLogText, pLogObject)\n\t{\n\t\t// The base logger does nothing.\n\t\treturn true;\n\t}\n}\n\nmodule.exports = BaseLogger;\n\n},{}],2:[function(require,module,exports){\n/**\n* Default Logger Provider Function\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\n// Return the providers that are available without extensions loaded\ngetDefaultProviders = () =>\n{\n\tlet tmpDefaultProviders = {};\n\n\ttmpDefaultProviders.console = require('./Fable-Log-Logger-Console.js');\n\n\ttmpDefaultProviders.default = tmpDefaultProviders.console;\n\n\treturn tmpDefaultProviders;\n}\n\nmodule.exports = getDefaultProviders();\n},{\"./Fable-Log-Logger-Console.js\":4}],3:[function(require,module,exports){\nmodule.exports=[\n    {\n        \"loggertype\": \"console\",\n        \"streamtype\": \"console\",\n        \"level\": \"trace\"\n    }\n]\n},{}],4:[function(require,module,exports){\nlet libBaseLogger = require('./Fable-Log-BaseLogger.js');\n\nclass ConsoleLogger extends libBaseLogger\n{\n\tconstructor(pLogStreamSettings, pFableLog)\n\t{\n\t\tsuper(pLogStreamSettings);\n\n\t\tthis._ShowTimeStamps = pLogStreamSettings.hasOwnProperty('showtimestamps') ? (pLogStreamSettings.showtimestamps == true) : false;\n\t\tthis._FormattedTimeStamps = pLogStreamSettings.hasOwnProperty('formattedtimestamps') ? (pLogStreamSettings.formattedtimestamps == true) : false;\n\n\t\tthis._ContextMessage = pLogStreamSettings.hasOwnProperty('Context') ? `(${pLogStreamSettings.Context})` : \n\t\t\t\t\t\t\t\tpFableLog._Settings.hasOwnProperty('Product') ? `(${pFableLog._Settings.Product})` :\n\t\t\t\t\t\t\t\t'Unnamed_Log_Context';\n\n\t\t// Allow the user to decide what gets output to the console\n\t\tthis._OutputLogLinesToConsole = pLogStreamSettings.hasOwnProperty('outputloglinestoconsole') ? pLogStreamSettings.outputloglinestoconsole : true;\n\t\tthis._OutputObjectsToConsole = pLogStreamSettings.hasOwnProperty('outputobjectstoconsole') ? pLogStreamSettings.outputobjectstoconsole : true;\n\n\t\t// Precompute the prefix for each level\n\t\tthis.prefixCache = {};\n\t\tfor (let i = 0; i <= this.levels.length; i++)\n\t\t{\n\t\t\tthis.prefixCache[this.levels[i]] = `[${this.levels[i]}] ${this._ContextMessage}: `;\n\n\t\t\tif (this._ShowTimeStamps)\n\t\t\t{\n\t\t\t\t// If there is a timestamp we need a to prepend space before the prefixcache string, since the timestamp comes first\n\t\t\t\tthis.prefixCache[this.levels[i]] = ' '+this.prefixCache[this.levels[i]];\n\t\t\t}\n\t\t}\n\t}\n\n\twrite(pLevel, pLogText, pObject)\n\t{\n\t\tlet tmpTimeStamp = '';\n\t\tif (this._ShowTimeStamps && this._FormattedTimeStamps)\n\t\t{\n\t\t\ttmpTimeStamp = (new Date()).toISOString();\n\t\t}\n\t\telse if (this._ShowTimeStamps)\n\t\t{\n\t\t\ttmpTimeStamp = +new Date();\n\t\t}\n\n\t\tlet tmpLogLine = `${tmpTimeStamp}${this.prefixCache[pLevel]}${pLogText}`;\n\n\t\tif (this._OutputLogLinesToConsole)\n\t\t{\n\t\t\tconsole.log(tmpLogLine);\n\t\t}\n\n\t\t// Write out the object on a separate line if it is passed in\n\t\tif (this._OutputObjectsToConsole && (typeof(pObject) !== 'undefined'))\n\t\t{\n\t\t\tconsole.log(JSON.stringify(pObject, null, 2));\n\t\t}\n\n\t\t// Provide an easy way to be overridden and be consistent\n\t\treturn tmpLogLine;\n\t}\n}\n\nmodule.exports = ConsoleLogger;\n},{\"./Fable-Log-BaseLogger.js\":1}],5:[function(require,module,exports){\n/**\n* Fable Logging Add-on\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable Logger\n*/\n\n/**\n* Fable Solution Log Wrapper Main Class\n*\n* @class FableLog\n* @constructor\n*/\nclass FableLog\n{\n\tconstructor(pFableSettings, pFable)\n\t{\n\t\tlet tmpSettings = (typeof(pFableSettings) === 'object') ? pFableSettings : {}\n\t\tthis._Settings = tmpSettings;\n\n\t\tthis._Providers = require('./Fable-Log-DefaultProviders-Node.js');\n\n\t\tthis._StreamDefinitions = (tmpSettings.hasOwnProperty('LogStreams')) ? tmpSettings.LogStreams : require('./Fable-Log-DefaultStreams.json');\n\n\t\tthis.logStreams = [];\n\n\t\t// This object gets decorated for one-time instantiated providers that\n\t\t//  have multiple outputs, such as bunyan.\n\t\tthis.logProviders = {};\n\n\t\t// A hash list of the GUIDs for each log stream, so they can't be added to the set more than one time\n\t\tthis.activeLogStreams = {};\n\n\t\tthis.logStreamsTrace = [];\n\t\tthis.logStreamsDebug = [];\n\t\tthis.logStreamsInfo = [];\n\t\tthis.logStreamsWarn = [];\n\t\tthis.logStreamsError = [];\n\t\tthis.logStreamsFatal = [];\n\n\t\tthis.datumDecorator = (pDatum) => pDatum;\n\n\t\tthis.uuid = (typeof(tmpSettings.Product) === 'string') ? tmpSettings.Product : 'Default';\n\t}\n\n\taddLogger(pLogger, pLevel)\n\t{\n\t\t// Bail out if we've already created one.\n\t\tif (this.activeLogStreams.hasOwnProperty(pLogger.loggerUUID))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// Add it to the streams and to the mutex\n\t\tthis.logStreams.push(pLogger);\n\t\tthis.activeLogStreams[pLogger.loggerUUID] = true;\n\n\t\t// Make sure a kosher level was passed in\n\t\tswitch (pLevel)\n\t\t{\n\t\t\tcase 'trace':\n\t\t\t\tthis.logStreamsTrace.push(pLogger);\n\t\t\tcase 'debug':\n\t\t\t\tthis.logStreamsDebug.push(pLogger);\n\t\t\tcase 'info':\n\t\t\t\tthis.logStreamsInfo.push(pLogger);\n\t\t\tcase 'warn':\n\t\t\t\tthis.logStreamsWarn.push(pLogger);\n\t\t\tcase 'error':\n\t\t\t\tthis.logStreamsError.push(pLogger);\n\t\t\tcase 'fatal':\n\t\t\t\tthis.logStreamsFatal.push(pLogger);\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tsetDatumDecorator(fDatumDecorator)\n\t{\n\t\tif (typeof(fDatumDecorator) === 'function')\n\t\t{\n\t\t\tthis.datumDecorator = fDatumDecorator;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.datumDecorator = (pDatum) => pDatum;\n\t\t}\n\t}\n\n\ttrace(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsTrace.length; i++)\n\t\t{\n\t\t\tthis.logStreamsTrace[i].trace(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tdebug(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsDebug.length; i++)\n\t\t{\n\t\t\tthis.logStreamsDebug[i].debug(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tinfo(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsInfo.length; i++)\n\t\t{\n\t\t\tthis.logStreamsInfo[i].info(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\twarn(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsWarn.length; i++)\n\t\t{\n\t\t\tthis.logStreamsWarn[i].warn(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\terror(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsError.length; i++)\n\t\t{\n\t\t\tthis.logStreamsError[i].error(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tfatal(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsFatal.length; i++)\n\t\t{\n\t\t\tthis.logStreamsFatal[i].fatal(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tinitialize()\n\t{\n\t\t// \"initialize\" each logger as defined in the logging parameters\n\t\tfor (let i = 0; i < this._StreamDefinitions.length; i++)\n\t\t{\n\t\t\tlet tmpStreamDefinition = Object.assign({loggertype:'default',streamtype:'console',level:'info'},this._StreamDefinitions[i]);\n\n\t\t\tif (!this._Providers.hasOwnProperty(tmpStreamDefinition.loggertype))\n\t\t\t{\n\t\t\t\tconsole.log(`Error initializing log stream: bad loggertype in stream definition ${JSON.stringify(tmpStreamDefinition)}`);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.addLogger(new this._Providers[tmpStreamDefinition.loggertype](tmpStreamDefinition, this), tmpStreamDefinition.level);\n\t\t\t}\n\t\t}\n\n\t\t// Now initialize each one.\n\t\tfor (let i = 0; i < this.logStreams.length; i++)\n\t\t{\n\t\t\tthis.logStreams[i].initialize();\n\t\t}\n\t}\n\n\tlogTime(pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time';\n\t\tlet tmpTime = new Date();\n\t\tthis.info(`${tmpMessage} ${tmpTime} (epoch ${+tmpTime})`, pDatum);\n\t}\n\n\t// Get a timestamp\n\tgetTimeStamp()\n\t{\n\t\treturn +new Date();\n\t}\n\n\tgetTimeDelta(pTimeStamp)\n\t{\n\t\tlet tmpEndTime = +new Date();\n\t\treturn tmpEndTime-pTimeStamp;\n\t}\n\n\t// Log the delta between a timestamp, and now with a message\n\tlogTimeDelta(pTimeDelta, pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time Measurement';\n\t\tlet tmpDatum = (typeof(pDatum) === 'object') ? pDatum : {};\n\n\t\tlet tmpEndTime = +new Date();\n\n\t\tthis.info(`${tmpMessage} logged at (epoch ${+tmpEndTime}) took (${pTimeDelta}ms)`, pDatum);\n\t}\n\n\tlogTimeDeltaHuman(pTimeDelta, pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time Measurement';\n\n\t\tlet tmpEndTime = +new Date();\n\n\t\tlet tmpMs = parseInt(pTimeDelta%1000);\n\t\tlet tmpSeconds = parseInt((pTimeDelta/1000)%60);\n\t\tlet tmpMinutes = parseInt((pTimeDelta/(1000*60))%60);\n\t\tlet tmpHours = parseInt(pTimeDelta/(1000*60*60));\n\n\t\ttmpMs = (tmpMs < 10) ? \"00\"+tmpMs : (tmpMs < 100) ? \"0\"+tmpMs : tmpMs;\n\t\ttmpSeconds = (tmpSeconds < 10) ? \"0\"+tmpSeconds : tmpSeconds;\n\t\ttmpMinutes = (tmpMinutes < 10) ? \"0\"+tmpMinutes : tmpMinutes;\n\t\ttmpHours = (tmpHours < 10) ? \"0\"+tmpHours : tmpHours;\n\n\t\tthis.info(`${tmpMessage} logged at (epoch ${+tmpEndTime}) took (${pTimeDelta}ms) or (${tmpHours}:${tmpMinutes}:${tmpSeconds}.${tmpMs})`, pDatum);\n\t}\n\n\tlogTimeDeltaRelative(pStartTime, pMessage, pDatum)\n\t{\n\t\tthis.logTimeDelta(this.getTimeDelta(pStartTime), pMessage, pDatum);\n\t}\n\n\tlogTimeDeltaRelativeHuman(pStartTime, pMessage, pDatum)\n\t{\n\t\tthis.logTimeDeltaHuman(this.getTimeDelta(pStartTime), pMessage, pDatum);\n\t}\n}\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new FableLog(pSettings);\n}\n\n\nmodule.exports = {new:autoConstruct, FableLog:FableLog};\n\n},{\"./Fable-Log-DefaultProviders-Node.js\":2,\"./Fable-Log-DefaultStreams.json\":3}],6:[function(require,module,exports){\nmodule.exports={\n\t\"Product\": \"ApplicationNameHere\",\n\t\"ProductVersion\": \"0.0.0\",\n\n\t\"ConfigFile\": false,\n\n\t\"LogStreams\":\n\t[\n\t\t{\n\t\t\t\"level\": \"trace\"\n\t\t}\n\t]\n}\n\n},{}],7:[function(require,module,exports){\n(function (process){(function (){\n/**\n* Fable Settings Template Processor\n*\n* This class allows environment variables to come in via templated expressions, and defaults to be set.\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable Settings\n*/\n\nclass FableSettingsTemplateProcessor\n{\n\tconstructor(pDependencies)\n\t{\n        // Use a no-dependencies templating engine to parse out environment variables\n\t\tthis.templateProcessor = new pDependencies.precedent();\n\n        // TODO: Make the environment variable wrap expression demarcation characters configurable?\n\t\tthis.templateProcessor.addPattern('${', '}',\n\t\t\t(pTemplateValue)=>\n\t\t\t{\n\t\t\t\tlet tmpTemplateValue = pTemplateValue.trim();\n\n\t\t\t\tlet tmpSeparatorIndex = tmpTemplateValue.indexOf('|');\n\n\t\t\t\t// If there is no pipe, the default value will end up being whatever the variable name is.\n\t\t\t\tlet tmpDefaultValue = tmpTemplateValue.substring(tmpSeparatorIndex+1);\n\n\t\t\t\tlet tmpEnvironmentVariableName = (tmpSeparatorIndex > -1) ? tmpTemplateValue.substring(0, tmpSeparatorIndex) : tmpTemplateValue;\n\n\t\t\t\tif (process.env.hasOwnProperty(tmpEnvironmentVariableName))\n\t\t\t\t{\n\t\t\t\t\treturn process.env[tmpEnvironmentVariableName];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn tmpDefaultValue;\n\t\t\t\t}\n\t\t\t});\n    }\n\n    parseSetting(pString)\n    {\n        return this.templateProcessor.parseString(pString);\n    }\n}\n\nmodule.exports = FableSettingsTemplateProcessor;\n}).call(this)}).call(this,require('_process'))\n\n},{\"_process\":14}],8:[function(require,module,exports){\n/**\n* Fable Settings Add-on\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable Settings\n*/\n\nconst libPrecedent = require('precedent');\nconst libFableSettingsTemplateProcessor = require('./Fable-Settings-TemplateProcessor.js');\n\nclass FableSettings\n{\n\tconstructor(pFableSettings)\n\t{\n\t\t// Expose the dependencies for downstream re-use\n\t\tthis.dependencies = (\n\t\t\t{\n\t\t\t\tprecedent: libPrecedent\n\t\t\t});\n\n\t\t// Initialize the settings value template processor\n\t\tthis.settingsTemplateProcessor = new libFableSettingsTemplateProcessor(this.dependencies);\n\n\t\t// set straight away so anything that uses it respects the initial setting\n\t\tthis._configureEnvTemplating(pFableSettings);\n\n\t\tthis.default = this.buildDefaultSettings();\n\n\t\t// Construct a new settings object\n\t\tlet tmpSettings = this.merge(pFableSettings, this.buildDefaultSettings());\n\n\t\t// The base settings object (what they were on initialization, before other actors have altered them)\n\t\tthis.base = JSON.parse(JSON.stringify(tmpSettings));\n\n\t\tif (tmpSettings.DefaultConfigFile)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// If there is a DEFAULT configuration file, try to load and merge it.\n\t\t\t\ttmpSettings = this.merge(require(tmpSettings.DefaultConfigFile), tmpSettings);\n\t\t\t}\n\t\t\tcatch (pException)\n\t\t\t{\n\t\t\t\t// Why this?  Often for an app we want settings to work out of the box, but\n\t\t\t\t// would potentially want to have a config file for complex settings.\n\t\t\t\tconsole.log('Fable-Settings Warning: Default configuration file specified but there was a problem loading it.  Falling back to base.');\n\t\t\t\tconsole.log('     Loading Exception: '+pException);\n\t\t\t}\n\t\t}\n\n\t\tif (tmpSettings.ConfigFile)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// If there is a configuration file, try to load and merge it.\n\t\t\t\ttmpSettings = this.merge(require(tmpSettings.ConfigFile), tmpSettings);\n\t\t\t}\n\t\t\tcatch (pException)\n\t\t\t{\n\t\t\t\t// Why this?  Often for an app we want settings to work out of the box, but\n\t\t\t\t// would potentially want to have a config file for complex settings.\n\t\t\t\tconsole.log('Fable-Settings Warning: Configuration file specified but there was a problem loading it.  Falling back to base.');\n\t\t\t\tconsole.log('     Loading Exception: '+pException);\n\t\t\t}\n\t\t}\n\n\t\tthis.settings = tmpSettings;\n\t}\n\n\t// Build a default settings object.  Use the JSON jimmy to ensure it is always a new object.\n\tbuildDefaultSettings()\n\t{\n\t\treturn JSON.parse(JSON.stringify(require('./Fable-Settings-Default')));\n\t}\n\n\t// Update the configuration for environment variable templating based on the current settings object\n\t_configureEnvTemplating(pSettings)\n\t{\n\t\t// default environment variable templating to on\n\t\tthis._PerformEnvTemplating = !pSettings || pSettings.NoEnvReplacement !== true;\n\t}\n\n\t// Resolve (recursive) any environment variables found in settings object.\n\t_resolveEnv(pSettings)\n\t{\n\t\tfor (const tmpKey in pSettings)\n\t\t{\n\t\t\tif (typeof(pSettings[tmpKey]) === 'object')\n\t\t\t{\n\t\t\t\tthis._resolveEnv(pSettings[tmpKey]);\n\t\t\t}\n\t\t\telse if (typeof(pSettings[tmpKey]) === 'string')\n\t\t\t{\n\t\t\t\tpSettings[tmpKey] = this.settingsTemplateProcessor.parseSetting(pSettings[tmpKey]);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Check to see if a value is an object (but not an array).\n\t */\n\t_isObject(value)\n\t{\n\t\treturn typeof(value) === 'object' && !Array.isArray(value);\n\t}\n\n\t/**\n\t * Merge two plain objects. Keys that are objects in both will be merged property-wise.\n\t */\n\t_deepMergeObjects(toObject, fromObject)\n\t{\n\t\tif (!fromObject || !this._isObject(fromObject))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tObject.keys(fromObject).forEach((key) =>\n\t\t{\n\t\t\tconst fromValue = fromObject[key];\n\t\t\tif (this._isObject(fromValue))\n\t\t\t{\n\t\t\t\tconst toValue = toObject[key];\n\t\t\t\tif (toValue && this._isObject(toValue))\n\t\t\t\t{\n\t\t\t\t\t// both are objects, so do a recursive merge\n\t\t\t\t\tthis._deepMergeObjects(toValue, fromValue);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttoObject[key] = fromValue;\n\t\t});\n\t\treturn toObject;\n\t}\n\n\t// Merge some new object into the existing settings.\n\tmerge(pSettingsFrom, pSettingsTo)\n\t{\n\t\t// If an invalid settings from object is passed in (e.g. object constructor without passing in anything) this should still work\n\t\tlet tmpSettingsFrom = (typeof(pSettingsFrom) === 'object') ? pSettingsFrom : {};\n\t\t// Default to the settings object if none is passed in for the merge.\n\t\tlet tmpSettingsTo = (typeof(pSettingsTo) === 'object') ? pSettingsTo : this.settings;\n\n\t\t// do not mutate the From object property values\n\t\tlet tmpSettingsFromCopy = JSON.parse(JSON.stringify(tmpSettingsFrom));\n\t\ttmpSettingsTo = this._deepMergeObjects(tmpSettingsTo, tmpSettingsFromCopy);\n\n\t\tif (this._PerformEnvTemplating)\n\t\t{\n\t\t\tthis._resolveEnv(tmpSettingsTo);\n\t\t}\n\t\t// Update env tempating config, since we just updated the config object, and it may have changed\n\t\tthis._configureEnvTemplating(tmpSettingsTo);\n\n\t\treturn tmpSettingsTo;\n\t}\n\n\t// Fill in settings gaps without overwriting settings that are already there\n\tfill(pSettingsFrom)\n\t{\n\t\t// If an invalid settings from object is passed in (e.g. object constructor without passing in anything) this should still work\n\t\tlet tmpSettingsFrom = (typeof(pSettingsFrom) === 'object') ? pSettingsFrom : {};\n\n\t\t// do not mutate the From object property values\n\t\tlet tmpSettingsFromCopy = JSON.parse(JSON.stringify(tmpSettingsFrom));\n\n\t\tthis.settings = this._deepMergeObjects(tmpSettingsFromCopy, this.settings);\n\n\t\treturn this.settings;\n\t}\n};\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new FableSettings(pSettings);\n}\n\nmodule.exports = {new:autoConstruct, FableSettings:FableSettings};\n},{\"./Fable-Settings-Default\":6,\"./Fable-Settings-TemplateProcessor.js\":7,\"precedent\":11}],9:[function(require,module,exports){\n/**\n* Random Byte Generator - Browser version\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\n// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\nclass RandomBytes\n{\n\tconstructor()\n\t{\n\n\t\t// getRandomValues needs to be invoked in a context where \"this\" is a Crypto\n\t\t// implementation. Also, find the complete implementation of crypto on IE11.\n\t\tthis.getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||\n                      \t\t(typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));\n\t}\n\n\t// WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n\tgenerateWhatWGBytes()\n\t{\n\t\tlet tmpBuffer = new Uint8Array(16); // eslint-disable-line no-undef\n\n\t\tthis.getRandomValues(tmpBuffer);\n\t\treturn tmpBuffer;\n\t}\n\n\t// Math.random()-based (RNG)\n\tgenerateRandomBytes()\n\t{\n\t\t// If all else fails, use Math.random().  It's fast, but is of unspecified\n\t\t// quality.\n\t\tlet tmpBuffer = new Uint8Array(16); // eslint-disable-line no-undef\n\n\t\tfor (let i = 0, tmpValue; i < 16; i++)\n\t\t{\n\t\t\tif ((i & 0x03) === 0)\n\t\t\t{\n\t\t\t\ttmpValue = Math.random() * 0x100000000;\n\t\t\t}\n\n\t\t\ttmpBuffer[i] = tmpValue >>> ((i & 0x03) << 3) & 0xff;\n\t\t}\n\n\t\treturn tmpBuffer;\n\t}\n\n\tgenerate()\n\t{\n\t\tif (this.getRandomValues)\n\t\t{\n\t\t\treturn this.generateWhatWGBytes();\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.generateRandomBytes();\n\t\t}\n\t}\n}\n\nmodule.exports = RandomBytes;\n\n},{}],10:[function(require,module,exports){\n/**\n* Fable UUID Generator\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable UUID\n*/\n\n/**\n* Fable Solution UUID Generation Main Class\n*\n* @class FableUUID\n* @constructor\n*/\n\nvar libRandomByteGenerator = require('./Fable-UUID-Random.js')\n\nclass FableUUID\n{\n\tconstructor(pSettings)\n\t{\n\t\t// Determine if the module is in \"Random UUID Mode\" which means just use the random character function rather than the v4 random UUID spec.\n\t\t// Note this allows UUIDs of various lengths (including very short ones) although guaranteed uniqueness goes downhill fast.\n\t\tthis._UUIDModeRandom = (typeof(pSettings) === 'object') && (pSettings.hasOwnProperty('UUIDModeRandom')) ? (pSettings.UUIDModeRandom == true) : false;\n\t\t// These two properties are only useful if we are in Random mode.  Otherwise it generates a v4 spec\n\t\t// Length for \"Random UUID Mode\" is set -- if not set it to 8\n\t\tthis._UUIDLength = (typeof(pSettings) === 'object') && (pSettings.hasOwnProperty('UUIDLength')) ? (pSettings.UUIDLength + 0) : 8;\n\t\t// Dictionary for \"Random UUID Mode\"\n\t\tthis._UUIDRandomDictionary = (typeof(pSettings) === 'object') && (pSettings.hasOwnProperty('UUIDDictionary')) ? (pSettings.UUIDDictionary + 0) : '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n\n\t\tthis.randomByteGenerator = new libRandomByteGenerator();\n\n\t\t// Lookup table for hex codes\n\t\tthis._HexLookup = [];\n\t\tfor (let i = 0; i < 256; ++i)\n\t\t{\n\t\t\tthis._HexLookup[i] = (i + 0x100).toString(16).substr(1);\n\t\t}\n\t}\n\n\t// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n\tbytesToUUID(pBuffer)\n\t{\n\t\tlet i = 0;\n\t\t// join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n\t\treturn ([\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], \n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]]\n\t\t\t\t]).join('');\n\t}\n\n\t// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n\tgenerateUUIDv4()\n\t{\n\t\tlet tmpBuffer = new Array(16);\n\t\tvar tmpRandomBytes = this.randomByteGenerator.generate();\n\n\t\t// Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\t\ttmpRandomBytes[6] = (tmpRandomBytes[6] & 0x0f) | 0x40;\n\t\ttmpRandomBytes[8] = (tmpRandomBytes[8] & 0x3f) | 0x80;\n\n\t\treturn this.bytesToUUID(tmpRandomBytes);\n\t}\n\n\t// Simple random UUID generation\n\tgenerateRandom()\n\t{\n\t\tlet tmpUUID = '';\n\n\t\tfor (let i = 0; i < this._UUIDLength; i++)\n\t\t{\n\t\t\ttmpUUID += this._UUIDRandomDictionary.charAt(Math.floor(Math.random() * (this._UUIDRandomDictionary.length-1)));\n\t\t}\n\n\t\treturn tmpUUID;\n\t}\n\n\t// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n\tgetUUID()\n\t{\n\t\tif (this._UUIDModeRandom)\n\t\t{\n\t\t\treturn this.generateRandom();\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.generateUUIDv4();\n\t\t}\n\t}\n}\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new FableUUID(pSettings);\n}\n\n\nmodule.exports = {new:autoConstruct, FableUUID:FableUUID};\n\n},{\"./Fable-UUID-Random.js\":9}],11:[function(require,module,exports){\n/**\n* Precedent Meta-Templating\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Process text streams, parsing out meta-template expressions.\n*/\nvar libWordTree = require(`./WordTree.js`);\nvar libStringParser = require(`./StringParser.js`);\n\nclass Precedent\n{\n\t/**\n\t * Precedent Constructor\n\t */\n\tconstructor()\n\t{\n\t\tthis.WordTree = new libWordTree();\n\t\t\n\t\tthis.StringParser = new libStringParser();\n\n\t\tthis.ParseTree = this.WordTree.ParseTree;\n\t}\n\t\n\t/**\n\t * Add a Pattern to the Parse Tree\n\t * @method addPattern\n\t * @param {Object} pTree - A node on the parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @param {number} pIndex - callback function\n\t * @return {bool} True if adding the pattern was successful\n\t */\n\taddPattern(pPatternStart, pPatternEnd, pParser)\n\t{\n\t\treturn this.WordTree.addPattern(pPatternStart, pPatternEnd, pParser);\n\t}\n\t\n\t/**\n\t * Parse a string with the existing parse tree\n\t * @method parseString\n\t * @param {string} pString - The string to parse\n\t * @return {string} The result from the parser\n\t */\n\tparseString(pString)\n\t{\n\t\treturn this.StringParser.parseString(pString, this.ParseTree);\n\t}\n}\n\nmodule.exports = Precedent;\n\n},{\"./StringParser.js\":12,\"./WordTree.js\":13}],12:[function(require,module,exports){\n/**\n* String Parser\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Parse a string, properly processing each matched token in the word tree.\n*/\n\nclass StringParser\n{\n\t/**\n\t * StringParser Constructor\n\t */\n\tconstructor()\n\t{\n\t}\n\t\n\t/**\n\t * Create a fresh parsing state object to work with.\n\t * @method newParserState\n\t * @param {Object} pParseTree - A node on the parse tree to begin parsing from (usually root)\n\t * @return {Object} A new parser state object for running a character parser on\n\t * @private\n\t */\n\tnewParserState (pParseTree)\n\t{\n\t\treturn (\n\t\t{\n\t\t\tParseTree: pParseTree,\n\n\t\t\tOutput: '',\n\t\t\tOutputBuffer: '',\n\n\t\t\tPattern: false,\n\n\t\t\tPatternMatch: false,\n\t\t\tPatternMatchOutputBuffer: ''\n\t\t});\n\t}\n\t\t\n\t/**\n\t * Assign a node of the parser tree to be the next potential match.\n\t * If the node has a PatternEnd property, it is a valid match and supercedes the last valid match (or becomes the initial match).\n\t * @method assignNode\n\t * @param {Object} pNode - A node on the parse tree to assign\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tassignNode (pNode, pParserState)\n\t{\n\t\tpParserState.PatternMatch = pNode;\n\n\t\t// If the pattern has a END we can assume it has a parse function...\n\t\tif (pParserState.PatternMatch.hasOwnProperty('PatternEnd'))\n\t\t{\n\t\t\t// ... this is the legitimate start of a pattern.\n\t\t\tpParserState.Pattern = pParserState.PatternMatch;\n\t\t}\n\t}\n\t\n\t/**\n\t * Append a character to the output buffer in the parser state.\n\t * This output buffer is used when a potential match is being explored, or a match is being explored.\n\t * @method appendOutputBuffer\n\t * @param {string} pCharacter - The character to append\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tappendOutputBuffer (pCharacter, pParserState)\n\t{\n\t\tpParserState.OutputBuffer += pCharacter;\n\t}\n\t\n\t/**\n\t * Flush the output buffer to the output and clear it.\n\t * @method flushOutputBuffer\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tflushOutputBuffer (pParserState)\n\t{\n\t\tpParserState.Output += pParserState.OutputBuffer;\n\t\tpParserState.OutputBuffer = '';\n\t}\n\n\t\n\t/**\n\t * Check if the pattern has ended.  If it has, properly flush the buffer and start looking for new patterns.\n\t * @method checkPatternEnd\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tcheckPatternEnd (pParserState)\n\t{\n\t\tif ((pParserState.OutputBuffer.length >= pParserState.Pattern.PatternEnd.length+pParserState.Pattern.PatternStart.length) && \n\t\t\t(pParserState.OutputBuffer.substr(-pParserState.Pattern.PatternEnd.length) === pParserState.Pattern.PatternEnd))\n\t\t{\n\t\t\t// ... this is the end of a pattern, cut off the end tag and parse it.\n\t\t\t// Trim the start and end tags off the output buffer now\n\t\t\tpParserState.OutputBuffer = pParserState.Pattern.Parse(pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStart.length, pParserState.OutputBuffer.length - (pParserState.Pattern.PatternStart.length+pParserState.Pattern.PatternEnd.length)));\n\t\t\t// Flush the output buffer.\n\t\t\tthis.flushOutputBuffer(pParserState);\n\t\t\t// End pattern mode\n\t\t\tpParserState.Pattern = false;\n\t\t\tpParserState.PatternMatch = false;\n\t\t}\n\t}\n\t\n\t/**\n\t * Parse a character in the buffer.\n\t * @method parseCharacter\n\t * @param {string} pCharacter - The character to append\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tparseCharacter (pCharacter, pParserState)\n\t{\n\t\t// (1) If we aren't in a pattern match, and we aren't potentially matching, and this may be the start of a new pattern....\n\t\tif (!pParserState.PatternMatch && pParserState.ParseTree.hasOwnProperty(pCharacter))\n\t\t{\n\t\t\t// ... assign the node as the matched node.\n\t\t\tthis.assignNode(pParserState.ParseTree[pCharacter], pParserState);\n\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t}\n\t\t// (2) If we are in a pattern match (actively seeing if this is part of a new pattern token)\n\t\telse if (pParserState.PatternMatch)\n\t\t{\n\t\t\t// If the pattern has a subpattern with this key\n\t\t\tif (pParserState.PatternMatch.hasOwnProperty(pCharacter))\n\t\t\t{\n\t\t\t\t// Continue matching patterns.\n\t\t\t\tthis.assignNode(pParserState.PatternMatch[pCharacter], pParserState);\n\t\t\t}\n\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\tif (pParserState.Pattern)\n\t\t\t{\n\t\t\t\t// ... Check if this is the end of the pattern (if we are matching a valid pattern)...\n\t\t\t\tthis.checkPatternEnd(pParserState);\n\t\t\t}\n\t\t}\n\t\t// (3) If we aren't in a pattern match or pattern, and this isn't the start of a new pattern (RAW mode)....\n\t\telse\n\t\t{\n\t\t\tpParserState.Output += pCharacter;\n\t\t}\n\t}\n\t\n\t/**\n\t * Parse a string for matches, and process any template segments that occur.\n\t * @method parseString\n\t * @param {string} pString - The string to parse.\n\t * @param {Object} pParseTree - The parse tree to begin parsing from (usually root)\n\t */\n\tparseString (pString, pParseTree)\n\t{\n\t\tlet tmpParserState = this.newParserState(pParseTree);\n\n\t\tfor (var i = 0; i < pString.length; i++)\n\t\t{\n\t\t\t// TODO: This is not fast.\n\t\t\tthis.parseCharacter(pString[i], tmpParserState);\n\t\t}\n\t\t\n\t\tthis.flushOutputBuffer(tmpParserState);\n\t\t\n\t\treturn tmpParserState.Output;\n\t}\n}\n\nmodule.exports = StringParser;\n\n},{}],13:[function(require,module,exports){\n/**\n* Word Tree\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Create a tree (directed graph) of Javascript objects, one character per object.\n*/\n\nclass WordTree\n{\n\t/**\n\t * WordTree Constructor\n\t */\n\tconstructor()\n\t{\n\t\tthis.ParseTree = {};\n\t}\n\t\n\t/** \n\t * Add a child character to a Parse Tree node\n\t * @method addChild\n\t * @param {Object} pTree - A parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @param {number} pIndex - The index of the character in the pattern\n\t * @returns {Object} The resulting leaf node that was added (or found)\n\t * @private\n\t */\n\taddChild (pTree, pPattern, pIndex)\n\t{\n\t\tif (!pTree.hasOwnProperty(pPattern[pIndex]))\n\t\t\tpTree[pPattern[pIndex]] = {};\n\t\t\n\t\treturn pTree[pPattern[pIndex]];\n\t}\n\t\n\t/** Add a Pattern to the Parse Tree\n\t * @method addPattern\n\t * @param {Object} pPatternStart - The starting string for the pattern (e.g. \"${\")\n\t * @param {string} pPatternEnd - The ending string for the pattern (e.g. \"}\")\n\t * @param {number} pParser - The function to parse if this is the matched pattern, once the Pattern End is met.  If this is a string, a simple replacement occurs.\n\t * @return {bool} True if adding the pattern was successful\n\t */\n\taddPattern (pPatternStart, pPatternEnd, pParser)\n\t{\n\t\tif (pPatternStart.length < 1)\n\t\t\treturn false;\n\n\t\tif ((typeof(pPatternEnd) === 'string') && (pPatternEnd.length < 1))\n\t\t\treturn false;\n\n\t\tlet tmpLeaf = this.ParseTree;\n\n\t\t// Add the tree of leaves iteratively\n\t\tfor (var i = 0; i < pPatternStart.length; i++)\n\t\t\ttmpLeaf = this.addChild(tmpLeaf, pPatternStart, i);\n\n\t\ttmpLeaf.PatternStart = pPatternStart;\n\t\ttmpLeaf.PatternEnd = ((typeof(pPatternEnd) === 'string') && (pPatternEnd.length > 0)) ? pPatternEnd : pPatternStart;\n\t\ttmpLeaf.Parse = (typeof(pParser) === 'function') ? pParser : \n\t\t\t\t\t\t(typeof(pParser) === 'string') ? () => { return pParser; } :\n\t\t\t\t\t\t(pData) => { return pData; };\n\n\t\treturn true;\n\t}\n}\n\nmodule.exports = WordTree;\n\n},{}],14:[function(require,module,exports){\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],15:[function(require,module,exports){\nvar libNPMModuleWrapper = require('./Fable.js');\n\nif ((typeof(window) === 'object') && !window.hasOwnProperty('Fable'))\n{\n\twindow.Fable = libNPMModuleWrapper;\n}\n\nmodule.exports = libNPMModuleWrapper;\n},{\"./Fable.js\":18}],16:[function(require,module,exports){\nclass FableUtility\n{\n\tconstructor(pFable, pTemplateText)\n\t{\n\t\tthis.fable = pFable;\n\n\t\t// These are the exact regex's used in lodash/underscore\n\t\t// TODO: Switch this to precedent\n\t\tthis.Matchers = (\n\t\t\t{\n\t\t        Evaluate: /<%([\\s\\S]+?)%>/g,\n\t\t        Interpolate: /<%=([\\s\\S]+?)%>/g,\n\t    \t\tEscaper: /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g,\n\t    \t\tUnescaper: /\\\\(\\\\|'|r|n|t|u2028|u2029)/g,\n\t\t\t\t// This is how underscore does it, so we are keeping it for now.\n\t    \t\tGuaranteedNonMatch: /.^/\n\t\t    });\n\n\t    // This is a helper for the escaper and unescaper functions.\n\t    // Right now we are going to keep what underscore is doing, but, not forever.\n\t    this.templateEscapes = {\n\t        '\\\\': '\\\\',\n\t        \"'\": \"'\",\n\t        'r': '\\r',\n\t        '\\r': 'r',\n\t        'n': '\\n',\n\t        '\\n': 'n',\n\t        't': '\\t',\n\t        '\\t': 't',\n\t        'u2028': '\\u2028',\n\t        '\\u2028': 'u2028',\n\t        'u2029': '\\u2029',\n\t        '\\u2029': 'u2029'\n\t    };\n\n\t    // This is defined as such to underscore that it is a dynamic programming\n\t    // function on this class.\n\t    this.renderFunction = ()=>{return ``};\n\t}\n\n\t// Underscore and lodash have a behavior, _.extend, which merges objects.\n\t// Now that es6 gives us this, use the native thingy.\n\textend(pDestinationObject, ...pSourceObjects)\n\t{\n\t\treturn Object.assign(pDestinationObject, ...pSourceObjects);\n\t}\n\n\trenderTemplate(pData)\n\t{\n\t\treturn this.renderFunction(pData);\n\t}\n\n\ttemplateFunction(pData)\n\t{\n\t\tlet fRenderTemplateBound = this.renderTemplate.bind(this);\n\t\treturn fRenderTemplateBound;\n\t}\n\n\t// Underscore and lodash have a behavior, _.template, which compiles a\n\t// string-based template with code snippets into simple executable pieces,\n\t// with the added twist of returning a precompiled function ready to go.\n\t//\n\t// NOTE: This does not implement underscore escape expressions\n\t// NOTE: This does not implement underscore magic browser variable assignment\n\t//\n\t// This is an implementation of that.\n\t// TODO: Make this use precedent, add configuration, add debugging.\n\tbuildTemplateFunction(pTemplateText, pData)\n    {\n    \t// For now this is being kept in a weird form ... this is to mimic the old\n    \t// underscore code until this is rewritten using precedent.\n        this.TemplateSource = \"__p+='\" + pTemplateText\n            .replace(this.Matchers.Escaper,\n            \t(pMatch)=>\n\t            {\n\t                return `\\\\${this.templateEscapes[pMatch]}`;\n\t            })\n            .replace(this.Matchers.Interpolate || this.Matchers.GuaranteedNonMatch,\n            \t(pMatch, pCode) =>\n            \t{\n\t                return `'+\\n(${decodeURIComponent(pCode)})+\\n'`;\n\t            })\n\t        .replace(this.Matchers.Evaluate || this.Matchers.GuaranteedNonMatch,\n\t\t\t\t(pMatch, pCode) =>\n            \t{\n\t                return `';\\n${decodeURIComponent(pCode)}\\n;__p+='`;\n\t            }) + `';\\n`;\n\n\n        this.TemplateSource = `with(pTemplateDataObject||{}){\\n${this.TemplateSource}}\\n`;\n        this.TemplateSource = `var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};\\n${this.TemplateSource}return __p;\\n`;\n\n        this.renderFunction = new Function('pTemplateDataObject', this.TemplateSource);\n\n        if (typeof(pData) != 'undefined')\n        {\n            return this.renderFunction(pData);\n        }\n\n        // Provide the compiled function source as a convenience for build time\n        // precompilation.\n        this.TemplateSourceCompiled = 'function(obj){\\n' + this.TemplateSource + '}';\n\n        return this.templateFunction();\n\t}\n}\n\nmodule.exports = FableUtility;\n},{}],17:[function(require,module,exports){\nconst libFableUtilityTemplate = require('./Fable-Utility-Template.js');\n\nclass FableUtility\n{\n\tconstructor(pFable)\n\t{\n\t\tthis.fable = pFable;\n\t}\n\n\t// Underscore and lodash have a behavior, _.extend, which merges objects.\n\t// Now that es6 gives us this, use the native thingy.\n\textend(pDestinationObject, ...pSourceObjects)\n\t{\n\t\treturn Object.assign(pDestinationObject, ...pSourceObjects);\n\t}\n\n\t// Underscore and lodash have a behavior, _.template, which compiles a\n\t// string-based template with code snippets into simple executable pieces,\n\t// with the added twist of returning a precompiled function ready to go.\n\ttemplate(pTemplateText, pData)\n\t{\n\t\tlet tmpTemplate = new libFableUtilityTemplate(this.fable, pTemplateText);\n\n\t\treturn tmpTemplate.buildTemplateFunction(pTemplateText, pData);\n\t}\n\n\t// This is a safe, modern version of chunk from underscore\n\t// Algorithm pulled from a mix of these two polyfills:\n\t// https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_chunk\n\t// https://youmightnotneed.com/lodash\n\t// This implementation was most tolerant in browsers.  Uglify can fix the rest.\n\tchunk (pInput, pChunkSize, pChunkCache)\n\t{\n\t\tlet tmpInputArray = [...pInput];\n\t\t// Note lodash defaults to 1, underscore defaults to 0\n\t\tlet tmpChunkSize = (typeof(pChunkSize) == 'number') ? pChunkSize : 0;\n\t\tlet tmpChunkCache = (typeof(pChunkCache) != 'undefined') ? pChunkCache : [];\n\n\t\tif (tmpChunkSize <= 0)\n\t\t{\n\t\t\treturn tmpChunkCache;\n\t\t}\n\n\t\twhile (tmpInputArray.length)\n\t\t{\n\t\t\ttmpChunkCache.push(tmpInputArray.splice(0, tmpChunkSize));\n\t\t}\n\n\t\treturn tmpChunkCache;\n\t}\n}\n\nmodule.exports = FableUtility;\n},{\"./Fable-Utility-Template.js\":16}],18:[function(require,module,exports){\n/**\n* Fable Application Services Support Library\n* @license MIT\n* @author <steven@velozo.com>\n*/\nconst libFableSettings = require('fable-settings').FableSettings;\nconst libFableUUID = require('fable-uuid').FableUUID;\nconst libFableLog = require('fable-log').FableLog;\n\nconst libFableUtility = require('./Fable-Utility.js')\n\nclass Fable\n{\n\tconstructor(pSettings)\n\t{\n\t\tlet tmpSettings = new libFableSettings(pSettings);\n\n\t\tthis.settingsManager = tmpSettings;\n\n\t\t// Instantiate the UUID generator\n\t\tthis.libUUID = new libFableUUID(this.settingsManager.settings);\n\n\t\tthis.log = new libFableLog(this.settingsManager.settings);\n\t\tthis.log.initialize();\n\n\t\tthis.Utility = new libFableUtility(this);\n\t}\n\n\tget settings()\n\t{\n\t\treturn this.settingsManager.settings;\n\t}\n\n\tget fable()\n\t{\n\t\treturn this;\n\t}\n\n\tgetUUID()\n\t{\n\t\treturn this.libUUID.getUUID();\n\t}\n}\n\nmodule.exports = Fable;\n},{\"./Fable-Utility.js\":17,\"fable-log\":5,\"fable-settings\":8,\"fable-uuid\":10}]},{},[15])(15)\n});\n\n","/**\n* Default Logger Provider Function\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\n// Return the providers that are available without extensions loaded\ngetDefaultProviders = () =>\n{\n\tlet tmpDefaultProviders = {};\n\n\ttmpDefaultProviders.console = require('./Fable-Log-Logger-Console.js');\n\n\ttmpDefaultProviders.default = tmpDefaultProviders.console;\n\n\treturn tmpDefaultProviders;\n}\n\nmodule.exports = getDefaultProviders();","module.exports=[\n    {\n        \"loggertype\": \"console\",\n        \"streamtype\": \"console\",\n        \"level\": \"trace\"\n    }\n]","let libBaseLogger = require('./Fable-Log-BaseLogger.js');\n\nclass ConsoleLogger extends libBaseLogger\n{\n\tconstructor(pLogStreamSettings, pFableLog)\n\t{\n\t\tsuper(pLogStreamSettings);\n\n\t\tthis._ShowTimeStamps = pLogStreamSettings.hasOwnProperty('showtimestamps') ? (pLogStreamSettings.showtimestamps == true) : false;\n\t\tthis._FormattedTimeStamps = pLogStreamSettings.hasOwnProperty('formattedtimestamps') ? (pLogStreamSettings.formattedtimestamps == true) : false;\n\n\t\tthis._ContextMessage = pLogStreamSettings.hasOwnProperty('Context') ? `(${pLogStreamSettings.Context})` : \n\t\t\t\t\t\t\t\tpFableLog._Settings.hasOwnProperty('Product') ? `(${pFableLog._Settings.Product})` :\n\t\t\t\t\t\t\t\t'Unnamed_Log_Context';\n\n\t\t// Allow the user to decide what gets output to the console\n\t\tthis._OutputLogLinesToConsole = pLogStreamSettings.hasOwnProperty('outputloglinestoconsole') ? pLogStreamSettings.outputloglinestoconsole : true;\n\t\tthis._OutputObjectsToConsole = pLogStreamSettings.hasOwnProperty('outputobjectstoconsole') ? pLogStreamSettings.outputobjectstoconsole : true;\n\n\t\t// Precompute the prefix for each level\n\t\tthis.prefixCache = {};\n\t\tfor (let i = 0; i <= this.levels.length; i++)\n\t\t{\n\t\t\tthis.prefixCache[this.levels[i]] = `[${this.levels[i]}] ${this._ContextMessage}: `;\n\n\t\t\tif (this._ShowTimeStamps)\n\t\t\t{\n\t\t\t\t// If there is a timestamp we need a to prepend space before the prefixcache string, since the timestamp comes first\n\t\t\t\tthis.prefixCache[this.levels[i]] = ' '+this.prefixCache[this.levels[i]];\n\t\t\t}\n\t\t}\n\t}\n\n\twrite(pLevel, pLogText, pObject)\n\t{\n\t\tlet tmpTimeStamp = '';\n\t\tif (this._ShowTimeStamps && this._FormattedTimeStamps)\n\t\t{\n\t\t\ttmpTimeStamp = (new Date()).toISOString();\n\t\t}\n\t\telse if (this._ShowTimeStamps)\n\t\t{\n\t\t\ttmpTimeStamp = +new Date();\n\t\t}\n\n\t\tlet tmpLogLine = `${tmpTimeStamp}${this.prefixCache[pLevel]}${pLogText}`;\n\n\t\tif (this._OutputLogLinesToConsole)\n\t\t{\n\t\t\tconsole.log(tmpLogLine);\n\t\t}\n\n\t\t// Write out the object on a separate line if it is passed in\n\t\tif (this._OutputObjectsToConsole && (typeof(pObject) !== 'undefined'))\n\t\t{\n\t\t\tconsole.log(JSON.stringify(pObject, null, 2));\n\t\t}\n\n\t\t// Provide an easy way to be overridden and be consistent\n\t\treturn tmpLogLine;\n\t}\n}\n\nmodule.exports = ConsoleLogger;","/**\n* Fable Logging Add-on\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable Logger\n*/\n\n/**\n* Fable Solution Log Wrapper Main Class\n*\n* @class FableLog\n* @constructor\n*/\nclass FableLog\n{\n\tconstructor(pFableSettings, pFable)\n\t{\n\t\tlet tmpSettings = (typeof(pFableSettings) === 'object') ? pFableSettings : {}\n\t\tthis._Settings = tmpSettings;\n\n\t\tthis._Providers = require('./Fable-Log-DefaultProviders-Node.js');\n\n\t\tthis._StreamDefinitions = (tmpSettings.hasOwnProperty('LogStreams')) ? tmpSettings.LogStreams : require('./Fable-Log-DefaultStreams.json');\n\n\t\tthis.logStreams = [];\n\n\t\t// This object gets decorated for one-time instantiated providers that\n\t\t//  have multiple outputs, such as bunyan.\n\t\tthis.logProviders = {};\n\n\t\t// A hash list of the GUIDs for each log stream, so they can't be added to the set more than one time\n\t\tthis.activeLogStreams = {};\n\n\t\tthis.logStreamsTrace = [];\n\t\tthis.logStreamsDebug = [];\n\t\tthis.logStreamsInfo = [];\n\t\tthis.logStreamsWarn = [];\n\t\tthis.logStreamsError = [];\n\t\tthis.logStreamsFatal = [];\n\n\t\tthis.datumDecorator = (pDatum) => pDatum;\n\n\t\tthis.uuid = (typeof(tmpSettings.Product) === 'string') ? tmpSettings.Product : 'Default';\n\t}\n\n\taddLogger(pLogger, pLevel)\n\t{\n\t\t// Bail out if we've already created one.\n\t\tif (this.activeLogStreams.hasOwnProperty(pLogger.loggerUUID))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// Add it to the streams and to the mutex\n\t\tthis.logStreams.push(pLogger);\n\t\tthis.activeLogStreams[pLogger.loggerUUID] = true;\n\n\t\t// Make sure a kosher level was passed in\n\t\tswitch (pLevel)\n\t\t{\n\t\t\tcase 'trace':\n\t\t\t\tthis.logStreamsTrace.push(pLogger);\n\t\t\tcase 'debug':\n\t\t\t\tthis.logStreamsDebug.push(pLogger);\n\t\t\tcase 'info':\n\t\t\t\tthis.logStreamsInfo.push(pLogger);\n\t\t\tcase 'warn':\n\t\t\t\tthis.logStreamsWarn.push(pLogger);\n\t\t\tcase 'error':\n\t\t\t\tthis.logStreamsError.push(pLogger);\n\t\t\tcase 'fatal':\n\t\t\t\tthis.logStreamsFatal.push(pLogger);\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tsetDatumDecorator(fDatumDecorator)\n\t{\n\t\tif (typeof(fDatumDecorator) === 'function')\n\t\t{\n\t\t\tthis.datumDecorator = fDatumDecorator;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.datumDecorator = (pDatum) => pDatum;\n\t\t}\n\t}\n\n\ttrace(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsTrace.length; i++)\n\t\t{\n\t\t\tthis.logStreamsTrace[i].trace(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tdebug(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsDebug.length; i++)\n\t\t{\n\t\t\tthis.logStreamsDebug[i].debug(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tinfo(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsInfo.length; i++)\n\t\t{\n\t\t\tthis.logStreamsInfo[i].info(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\twarn(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsWarn.length; i++)\n\t\t{\n\t\t\tthis.logStreamsWarn[i].warn(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\terror(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsError.length; i++)\n\t\t{\n\t\t\tthis.logStreamsError[i].error(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tfatal(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsFatal.length; i++)\n\t\t{\n\t\t\tthis.logStreamsFatal[i].fatal(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tinitialize()\n\t{\n\t\t// \"initialize\" each logger as defined in the logging parameters\n\t\tfor (let i = 0; i < this._StreamDefinitions.length; i++)\n\t\t{\n\t\t\tlet tmpStreamDefinition = Object.assign({loggertype:'default',streamtype:'console',level:'info'},this._StreamDefinitions[i]);\n\n\t\t\tif (!this._Providers.hasOwnProperty(tmpStreamDefinition.loggertype))\n\t\t\t{\n\t\t\t\tconsole.log(`Error initializing log stream: bad loggertype in stream definition ${JSON.stringify(tmpStreamDefinition)}`);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.addLogger(new this._Providers[tmpStreamDefinition.loggertype](tmpStreamDefinition, this), tmpStreamDefinition.level);\n\t\t\t}\n\t\t}\n\n\t\t// Now initialize each one.\n\t\tfor (let i = 0; i < this.logStreams.length; i++)\n\t\t{\n\t\t\tthis.logStreams[i].initialize();\n\t\t}\n\t}\n\n\tlogTime(pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time';\n\t\tlet tmpTime = new Date();\n\t\tthis.info(`${tmpMessage} ${tmpTime} (epoch ${+tmpTime})`, pDatum);\n\t}\n\n\t// Get a timestamp\n\tgetTimeStamp()\n\t{\n\t\treturn +new Date();\n\t}\n\n\tgetTimeDelta(pTimeStamp)\n\t{\n\t\tlet tmpEndTime = +new Date();\n\t\treturn tmpEndTime-pTimeStamp;\n\t}\n\n\t// Log the delta between a timestamp, and now with a message\n\tlogTimeDelta(pTimeDelta, pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time Measurement';\n\t\tlet tmpDatum = (typeof(pDatum) === 'object') ? pDatum : {};\n\n\t\tlet tmpEndTime = +new Date();\n\n\t\tthis.info(`${tmpMessage} logged at (epoch ${+tmpEndTime}) took (${pTimeDelta}ms)`, pDatum);\n\t}\n\n\tlogTimeDeltaHuman(pTimeDelta, pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time Measurement';\n\n\t\tlet tmpEndTime = +new Date();\n\n\t\tlet tmpMs = parseInt(pTimeDelta%1000);\n\t\tlet tmpSeconds = parseInt((pTimeDelta/1000)%60);\n\t\tlet tmpMinutes = parseInt((pTimeDelta/(1000*60))%60);\n\t\tlet tmpHours = parseInt(pTimeDelta/(1000*60*60));\n\n\t\ttmpMs = (tmpMs < 10) ? \"00\"+tmpMs : (tmpMs < 100) ? \"0\"+tmpMs : tmpMs;\n\t\ttmpSeconds = (tmpSeconds < 10) ? \"0\"+tmpSeconds : tmpSeconds;\n\t\ttmpMinutes = (tmpMinutes < 10) ? \"0\"+tmpMinutes : tmpMinutes;\n\t\ttmpHours = (tmpHours < 10) ? \"0\"+tmpHours : tmpHours;\n\n\t\tthis.info(`${tmpMessage} logged at (epoch ${+tmpEndTime}) took (${pTimeDelta}ms) or (${tmpHours}:${tmpMinutes}:${tmpSeconds}.${tmpMs})`, pDatum);\n\t}\n\n\tlogTimeDeltaRelative(pStartTime, pMessage, pDatum)\n\t{\n\t\tthis.logTimeDelta(this.getTimeDelta(pStartTime), pMessage, pDatum);\n\t}\n\n\tlogTimeDeltaRelativeHuman(pStartTime, pMessage, pDatum)\n\t{\n\t\tthis.logTimeDeltaHuman(this.getTimeDelta(pStartTime), pMessage, pDatum);\n\t}\n}\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new FableLog(pSettings);\n}\n\n\nmodule.exports = {new:autoConstruct, FableLog:FableLog};\n","module.exports={\n\t\"Product\": \"ApplicationNameHere\",\n\t\"ProductVersion\": \"0.0.0\",\n\n\t\"ConfigFile\": false,\n\n\t\"LogStreams\":\n\t[\n\t\t{\n\t\t\t\"level\": \"trace\"\n\t\t}\n\t]\n}\n","/**\n* Fable Settings Template Processor\n*\n* This class allows environment variables to come in via templated expressions, and defaults to be set.\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable Settings\n*/\n\nclass FableSettingsTemplateProcessor\n{\n\tconstructor(pDependencies)\n\t{\n        // Use a no-dependencies templating engine to parse out environment variables\n\t\tthis.templateProcessor = new pDependencies.precedent();\n\n        // TODO: Make the environment variable wrap expression demarcation characters configurable?\n\t\tthis.templateProcessor.addPattern('${', '}',\n\t\t\t(pTemplateValue)=>\n\t\t\t{\n\t\t\t\tlet tmpTemplateValue = pTemplateValue.trim();\n\n\t\t\t\tlet tmpSeparatorIndex = tmpTemplateValue.indexOf('|');\n\n\t\t\t\t// If there is no pipe, the default value will end up being whatever the variable name is.\n\t\t\t\tlet tmpDefaultValue = tmpTemplateValue.substring(tmpSeparatorIndex+1);\n\n\t\t\t\tlet tmpEnvironmentVariableName = (tmpSeparatorIndex > -1) ? tmpTemplateValue.substring(0, tmpSeparatorIndex) : tmpTemplateValue;\n\n\t\t\t\tif (process.env.hasOwnProperty(tmpEnvironmentVariableName))\n\t\t\t\t{\n\t\t\t\t\treturn process.env[tmpEnvironmentVariableName];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn tmpDefaultValue;\n\t\t\t\t}\n\t\t\t});\n    }\n\n    parseSetting(pString)\n    {\n        return this.templateProcessor.parseString(pString);\n    }\n}\n\nmodule.exports = FableSettingsTemplateProcessor;","/**\n* Fable Settings Add-on\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable Settings\n*/\n\nconst libPrecedent = require('precedent');\nconst libFableSettingsTemplateProcessor = require('./Fable-Settings-TemplateProcessor.js');\n\nclass FableSettings\n{\n\tconstructor(pFableSettings)\n\t{\n\t\t// Expose the dependencies for downstream re-use\n\t\tthis.dependencies = (\n\t\t\t{\n\t\t\t\tprecedent: libPrecedent\n\t\t\t});\n\n\t\t// Initialize the settings value template processor\n\t\tthis.settingsTemplateProcessor = new libFableSettingsTemplateProcessor(this.dependencies);\n\n\t\t// set straight away so anything that uses it respects the initial setting\n\t\tthis._configureEnvTemplating(pFableSettings);\n\n\t\tthis.default = this.buildDefaultSettings();\n\n\t\t// Construct a new settings object\n\t\tlet tmpSettings = this.merge(pFableSettings, this.buildDefaultSettings());\n\n\t\t// The base settings object (what they were on initialization, before other actors have altered them)\n\t\tthis.base = JSON.parse(JSON.stringify(tmpSettings));\n\n\t\tif (tmpSettings.DefaultConfigFile)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// If there is a DEFAULT configuration file, try to load and merge it.\n\t\t\t\ttmpSettings = this.merge(require(tmpSettings.DefaultConfigFile), tmpSettings);\n\t\t\t}\n\t\t\tcatch (pException)\n\t\t\t{\n\t\t\t\t// Why this?  Often for an app we want settings to work out of the box, but\n\t\t\t\t// would potentially want to have a config file for complex settings.\n\t\t\t\tconsole.log('Fable-Settings Warning: Default configuration file specified but there was a problem loading it.  Falling back to base.');\n\t\t\t\tconsole.log('     Loading Exception: '+pException);\n\t\t\t}\n\t\t}\n\n\t\tif (tmpSettings.ConfigFile)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// If there is a configuration file, try to load and merge it.\n\t\t\t\ttmpSettings = this.merge(require(tmpSettings.ConfigFile), tmpSettings);\n\t\t\t}\n\t\t\tcatch (pException)\n\t\t\t{\n\t\t\t\t// Why this?  Often for an app we want settings to work out of the box, but\n\t\t\t\t// would potentially want to have a config file for complex settings.\n\t\t\t\tconsole.log('Fable-Settings Warning: Configuration file specified but there was a problem loading it.  Falling back to base.');\n\t\t\t\tconsole.log('     Loading Exception: '+pException);\n\t\t\t}\n\t\t}\n\n\t\tthis.settings = tmpSettings;\n\t}\n\n\t// Build a default settings object.  Use the JSON jimmy to ensure it is always a new object.\n\tbuildDefaultSettings()\n\t{\n\t\treturn JSON.parse(JSON.stringify(require('./Fable-Settings-Default')));\n\t}\n\n\t// Update the configuration for environment variable templating based on the current settings object\n\t_configureEnvTemplating(pSettings)\n\t{\n\t\t// default environment variable templating to on\n\t\tthis._PerformEnvTemplating = !pSettings || pSettings.NoEnvReplacement !== true;\n\t}\n\n\t// Resolve (recursive) any environment variables found in settings object.\n\t_resolveEnv(pSettings)\n\t{\n\t\tfor (const tmpKey in pSettings)\n\t\t{\n\t\t\tif (typeof(pSettings[tmpKey]) === 'object')\n\t\t\t{\n\t\t\t\tthis._resolveEnv(pSettings[tmpKey]);\n\t\t\t}\n\t\t\telse if (typeof(pSettings[tmpKey]) === 'string')\n\t\t\t{\n\t\t\t\tpSettings[tmpKey] = this.settingsTemplateProcessor.parseSetting(pSettings[tmpKey]);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Check to see if a value is an object (but not an array).\n\t */\n\t_isObject(value)\n\t{\n\t\treturn typeof(value) === 'object' && !Array.isArray(value);\n\t}\n\n\t/**\n\t * Merge two plain objects. Keys that are objects in both will be merged property-wise.\n\t */\n\t_deepMergeObjects(toObject, fromObject)\n\t{\n\t\tif (!fromObject || !this._isObject(fromObject))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tObject.keys(fromObject).forEach((key) =>\n\t\t{\n\t\t\tconst fromValue = fromObject[key];\n\t\t\tif (this._isObject(fromValue))\n\t\t\t{\n\t\t\t\tconst toValue = toObject[key];\n\t\t\t\tif (toValue && this._isObject(toValue))\n\t\t\t\t{\n\t\t\t\t\t// both are objects, so do a recursive merge\n\t\t\t\t\tthis._deepMergeObjects(toValue, fromValue);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttoObject[key] = fromValue;\n\t\t});\n\t\treturn toObject;\n\t}\n\n\t// Merge some new object into the existing settings.\n\tmerge(pSettingsFrom, pSettingsTo)\n\t{\n\t\t// If an invalid settings from object is passed in (e.g. object constructor without passing in anything) this should still work\n\t\tlet tmpSettingsFrom = (typeof(pSettingsFrom) === 'object') ? pSettingsFrom : {};\n\t\t// Default to the settings object if none is passed in for the merge.\n\t\tlet tmpSettingsTo = (typeof(pSettingsTo) === 'object') ? pSettingsTo : this.settings;\n\n\t\t// do not mutate the From object property values\n\t\tlet tmpSettingsFromCopy = JSON.parse(JSON.stringify(tmpSettingsFrom));\n\t\ttmpSettingsTo = this._deepMergeObjects(tmpSettingsTo, tmpSettingsFromCopy);\n\n\t\tif (this._PerformEnvTemplating)\n\t\t{\n\t\t\tthis._resolveEnv(tmpSettingsTo);\n\t\t}\n\t\t// Update env tempating config, since we just updated the config object, and it may have changed\n\t\tthis._configureEnvTemplating(tmpSettingsTo);\n\n\t\treturn tmpSettingsTo;\n\t}\n\n\t// Fill in settings gaps without overwriting settings that are already there\n\tfill(pSettingsFrom)\n\t{\n\t\t// If an invalid settings from object is passed in (e.g. object constructor without passing in anything) this should still work\n\t\tlet tmpSettingsFrom = (typeof(pSettingsFrom) === 'object') ? pSettingsFrom : {};\n\n\t\t// do not mutate the From object property values\n\t\tlet tmpSettingsFromCopy = JSON.parse(JSON.stringify(tmpSettingsFrom));\n\n\t\tthis.settings = this._deepMergeObjects(tmpSettingsFromCopy, this.settings);\n\n\t\treturn this.settings;\n\t}\n};\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new FableSettings(pSettings);\n}\n\nmodule.exports = {new:autoConstruct, FableSettings:FableSettings};","/**\n* Random Byte Generator - Browser version\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\n// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\nclass RandomBytes\n{\n\tconstructor()\n\t{\n\n\t\t// getRandomValues needs to be invoked in a context where \"this\" is a Crypto\n\t\t// implementation. Also, find the complete implementation of crypto on IE11.\n\t\tthis.getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||\n                      \t\t(typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));\n\t}\n\n\t// WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n\tgenerateWhatWGBytes()\n\t{\n\t\tlet tmpBuffer = new Uint8Array(16); // eslint-disable-line no-undef\n\n\t\tthis.getRandomValues(tmpBuffer);\n\t\treturn tmpBuffer;\n\t}\n\n\t// Math.random()-based (RNG)\n\tgenerateRandomBytes()\n\t{\n\t\t// If all else fails, use Math.random().  It's fast, but is of unspecified\n\t\t// quality.\n\t\tlet tmpBuffer = new Uint8Array(16); // eslint-disable-line no-undef\n\n\t\tfor (let i = 0, tmpValue; i < 16; i++)\n\t\t{\n\t\t\tif ((i & 0x03) === 0)\n\t\t\t{\n\t\t\t\ttmpValue = Math.random() * 0x100000000;\n\t\t\t}\n\n\t\t\ttmpBuffer[i] = tmpValue >>> ((i & 0x03) << 3) & 0xff;\n\t\t}\n\n\t\treturn tmpBuffer;\n\t}\n\n\tgenerate()\n\t{\n\t\tif (this.getRandomValues)\n\t\t{\n\t\t\treturn this.generateWhatWGBytes();\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.generateRandomBytes();\n\t\t}\n\t}\n}\n\nmodule.exports = RandomBytes;\n","/**\n* Fable UUID Generator\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable UUID\n*/\n\n/**\n* Fable Solution UUID Generation Main Class\n*\n* @class FableUUID\n* @constructor\n*/\n\nvar libRandomByteGenerator = require('./Fable-UUID-Random.js')\n\nclass FableUUID\n{\n\tconstructor(pSettings)\n\t{\n\t\t// Determine if the module is in \"Random UUID Mode\" which means just use the random character function rather than the v4 random UUID spec.\n\t\t// Note this allows UUIDs of various lengths (including very short ones) although guaranteed uniqueness goes downhill fast.\n\t\tthis._UUIDModeRandom = (typeof(pSettings) === 'object') && (pSettings.hasOwnProperty('UUIDModeRandom')) ? (pSettings.UUIDModeRandom == true) : false;\n\t\t// These two properties are only useful if we are in Random mode.  Otherwise it generates a v4 spec\n\t\t// Length for \"Random UUID Mode\" is set -- if not set it to 8\n\t\tthis._UUIDLength = (typeof(pSettings) === 'object') && (pSettings.hasOwnProperty('UUIDLength')) ? (pSettings.UUIDLength + 0) : 8;\n\t\t// Dictionary for \"Random UUID Mode\"\n\t\tthis._UUIDRandomDictionary = (typeof(pSettings) === 'object') && (pSettings.hasOwnProperty('UUIDDictionary')) ? (pSettings.UUIDDictionary + 0) : '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n\n\t\tthis.randomByteGenerator = new libRandomByteGenerator();\n\n\t\t// Lookup table for hex codes\n\t\tthis._HexLookup = [];\n\t\tfor (let i = 0; i < 256; ++i)\n\t\t{\n\t\t\tthis._HexLookup[i] = (i + 0x100).toString(16).substr(1);\n\t\t}\n\t}\n\n\t// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n\tbytesToUUID(pBuffer)\n\t{\n\t\tlet i = 0;\n\t\t// join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n\t\treturn ([\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], \n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]]\n\t\t\t\t]).join('');\n\t}\n\n\t// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n\tgenerateUUIDv4()\n\t{\n\t\tlet tmpBuffer = new Array(16);\n\t\tvar tmpRandomBytes = this.randomByteGenerator.generate();\n\n\t\t// Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\t\ttmpRandomBytes[6] = (tmpRandomBytes[6] & 0x0f) | 0x40;\n\t\ttmpRandomBytes[8] = (tmpRandomBytes[8] & 0x3f) | 0x80;\n\n\t\treturn this.bytesToUUID(tmpRandomBytes);\n\t}\n\n\t// Simple random UUID generation\n\tgenerateRandom()\n\t{\n\t\tlet tmpUUID = '';\n\n\t\tfor (let i = 0; i < this._UUIDLength; i++)\n\t\t{\n\t\t\ttmpUUID += this._UUIDRandomDictionary.charAt(Math.floor(Math.random() * (this._UUIDRandomDictionary.length-1)));\n\t\t}\n\n\t\treturn tmpUUID;\n\t}\n\n\t// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n\tgetUUID()\n\t{\n\t\tif (this._UUIDModeRandom)\n\t\t{\n\t\t\treturn this.generateRandom();\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.generateUUIDv4();\n\t\t}\n\t}\n}\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new FableUUID(pSettings);\n}\n\n\nmodule.exports = {new:autoConstruct, FableUUID:FableUUID};\n","/**\n* Precedent Meta-Templating\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Process text streams, parsing out meta-template expressions.\n*/\nvar libWordTree = require(`./WordTree.js`);\nvar libStringParser = require(`./StringParser.js`);\n\nclass Precedent\n{\n\t/**\n\t * Precedent Constructor\n\t */\n\tconstructor()\n\t{\n\t\tthis.WordTree = new libWordTree();\n\t\t\n\t\tthis.StringParser = new libStringParser();\n\n\t\tthis.ParseTree = this.WordTree.ParseTree;\n\t}\n\t\n\t/**\n\t * Add a Pattern to the Parse Tree\n\t * @method addPattern\n\t * @param {Object} pTree - A node on the parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @param {number} pIndex - callback function\n\t * @return {bool} True if adding the pattern was successful\n\t */\n\taddPattern(pPatternStart, pPatternEnd, pParser)\n\t{\n\t\treturn this.WordTree.addPattern(pPatternStart, pPatternEnd, pParser);\n\t}\n\t\n\t/**\n\t * Parse a string with the existing parse tree\n\t * @method parseString\n\t * @param {string} pString - The string to parse\n\t * @return {string} The result from the parser\n\t */\n\tparseString(pString)\n\t{\n\t\treturn this.StringParser.parseString(pString, this.ParseTree);\n\t}\n}\n\nmodule.exports = Precedent;\n","/**\n* String Parser\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Parse a string, properly processing each matched token in the word tree.\n*/\n\nclass StringParser\n{\n\t/**\n\t * StringParser Constructor\n\t */\n\tconstructor()\n\t{\n\t}\n\t\n\t/**\n\t * Create a fresh parsing state object to work with.\n\t * @method newParserState\n\t * @param {Object} pParseTree - A node on the parse tree to begin parsing from (usually root)\n\t * @return {Object} A new parser state object for running a character parser on\n\t * @private\n\t */\n\tnewParserState (pParseTree)\n\t{\n\t\treturn (\n\t\t{\n\t\t\tParseTree: pParseTree,\n\n\t\t\tOutput: '',\n\t\t\tOutputBuffer: '',\n\n\t\t\tPattern: false,\n\n\t\t\tPatternMatch: false,\n\t\t\tPatternMatchOutputBuffer: ''\n\t\t});\n\t}\n\t\t\n\t/**\n\t * Assign a node of the parser tree to be the next potential match.\n\t * If the node has a PatternEnd property, it is a valid match and supercedes the last valid match (or becomes the initial match).\n\t * @method assignNode\n\t * @param {Object} pNode - A node on the parse tree to assign\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tassignNode (pNode, pParserState)\n\t{\n\t\tpParserState.PatternMatch = pNode;\n\n\t\t// If the pattern has a END we can assume it has a parse function...\n\t\tif (pParserState.PatternMatch.hasOwnProperty('PatternEnd'))\n\t\t{\n\t\t\t// ... this is the legitimate start of a pattern.\n\t\t\tpParserState.Pattern = pParserState.PatternMatch;\n\t\t}\n\t}\n\t\n\t/**\n\t * Append a character to the output buffer in the parser state.\n\t * This output buffer is used when a potential match is being explored, or a match is being explored.\n\t * @method appendOutputBuffer\n\t * @param {string} pCharacter - The character to append\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tappendOutputBuffer (pCharacter, pParserState)\n\t{\n\t\tpParserState.OutputBuffer += pCharacter;\n\t}\n\t\n\t/**\n\t * Flush the output buffer to the output and clear it.\n\t * @method flushOutputBuffer\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tflushOutputBuffer (pParserState)\n\t{\n\t\tpParserState.Output += pParserState.OutputBuffer;\n\t\tpParserState.OutputBuffer = '';\n\t}\n\n\t\n\t/**\n\t * Check if the pattern has ended.  If it has, properly flush the buffer and start looking for new patterns.\n\t * @method checkPatternEnd\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tcheckPatternEnd (pParserState)\n\t{\n\t\tif ((pParserState.OutputBuffer.length >= pParserState.Pattern.PatternEnd.length+pParserState.Pattern.PatternStart.length) && \n\t\t\t(pParserState.OutputBuffer.substr(-pParserState.Pattern.PatternEnd.length) === pParserState.Pattern.PatternEnd))\n\t\t{\n\t\t\t// ... this is the end of a pattern, cut off the end tag and parse it.\n\t\t\t// Trim the start and end tags off the output buffer now\n\t\t\tpParserState.OutputBuffer = pParserState.Pattern.Parse(pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStart.length, pParserState.OutputBuffer.length - (pParserState.Pattern.PatternStart.length+pParserState.Pattern.PatternEnd.length)));\n\t\t\t// Flush the output buffer.\n\t\t\tthis.flushOutputBuffer(pParserState);\n\t\t\t// End pattern mode\n\t\t\tpParserState.Pattern = false;\n\t\t\tpParserState.PatternMatch = false;\n\t\t}\n\t}\n\t\n\t/**\n\t * Parse a character in the buffer.\n\t * @method parseCharacter\n\t * @param {string} pCharacter - The character to append\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tparseCharacter (pCharacter, pParserState)\n\t{\n\t\t// (1) If we aren't in a pattern match, and we aren't potentially matching, and this may be the start of a new pattern....\n\t\tif (!pParserState.PatternMatch && pParserState.ParseTree.hasOwnProperty(pCharacter))\n\t\t{\n\t\t\t// ... assign the node as the matched node.\n\t\t\tthis.assignNode(pParserState.ParseTree[pCharacter], pParserState);\n\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t}\n\t\t// (2) If we are in a pattern match (actively seeing if this is part of a new pattern token)\n\t\telse if (pParserState.PatternMatch)\n\t\t{\n\t\t\t// If the pattern has a subpattern with this key\n\t\t\tif (pParserState.PatternMatch.hasOwnProperty(pCharacter))\n\t\t\t{\n\t\t\t\t// Continue matching patterns.\n\t\t\t\tthis.assignNode(pParserState.PatternMatch[pCharacter], pParserState);\n\t\t\t}\n\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\tif (pParserState.Pattern)\n\t\t\t{\n\t\t\t\t// ... Check if this is the end of the pattern (if we are matching a valid pattern)...\n\t\t\t\tthis.checkPatternEnd(pParserState);\n\t\t\t}\n\t\t}\n\t\t// (3) If we aren't in a pattern match or pattern, and this isn't the start of a new pattern (RAW mode)....\n\t\telse\n\t\t{\n\t\t\tpParserState.Output += pCharacter;\n\t\t}\n\t}\n\t\n\t/**\n\t * Parse a string for matches, and process any template segments that occur.\n\t * @method parseString\n\t * @param {string} pString - The string to parse.\n\t * @param {Object} pParseTree - The parse tree to begin parsing from (usually root)\n\t */\n\tparseString (pString, pParseTree)\n\t{\n\t\tlet tmpParserState = this.newParserState(pParseTree);\n\n\t\tfor (var i = 0; i < pString.length; i++)\n\t\t{\n\t\t\t// TODO: This is not fast.\n\t\t\tthis.parseCharacter(pString[i], tmpParserState);\n\t\t}\n\t\t\n\t\tthis.flushOutputBuffer(tmpParserState);\n\t\t\n\t\treturn tmpParserState.Output;\n\t}\n}\n\nmodule.exports = StringParser;\n","/**\n* Word Tree\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Create a tree (directed graph) of Javascript objects, one character per object.\n*/\n\nclass WordTree\n{\n\t/**\n\t * WordTree Constructor\n\t */\n\tconstructor()\n\t{\n\t\tthis.ParseTree = {};\n\t}\n\t\n\t/** \n\t * Add a child character to a Parse Tree node\n\t * @method addChild\n\t * @param {Object} pTree - A parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @param {number} pIndex - The index of the character in the pattern\n\t * @returns {Object} The resulting leaf node that was added (or found)\n\t * @private\n\t */\n\taddChild (pTree, pPattern, pIndex)\n\t{\n\t\tif (!pTree.hasOwnProperty(pPattern[pIndex]))\n\t\t\tpTree[pPattern[pIndex]] = {};\n\t\t\n\t\treturn pTree[pPattern[pIndex]];\n\t}\n\t\n\t/** Add a Pattern to the Parse Tree\n\t * @method addPattern\n\t * @param {Object} pPatternStart - The starting string for the pattern (e.g. \"${\")\n\t * @param {string} pPatternEnd - The ending string for the pattern (e.g. \"}\")\n\t * @param {number} pParser - The function to parse if this is the matched pattern, once the Pattern End is met.  If this is a string, a simple replacement occurs.\n\t * @return {bool} True if adding the pattern was successful\n\t */\n\taddPattern (pPatternStart, pPatternEnd, pParser)\n\t{\n\t\tif (pPatternStart.length < 1)\n\t\t\treturn false;\n\n\t\tif ((typeof(pPatternEnd) === 'string') && (pPatternEnd.length < 1))\n\t\t\treturn false;\n\n\t\tlet tmpLeaf = this.ParseTree;\n\n\t\t// Add the tree of leaves iteratively\n\t\tfor (var i = 0; i < pPatternStart.length; i++)\n\t\t\ttmpLeaf = this.addChild(tmpLeaf, pPatternStart, i);\n\n\t\ttmpLeaf.PatternStart = pPatternStart;\n\t\ttmpLeaf.PatternEnd = ((typeof(pPatternEnd) === 'string') && (pPatternEnd.length > 0)) ? pPatternEnd : pPatternStart;\n\t\ttmpLeaf.Parse = (typeof(pParser) === 'function') ? pParser : \n\t\t\t\t\t\t(typeof(pParser) === 'string') ? () => { return pParser; } :\n\t\t\t\t\t\t(pData) => { return pData; };\n\n\t\treturn true;\n\t}\n}\n\nmodule.exports = WordTree;\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","var libNPMModuleWrapper = require('./Fable.js');\n\nif ((typeof(window) === 'object') && !window.hasOwnProperty('Fable'))\n{\n\twindow.Fable = libNPMModuleWrapper;\n}\n\nmodule.exports = libNPMModuleWrapper;","class FableUtility\n{\n\tconstructor(pFable, pTemplateText)\n\t{\n\t\tthis.fable = pFable;\n\n\t\t// These are the exact regex's used in lodash/underscore\n\t\t// TODO: Switch this to precedent\n\t\tthis.Matchers = (\n\t\t\t{\n\t\t        Evaluate: /<%([\\s\\S]+?)%>/g,\n\t\t        Interpolate: /<%=([\\s\\S]+?)%>/g,\n\t    \t\tEscaper: /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g,\n\t    \t\tUnescaper: /\\\\(\\\\|'|r|n|t|u2028|u2029)/g,\n\t\t\t\t// This is how underscore does it, so we are keeping it for now.\n\t    \t\tGuaranteedNonMatch: /.^/\n\t\t    });\n\n\t    // This is a helper for the escaper and unescaper functions.\n\t    // Right now we are going to keep what underscore is doing, but, not forever.\n\t    this.templateEscapes = {\n\t        '\\\\': '\\\\',\n\t        \"'\": \"'\",\n\t        'r': '\\r',\n\t        '\\r': 'r',\n\t        'n': '\\n',\n\t        '\\n': 'n',\n\t        't': '\\t',\n\t        '\\t': 't',\n\t        'u2028': '\\u2028',\n\t        '\\u2028': 'u2028',\n\t        'u2029': '\\u2029',\n\t        '\\u2029': 'u2029'\n\t    };\n\n\t    // This is defined as such to underscore that it is a dynamic programming\n\t    // function on this class.\n\t    this.renderFunction = ()=>{return ``};\n\t}\n\n\t// Underscore and lodash have a behavior, _.extend, which merges objects.\n\t// Now that es6 gives us this, use the native thingy.\n\textend(pDestinationObject, ...pSourceObjects)\n\t{\n\t\treturn Object.assign(pDestinationObject, ...pSourceObjects);\n\t}\n\n\trenderTemplate(pData)\n\t{\n\t\treturn this.renderFunction(pData);\n\t}\n\n\ttemplateFunction(pData)\n\t{\n\t\tlet fRenderTemplateBound = this.renderTemplate.bind(this);\n\t\treturn fRenderTemplateBound;\n\t}\n\n\t// Underscore and lodash have a behavior, _.template, which compiles a\n\t// string-based template with code snippets into simple executable pieces,\n\t// with the added twist of returning a precompiled function ready to go.\n\t//\n\t// NOTE: This does not implement underscore escape expressions\n\t// NOTE: This does not implement underscore magic browser variable assignment\n\t//\n\t// This is an implementation of that.\n\t// TODO: Make this use precedent, add configuration, add debugging.\n\tbuildTemplateFunction(pTemplateText, pData)\n    {\n    \t// For now this is being kept in a weird form ... this is to mimic the old\n    \t// underscore code until this is rewritten using precedent.\n        this.TemplateSource = \"__p+='\" + pTemplateText\n            .replace(this.Matchers.Escaper,\n            \t(pMatch)=>\n\t            {\n\t                return `\\\\${this.templateEscapes[pMatch]}`;\n\t            })\n            .replace(this.Matchers.Interpolate || this.Matchers.GuaranteedNonMatch,\n            \t(pMatch, pCode) =>\n            \t{\n\t                return `'+\\n(${decodeURIComponent(pCode)})+\\n'`;\n\t            })\n\t        .replace(this.Matchers.Evaluate || this.Matchers.GuaranteedNonMatch,\n\t\t\t\t(pMatch, pCode) =>\n            \t{\n\t                return `';\\n${decodeURIComponent(pCode)}\\n;__p+='`;\n\t            }) + `';\\n`;\n\n\n        this.TemplateSource = `with(pTemplateDataObject||{}){\\n${this.TemplateSource}}\\n`;\n        this.TemplateSource = `var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};\\n${this.TemplateSource}return __p;\\n`;\n\n        this.renderFunction = new Function('pTemplateDataObject', this.TemplateSource);\n\n        if (typeof(pData) != 'undefined')\n        {\n            return this.renderFunction(pData);\n        }\n\n        // Provide the compiled function source as a convenience for build time\n        // precompilation.\n        this.TemplateSourceCompiled = 'function(obj){\\n' + this.TemplateSource + '}';\n\n        return this.templateFunction();\n\t}\n}\n\nmodule.exports = FableUtility;","const libFableUtilityTemplate = require('./Fable-Utility-Template.js');\n\nclass FableUtility\n{\n\tconstructor(pFable)\n\t{\n\t\tthis.fable = pFable;\n\t}\n\n\t// Underscore and lodash have a behavior, _.extend, which merges objects.\n\t// Now that es6 gives us this, use the native thingy.\n\textend(pDestinationObject, ...pSourceObjects)\n\t{\n\t\treturn Object.assign(pDestinationObject, ...pSourceObjects);\n\t}\n\n\t// Underscore and lodash have a behavior, _.template, which compiles a\n\t// string-based template with code snippets into simple executable pieces,\n\t// with the added twist of returning a precompiled function ready to go.\n\ttemplate(pTemplateText, pData)\n\t{\n\t\tlet tmpTemplate = new libFableUtilityTemplate(this.fable, pTemplateText);\n\n\t\treturn tmpTemplate.buildTemplateFunction(pTemplateText, pData);\n\t}\n\n\t// This is a safe, modern version of chunk from underscore\n\t// Algorithm pulled from a mix of these two polyfills:\n\t// https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_chunk\n\t// https://youmightnotneed.com/lodash\n\t// This implementation was most tolerant in browsers.  Uglify can fix the rest.\n\tchunk (pInput, pChunkSize, pChunkCache)\n\t{\n\t\tlet tmpInputArray = [...pInput];\n\t\t// Note lodash defaults to 1, underscore defaults to 0\n\t\tlet tmpChunkSize = (typeof(pChunkSize) == 'number') ? pChunkSize : 0;\n\t\tlet tmpChunkCache = (typeof(pChunkCache) != 'undefined') ? pChunkCache : [];\n\n\t\tif (tmpChunkSize <= 0)\n\t\t{\n\t\t\treturn tmpChunkCache;\n\t\t}\n\n\t\twhile (tmpInputArray.length)\n\t\t{\n\t\t\ttmpChunkCache.push(tmpInputArray.splice(0, tmpChunkSize));\n\t\t}\n\n\t\treturn tmpChunkCache;\n\t}\n}\n\nmodule.exports = FableUtility;","/**\n* Fable Application Services Support Library\n* @license MIT\n* @author <steven@velozo.com>\n*/\nconst libFableSettings = require('fable-settings').FableSettings;\nconst libFableUUID = require('fable-uuid').FableUUID;\nconst libFableLog = require('fable-log').FableLog;\n\nconst libFableUtility = require('./Fable-Utility.js')\n\nclass Fable\n{\n\tconstructor(pSettings)\n\t{\n\t\tlet tmpSettings = new libFableSettings(pSettings);\n\n\t\tthis.settingsManager = tmpSettings;\n\n\t\t// Instantiate the UUID generator\n\t\tthis.libUUID = new libFableUUID(this.settingsManager.settings);\n\n\t\tthis.log = new libFableLog(this.settingsManager.settings);\n\t\tthis.log.initialize();\n\n\t\tthis.Utility = new libFableUtility(this);\n\t}\n\n\tget settings()\n\t{\n\t\treturn this.settingsManager.settings;\n\t}\n\n\tget fable()\n\t{\n\t\treturn this;\n\t}\n\n\tgetUUID()\n\t{\n\t\treturn this.libUUID.getUUID();\n\t}\n}\n\nmodule.exports = Fable;"]}