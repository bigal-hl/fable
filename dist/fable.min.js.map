{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/async.eachlimit/index.js","fable.min.js","node_modules/async.iterator/index.js","node_modules/async.util.eachoflimit/index.js","node_modules/async.util.ensureasync/index.js","node_modules/async.util.isarray/index.js","node_modules/async.util.isarraylike/index.js","node_modules/async.util.keyiterator/index.js","node_modules/async.util.keys/index.js","node_modules/async.util.noop/index.js","node_modules/async.util.once/index.js","node_modules/async.util.onlyonce/index.js","node_modules/async.util.restparam/index.js","node_modules/async.util.setimmediate/index.js","node_modules/async.util.withoutindex/index.js","node_modules/async.waterfall/index.js","node_modules/fable-log/source/Fable-Log-BaseLogger.js","node_modules/fable-log/source/Fable-Log-DefaultProviders-Web.js","node_modules/fable-log/source/Fable-Log-DefaultStreams.json","node_modules/fable-log/source/Fable-Log-Logger-Console.js","node_modules/fable-log/source/Fable-Log-Logger-SimpleFlatFile.js","node_modules/fable-log/source/Fable-Log.js","node_modules/fable-settings/source/Fable-Settings-Default.json","node_modules/fable-settings/source/Fable-Settings-TemplateProcessor.js","node_modules/fable-settings/source/Fable-Settings.js","node_modules/fable-uuid/source/Fable-UUID-Random-Browser.js","node_modules/fable-uuid/source/Fable-UUID.js","node_modules/path-browserify/index.js","node_modules/precedent/source/Precedent.js","node_modules/precedent/source/StringParser.js","node_modules/precedent/source/WordTree.js","node_modules/process/browser.js","node_modules/timers-browserify/main.js","source/Fable-Browser-Shim.js","source/Fable-Operation.js","source/Fable-Service-Template.js","source/Fable-ServiceManager.js","source/Fable-ServiceProviderBase.js","source/Fable-Utility.js","source/Fable.js"],"names":["f","exports","module","define","amd","window","global","self","this","Fable","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","eachOfLimit","withoutIndex","arr","limit","iterator","cb","tasks","makeCallback","index","fn","apply","arguments","next","once","noop","onlyOnce","keyIterator","obj","nextKey","done","running","errored","replenish","key","err","setImmediate","restParam","args","callback","pop","push","innerArgs","sync","Array","isArray","Object","prototype","toString","_keys","isArrayLike","coll","len","keys","k","hasOwnProperty","func","startIndex","Math","max","rest","_setImmediate","fallback","setTimeout","timers","value","ensureAsync","wrapIterator","concat","constructor","pLogStreamSettings","pFableLog","_Settings","loggerUUID","generateInsecureUUID","levels","tmpDate","Date","getTime","replace","pCharacter","tmpRandomData","random","floor","initialize","trace","pLogText","pLogObject","write","debug","info","warn","error","fatal","pLogLevel","getDefaultProviders","tmpDefaultProviders","console","default","loggertype","streamtype","level","libBaseLogger","super","_ShowTimeStamps","showtimestamps","_FormattedTimeStamps","formattedtimestamps","_ContextMessage","Context","Product","_OutputLogLinesToConsole","outputloglinestoconsole","_OutputObjectsToConsole","outputobjectstoconsole","prefixCache","pLevel","pObject","tmpTimeStamp","toISOString","tmpLogLine","log","JSON","stringify","libConsoleLog","libFS","libPath","logFileRawPath","path","logFilePath","normalize","logFileStreamOptions","fileStreamOptions","flags","encoding","fileWriter","createWriteStream","activelyWriting","logLineStrings","logObjectStrings","defaultWriteCompleteCallback","defaultBufferFlushCallback","closeWriter","fCloseComplete","tmpCloseComplete","end","bind","completeBufferFlushToLogFile","fFlushComplete","tmpFlushComplete","flushBufferToLogFile","tmpLineStrings","tmpObjectStrings","tmpConstructedBufferOutputString","fs","FableLog","pFableSettings","pFable","tmpSettings","_Providers","_StreamDefinitions","LogStreams","logStreams","logProviders","activeLogStreams","logStreamsTrace","logStreamsDebug","logStreamsInfo","logStreamsWarn","logStreamsError","logStreamsFatal","datumDecorator","pDatum","uuid","addLogger","pLogger","setDatumDecorator","fDatumDecorator","pMessage","tmpDecoratedDatum","tmpStreamDefinition","assign","logTime","tmpMessage","tmpTime","getTimeStamp","getTimeDelta","pTimeStamp","logTimeDelta","pTimeDelta","tmpEndTime","logTimeDeltaHuman","tmpMs","parseInt","tmpSeconds","tmpMinutes","tmpHours","logTimeDeltaRelative","pStartTime","logTimeDeltaRelativeHuman","new","pSettings","LogProviderBase","LogProviderConsole","ProductVersion","ConfigFile","process","pDependencies","templateProcessor","precedent","addPattern","pTemplateValue","tmpTemplateValue","trim","tmpSeparatorIndex","indexOf","tmpDefaultValue","substring","tmpEnvironmentVariableName","env","parseSetting","pString","parseString","_process","libPrecedent","libFableSettingsTemplateProcessor","FableSettings","dependencies","settingsTemplateProcessor","_configureEnvTemplating","buildDefaultSettings","merge","base","parse","DefaultConfigFile","pException","settings","_PerformEnvTemplating","NoEnvReplacement","_resolveEnv","tmpKey","_isObject","_deepMergeObjects","toObject","fromObject","forEach","fromValue","toValue","pSettingsFrom","pSettingsTo","tmpSettingsFrom","tmpSettingsTo","tmpSettingsFromCopy","fill","getRandomValues","crypto","msCrypto","generateWhatWGBytes","tmpBuffer","Uint8Array","generateRandomBytes","tmpValue","generate","libRandomByteGenerator","FableUUID","_UUIDModeRandom","UUIDModeRandom","_UUIDLength","UUIDLength","_UUIDRandomDictionary","UUIDDictionary","randomByteGenerator","_HexLookup","substr","bytesToUUID","pBuffer","join","generateUUIDv4","tmpRandomBytes","generateRandom","tmpUUID","charAt","getUUID","assertPath","TypeError","normalizeStringPosix","allowAboveRoot","res","lastSegmentLength","lastSlash","dots","charCodeAt","lastSlashIndex","lastIndexOf","slice","posix","resolve","cwd","resolvedPath","resolvedAbsolute","undefined","isAbsolute","trailingSeparator","joined","arg","relative","from","to","fromStart","fromEnd","fromLen","toStart","toLen","lastCommonSep","fromCode","out","_makeLong","dirname","hasRoot","matchedSlash","basename","ext","start","extIdx","firstNonSlashEnd","extname","startDot","startPart","preDotState","format","pathObject","sep","dir","root","name","_format","ret","delimiter","win32","libWordTree","libStringParser","WordTree","StringParser","ParseTree","pPatternStart","pPatternEnd","pParser","newParserState","pParseTree","Output","OutputBuffer","Pattern","PatternMatch","PatternMatchOutputBuffer","assignNode","pNode","pParserState","appendOutputBuffer","flushOutputBuffer","checkPatternEnd","PatternEnd","PatternStart","Parse","parseCharacter","tmpParserState","addChild","pTree","pPattern","pIndex","tmpLeaf","pData","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","fun","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","drainQueue","timeout","run","marker","runClearTimeout","Item","array","nextTick","title","browser","argv","version","versions","on","addListener","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","chdir","umask","clearImmediate","Function","immediateIds","nextImmediateId","Timeout","id","clearFn","_id","_clearFn","setInterval","clearInterval","close","unref","ref","enroll","item","msecs","_idleTimeoutId","_idleTimeout","unenroll","_unrefActive","active","_onTimeout","libNPMModuleWrapper","_OperationStatePrototype","Metadata","GUID","Hash","Title","Summary","Version","Status","Completed","CompletionProgress","CompletionTimeElapsed","Steps","StepsCompleted","StartTime","EndTime","Errors","Log","pOperationName","pOperationHash","fable","state","writeOperationLog","toUTCString","writeOperationErrors","libFableServiceBase","pOptions","pServiceHash","serviceType","Matchers","Evaluate","Interpolate","Escaper","Unescaper","GuaranteedNonMatch","templateEscapes","u2028","u2029","renderFunction","templateString","renderTemplate","templateFunction","buildTemplateFunction","pTemplateText","TemplateSource","pMatch","pCode","decodeURIComponent","TemplateSourceCompiled","serviceTypes","services","defaultServices","serviceClasses","addServiceType","pServiceType","pServiceClass","instantiateServiceProvider","pCustomServiceHash","tmpService","instantiateServiceProviderWithoutRegistration","setDefaultServiceInstantiation","ServiceProviderBase","options","UUID","libAsyncWaterfall","libAsyncEachLimit","templates","waterfall","eachLimit","extend","pDestinationObject","pSourceObjects","template","serviceManager","buildHashedTemplate","pTemplateHash","tmpTemplate","chunk","pInput","pChunkSize","pChunkCache","tmpInputArray","tmpChunkSize","tmpChunkCache","splice","libFableSettings","libFableUUID","libFableLog","libFableUtility","libFableServiceManager","libFableServiceTemplate","libFableOperation","settingsManager","libUUID","Utility","Dependencies","Operations","createOperation","tmpOperation","getOperation"],"mappings":"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","file":"fable.min.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","'use strict';\n\nvar eachOfLimit = require('async.util.eachoflimit');\nvar withoutIndex = require('async.util.withoutindex');\n\nmodule.exports = function eachLimit(arr, limit, iterator, cb) {\n    return eachOfLimit(limit)(arr, withoutIndex(iterator), cb);\n};\n","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.Fable = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n'use strict';\n\nvar eachOfLimit = require('async.util.eachoflimit');\nvar withoutIndex = require('async.util.withoutindex');\n\nmodule.exports = function eachLimit(arr, limit, iterator, cb) {\n    return eachOfLimit(limit)(arr, withoutIndex(iterator), cb);\n};\n\n},{\"async.util.eachoflimit\":3,\"async.util.withoutindex\":14}],2:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function(tasks) {\n    function makeCallback(index) {\n        function fn() {\n            if (tasks.length) {\n                tasks[index].apply(null, arguments);\n            }\n            return fn.next();\n        }\n        fn.next = function() {\n            return (index < tasks.length - 1) ? makeCallback(index + 1) : null;\n        };\n        return fn;\n    }\n    return makeCallback(0);\n};\n\n},{}],3:[function(require,module,exports){\nvar once = require('async.util.once');\nvar noop = require('async.util.noop');\nvar onlyOnce = require('async.util.onlyonce');\nvar keyIterator = require('async.util.keyiterator');\n\nmodule.exports = function eachOfLimit(limit) {\n    return function(obj, iterator, cb) {\n        cb = once(cb || noop);\n        obj = obj || [];\n        var nextKey = keyIterator(obj);\n        if (limit <= 0) {\n            return cb(null);\n        }\n        var done = false;\n        var running = 0;\n        var errored = false;\n\n        (function replenish() {\n            if (done && running <= 0) {\n                return cb(null);\n            }\n\n            while (running < limit && !errored) {\n                var key = nextKey();\n                if (key === null) {\n                    done = true;\n                    if (running <= 0) {\n                        cb(null);\n                    }\n                    return;\n                }\n                running += 1;\n                iterator(obj[key], key, onlyOnce(function(err) {\n                    running -= 1;\n                    if (err) {\n                        cb(err);\n                        errored = true;\n                    } else {\n                        replenish();\n                    }\n                }));\n            }\n        })();\n    };\n};\n\n},{\"async.util.keyiterator\":7,\"async.util.noop\":9,\"async.util.once\":10,\"async.util.onlyonce\":11}],4:[function(require,module,exports){\n'use strict';\nvar setImmediate = require('async.util.setimmediate');\nvar restParam = require('async.util.restparam');\n\nmodule.exports = function(fn) {\n    return restParam(function(args) {\n        var callback = args.pop();\n        args.push(function() {\n            var innerArgs = arguments;\n            if (sync) {\n                setImmediate(function() {\n                    callback.apply(null, innerArgs);\n                });\n            } else {\n                callback.apply(null, innerArgs);\n            }\n        });\n        var sync = true;\n        fn.apply(this, args);\n        sync = false;\n    });\n};\n\n},{\"async.util.restparam\":12,\"async.util.setimmediate\":13}],5:[function(require,module,exports){\n'use strict';\n\nmodule.exports = Array.isArray || function isArray(obj) {\n    return Object.prototype.toString.call(obj) === '[object Array]';\n};\n\n},{}],6:[function(require,module,exports){\n'use strict';\n\nvar isArray = require('async.util.isarray');\n\nmodule.exports = function isArrayLike(arr) {\n    return isArray(arr) || (\n        // has a positive integer length property\n        typeof arr.length === 'number' &&\n        arr.length >= 0 &&\n        arr.length % 1 === 0\n    );\n};\n\n},{\"async.util.isarray\":5}],7:[function(require,module,exports){\n'use strict';\n\nvar _keys = require('async.util.keys');\nvar isArrayLike = require('async.util.isarraylike');\n\nmodule.exports = function keyIterator(coll) {\n    var i = -1;\n    var len;\n    var keys;\n    if (isArrayLike(coll)) {\n        len = coll.length;\n        return function next() {\n            i++;\n            return i < len ? i : null;\n        };\n    } else {\n        keys = _keys(coll);\n        len = keys.length;\n        return function next() {\n            i++;\n            return i < len ? keys[i] : null;\n        };\n    }\n};\n\n},{\"async.util.isarraylike\":6,\"async.util.keys\":8}],8:[function(require,module,exports){\n'use strict';\n\nmodule.exports = Object.keys || function keys(obj) {\n    var _keys = [];\n    for (var k in obj) {\n        if (obj.hasOwnProperty(k)) {\n            _keys.push(k);\n        }\n    }\n    return _keys;\n};\n\n},{}],9:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function noop () {};\n\n},{}],10:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function once(fn) {\n    return function() {\n        if (fn === null) return;\n        fn.apply(this, arguments);\n        fn = null;\n    };\n};\n\n},{}],11:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function only_once(fn) {\n    return function() {\n        if (fn === null) throw new Error('Callback was already called.');\n        fn.apply(this, arguments);\n        fn = null;\n    };\n};\n\n},{}],12:[function(require,module,exports){\n'use strict';\nmodule.exports = function restParam(func, startIndex) {\n    startIndex = startIndex == null ? func.length - 1 : +startIndex;\n    return function() {\n        var length = Math.max(arguments.length - startIndex, 0);\n        var rest = new Array(length);\n        for (var index = 0; index < length; index++) {\n            rest[index] = arguments[index + startIndex];\n        }\n        switch (startIndex) {\n            case 0:\n                return func.call(this, rest);\n            case 1:\n                return func.call(this, arguments[0], rest);\n        }\n    };\n};\n\n},{}],13:[function(require,module,exports){\n(function (setImmediate){(function (){\n'use strict';\n\nvar _setImmediate = typeof setImmediate === 'function' && setImmediate;\nvar fallback = function(fn) {\n    setTimeout(fn, 0);\n};\n\nmodule.exports = function setImmediate(fn) {\n    // not a direct alias for IE10 compatibility\n    return (_setImmediate || fallback)(fn);\n};\n\n}).call(this)}).call(this,require(\"timers\").setImmediate)\n\n},{\"timers\":33}],14:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function withoutIndex(iterator) {\n    return function(value, index, callback) {\n        return iterator(value, callback);\n    };\n};\n\n},{}],15:[function(require,module,exports){\n'use strict';\n\nvar once = require('async.util.once');\nvar noop = require('async.util.noop');\nvar isArray = require('async.util.isarray');\nvar restParam = require('async.util.restparam');\nvar ensureAsync = require('async.util.ensureasync');\nvar iterator = require('async.iterator');\n\nmodule.exports = function(tasks, cb) {\n    cb = once(cb || noop);\n    if (!isArray(tasks)) return cb(new Error('First argument to waterfall must be an array of functions'));\n    if (!tasks.length) return cb();\n\n    function wrapIterator(iterator) {\n        return restParam(function(err, args) {\n            if (err) {\n                cb.apply(null, [err].concat(args));\n            } else {\n                var next = iterator.next();\n                if (next) {\n                    args.push(wrapIterator(next));\n                } else {\n                    args.push(cb);\n                }\n                ensureAsync(iterator).apply(null, args);\n            }\n        });\n    }\n    wrapIterator(iterator(tasks))();\n};\n\n},{\"async.iterator\":2,\"async.util.ensureasync\":4,\"async.util.isarray\":5,\"async.util.noop\":9,\"async.util.once\":10,\"async.util.restparam\":12}],16:[function(require,module,exports){\n\n},{}],17:[function(require,module,exports){\n/**\n* Base Logger Class\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\nclass BaseLogger\n{\n\tconstructor(pLogStreamSettings, pFableLog)\n\t{\n\t\t// This should not possibly be able to be instantiated without a settings object\n\t\tthis._Settings = (typeof(pLogStreamSettings) == 'object') ? pLogStreamSettings : {};\n\n\t\t// The base logger does nothing but associate a UUID with itself\n\t\t// We added this as the mechanism for tracking loggers to allow multiple simultaneous streams\n\t\t// to the same provider.\n\t\tthis.loggerUUID = this.generateInsecureUUID();\n\n\t\t// Eventually we can use this array to ompute which levels the provider allows.\n\t\t// For now it's just used to precompute some string concatenations.\n\t\tthis.levels = (\n\t\t\t[\n\t\t\t\t\"trace\",\n\t\t\t\t\"debug\",\n\t\t\t\t\"info\",\n\t\t\t\t\"warn\",\n\t\t\t\t\"error\",\n\t\t\t\t\"fatal\"\n\t\t\t]);\n\t}\n\n\t// This is meant to generate programmatically insecure UUIDs to identify loggers\n\tgenerateInsecureUUID()\n\t{\n\t\tlet tmpDate = new Date().getTime();\n\t\tlet tmpUUID = 'LOGSTREAM-xxxxxx-yxxxxx'.replace(/[xy]/g,\n\t\t\t\t(pCharacter) =>\n\t\t\t\t{\n\t\t\t\t\t// Funny algorithm from w3resource that is twister-ish without the deep math and security\n\t\t\t\t\t// ..but good enough for unique log stream identifiers\n\t\t\t\t\tlet tmpRandomData = (tmpDate + Math.random()*16)%16 | 0;\n\t\t\t\t\ttmpDate = Math.floor(tmpDate/16);\n\n\t\t\t\t\treturn (pCharacter =='x' ? tmpRandomData : (tmpRandomData&0x3|0x8)).toString(16);\n\t\t\t\t});\n\t\treturn tmpUUID;\n\t}\n\n\tinitialize()\n\t{\n\t\t// No operation.\n\t}\n\n\ttrace(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"trace\", pLogText, pLogObject);\n\t}\n\n\tdebug(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"debug\", pLogText, pLogObject);\n\t}\n\n\tinfo(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"info\", pLogText, pLogObject);\n\t}\n\n\twarn(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"warn\", pLogText, pLogObject);\n\t}\n\n\terror(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"error\", pLogText, pLogObject);\n\t}\n\n\tfatal(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"fatal\", pLogText, pLogObject);\n\t}\n\n\twrite(pLogLevel, pLogText, pLogObject)\n\t{\n\t\t// The base logger does nothing.\n\t\treturn true;\n\t}\n}\n\nmodule.exports = BaseLogger;\n\n},{}],18:[function(require,module,exports){\n/**\n* Default Logger Provider Function\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\n// Return the providers that are available without extensions loaded\ngetDefaultProviders = () =>\n{\n\tlet tmpDefaultProviders = {};\n\n\ttmpDefaultProviders.console = require('./Fable-Log-Logger-Console.js');\n\n\ttmpDefaultProviders.default = tmpDefaultProviders.console;\n\n\treturn tmpDefaultProviders;\n}\n\nmodule.exports = getDefaultProviders();\n},{\"./Fable-Log-Logger-Console.js\":20}],19:[function(require,module,exports){\nmodule.exports=[\n    {\n        \"loggertype\": \"console\",\n        \"streamtype\": \"console\",\n        \"level\": \"trace\"\n    }\n]\n},{}],20:[function(require,module,exports){\nlet libBaseLogger = require('./Fable-Log-BaseLogger.js');\n\nclass ConsoleLogger extends libBaseLogger\n{\n\tconstructor(pLogStreamSettings, pFableLog)\n\t{\n\t\tsuper(pLogStreamSettings);\n\n\t\tthis._ShowTimeStamps = this._Settings.hasOwnProperty('showtimestamps') ? (this._Settings.showtimestamps == true) : true;\n\t\tthis._FormattedTimeStamps = this._Settings.hasOwnProperty('formattedtimestamps') ? (this._Settings.formattedtimestamps == true) : true;\n\n\t\tthis._ContextMessage = this._Settings.hasOwnProperty('Context') ? `(${this._Settings.Context})` : \n\t\t\t\t\t\t\t\tpFableLog._Settings.hasOwnProperty('Product') ? `(${pFableLog._Settings.Product})` :\n\t\t\t\t\t\t\t\t'Unnamed_Log_Context';\n\n\t\t// Allow the user to decide what gets output to the console\n\t\tthis._OutputLogLinesToConsole = this._Settings.hasOwnProperty('outputloglinestoconsole') ? this._Settings.outputloglinestoconsole : true;\n\t\tthis._OutputObjectsToConsole = this._Settings.hasOwnProperty('outputobjectstoconsole') ? this._Settings.outputobjectstoconsole : true;\n\n\t\t// Precompute the prefix for each level\n\t\tthis.prefixCache = {};\n\t\tfor (let i = 0; i <= this.levels.length; i++)\n\t\t{\n\t\t\tthis.prefixCache[this.levels[i]] = `[${this.levels[i]}] ${this._ContextMessage}: `;\n\n\t\t\tif (this._ShowTimeStamps)\n\t\t\t{\n\t\t\t\t// If there is a timestamp we need a to prepend space before the prefixcache string, since the timestamp comes first\n\t\t\t\tthis.prefixCache[this.levels[i]] = ' '+this.prefixCache[this.levels[i]];\n\t\t\t}\n\t\t}\n\t}\n\n\twrite(pLevel, pLogText, pObject)\n\t{\n\t\tlet tmpTimeStamp = '';\n\t\tif (this._ShowTimeStamps && this._FormattedTimeStamps)\n\t\t{\n\t\t\ttmpTimeStamp = (new Date()).toISOString();\n\t\t}\n\t\telse if (this._ShowTimeStamps)\n\t\t{\n\t\t\ttmpTimeStamp = +new Date();\n\t\t}\n\n\t\tlet tmpLogLine = `${tmpTimeStamp}${this.prefixCache[pLevel]}${pLogText}`;\n\n\t\tif (this._OutputLogLinesToConsole)\n\t\t{\n\t\t\tconsole.log(tmpLogLine);\n\t\t}\n\n\t\t// Write out the object on a separate line if it is passed in\n\t\tif (this._OutputObjectsToConsole && (typeof(pObject) !== 'undefined'))\n\t\t{\n\t\t\tconsole.log(JSON.stringify(pObject, null, 2));\n\t\t}\n\n\t\t// Provide an easy way to be overridden and be consistent\n\t\treturn tmpLogLine;\n\t}\n}\n\nmodule.exports = ConsoleLogger;\n},{\"./Fable-Log-BaseLogger.js\":17}],21:[function(require,module,exports){\nconst libConsoleLog = require('./Fable-Log-Logger-Console.js');\nconst libFS = require('fs');\nconst libPath = require('path');\n\nclass SimpleFlatFileLogger extends libConsoleLog\n{\n\tconstructor(pLogStreamSettings, pFableLog)\n\t{\n\t\tsuper(pLogStreamSettings, pFableLog);\n\n\t\t// If a path isn't provided for the logfile, it tries to use the ProductName or Context\n\t\tthis.logFileRawPath = (this._Settings.hasOwnProperty('path')) ? this._Settings.path : `./${this._ContextMessage}.log`;\n\t\tthis.logFilePath = libPath.normalize(this.logFileRawPath);\n\n\t\tthis.logFileStreamOptions = (this._Settings.hasOwnProperty('fileStreamoptions')) ? this._Settings.fileStreamOptions : (\n\t\t\t{\n\t\t\t\t\"flags\": \"a\",\n\t\t\t\t\"encoding\": \"utf8\"\n\t\t\t})\n\n\t\tthis.fileWriter = libFS.createWriteStream(this.logFilePath, this.logFileStreamOptions);\n\n\t\tthis.activelyWriting = false;\n\n\t\tthis.logLineStrings = [];\n\t\tthis.logObjectStrings = [];\n\n\t\tthis.defaultWriteCompleteCallback = ()=>{};\n\t\tthis.defaultBufferFlushCallback = ()=>{};\n\t}\n\n\tcloseWriter(fCloseComplete)\n\t{\n\t\tlet tmpCloseComplete = (typeof(fCloseComplete) == 'function') ? fCloseComplete : ()=>{};\n\t\tif (this.fileWriter)\n\t\t{\n\t\t\tthis.fileWriter.end('\\n');\n\t\t\treturn this.fileWriter.once('finish', tmpCloseComplete.bind(this));\n\t\t}\n\t};\n\n\tcompleteBufferFlushToLogFile(fFlushComplete)\n\t{\n\t\tthis.activelyWriting = false;\n\t\tlet tmpFlushComplete = (typeof(fFlushComplete) == 'function') ? fFlushComplete : this.defaultBufferFlushCallback;\n\n\t\tif (this.logLineStrings.length > 0)\n\t\t{\n\t\t\tthis.flushBufferToLogFile(tmpFlushComplete);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn tmpFlushComplete();\n\t\t}\n\t}\n\n\tflushBufferToLogFile(fFlushComplete)\n\t{\n\t\tif (!this.activelyWriting)\n\t\t{\n\t\t\t// Only want to be writing one thing at a time....\n\t\t\tthis.activelyWriting = true;\n\n\t\t\tlet tmpFlushComplete = (typeof(fFlushComplete) == 'function') ? fFlushComplete : this.defaultBufferFlushCallback;\n\n\t\t\t// Get the current buffer arrays.  These should always have matching number of elements.\n\t\t\tlet tmpLineStrings = this.logLineStrings;\n\t\t\tlet tmpObjectStrings = this.logObjectStrings;\n\n\t\t\t// Reset these to be filled while we process this queue...\n\t\t\tthis.logLineStrings = [];\n\t\t\tthis.logObjectStrings = [];\n\n\t\t\t// This is where we will put each line before writing it to the file...\n\t\t\tlet tmpConstructedBufferOutputString = '';\n\n\t\t\tfor (let i = 0; i < tmpLineStrings.length; i++)\n\t\t\t{\n\t\t\t\t// TODO: Windows Newline?   ....... yo no se!\n\t\t\t\ttmpConstructedBufferOutputString += `${tmpLineStrings[i]}\\n`;\n\t\t\t\tif (tmpObjectStrings[i] !== false)\n\t\t\t\t{\n\t\t\t\t\ttmpConstructedBufferOutputString += `${tmpObjectStrings[i]}\\n`;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!this.fileWriter.write(tmpConstructedBufferOutputString, 'utf8'))\n\t\t\t{\n\t\t\t\t// If the streamwriter returns false, we need to wait for it to drain.\n\t\t\t\tthis.fileWriter.once('drain', this.completeBufferFlushToLogFile.bind(this, tmpFlushComplete));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn this.completeBufferFlushToLogFile(tmpFlushComplete);\n\t\t\t}\n\t\t}\n\t}\n\n\twrite(pLevel, pLogText, pObject)\n\t{\n\t\tlet tmpLogLine = super.write(pLevel, pLogText, pObject);\n\n\t\t// Use a very simple array as the write buffer\n\t\tthis.logLineStrings.push(tmpLogLine);\n\n\t\t// Write out the object on a separate line if it is passed in\n\t\tif (typeof(pObject) !== 'undefined')\n\t\t{\n\t\t\tthis.logObjectStrings.push(JSON.stringify(pObject, null, 4));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logObjectStrings.push(false);\n\t\t}\n\n\t\tthis.flushBufferToLogFile();\n\t}\n}\n\nmodule.exports = SimpleFlatFileLogger;\n},{\"./Fable-Log-Logger-Console.js\":20,\"fs\":16,\"path\":28}],22:[function(require,module,exports){\n/**\n* Fable Logging Add-on\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable Logger\n*/\n\n/**\n* Fable Solution Log Wrapper Main Class\n*\n* @class FableLog\n* @constructor\n*/\nclass FableLog\n{\n\tconstructor(pFableSettings, pFable)\n\t{\n\t\tlet tmpSettings = (typeof(pFableSettings) === 'object') ? pFableSettings : {}\n\t\tthis._Settings = tmpSettings;\n\n\t\tthis._Providers = require('./Fable-Log-DefaultProviders-Node.js');\n\n\t\tthis._StreamDefinitions = (tmpSettings.hasOwnProperty('LogStreams')) ? tmpSettings.LogStreams : require('./Fable-Log-DefaultStreams.json');\n\n\t\tthis.logStreams = [];\n\n\t\t// This object gets decorated for one-time instantiated providers that\n\t\t//  have multiple outputs, such as bunyan.\n\t\tthis.logProviders = {};\n\n\t\t// A hash list of the GUIDs for each log stream, so they can't be added to the set more than one time\n\t\tthis.activeLogStreams = {};\n\n\t\tthis.logStreamsTrace = [];\n\t\tthis.logStreamsDebug = [];\n\t\tthis.logStreamsInfo = [];\n\t\tthis.logStreamsWarn = [];\n\t\tthis.logStreamsError = [];\n\t\tthis.logStreamsFatal = [];\n\n\t\tthis.datumDecorator = (pDatum) => pDatum;\n\n\t\tthis.uuid = (typeof(tmpSettings.Product) === 'string') ? tmpSettings.Product : 'Default';\n\t}\n\n\taddLogger(pLogger, pLevel)\n\t{\n\t\t// Bail out if we've already created one.\n\t\tif (this.activeLogStreams.hasOwnProperty(pLogger.loggerUUID))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// Add it to the streams and to the mutex\n\t\tthis.logStreams.push(pLogger);\n\t\tthis.activeLogStreams[pLogger.loggerUUID] = true;\n\n\t\t// Make sure a kosher level was passed in\n\t\tswitch (pLevel)\n\t\t{\n\t\t\tcase 'trace':\n\t\t\t\tthis.logStreamsTrace.push(pLogger);\n\t\t\tcase 'debug':\n\t\t\t\tthis.logStreamsDebug.push(pLogger);\n\t\t\tcase 'info':\n\t\t\t\tthis.logStreamsInfo.push(pLogger);\n\t\t\tcase 'warn':\n\t\t\t\tthis.logStreamsWarn.push(pLogger);\n\t\t\tcase 'error':\n\t\t\t\tthis.logStreamsError.push(pLogger);\n\t\t\tcase 'fatal':\n\t\t\t\tthis.logStreamsFatal.push(pLogger);\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tsetDatumDecorator(fDatumDecorator)\n\t{\n\t\tif (typeof(fDatumDecorator) === 'function')\n\t\t{\n\t\t\tthis.datumDecorator = fDatumDecorator;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.datumDecorator = (pDatum) => pDatum;\n\t\t}\n\t}\n\n\ttrace(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsTrace.length; i++)\n\t\t{\n\t\t\tthis.logStreamsTrace[i].trace(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tdebug(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsDebug.length; i++)\n\t\t{\n\t\t\tthis.logStreamsDebug[i].debug(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tinfo(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsInfo.length; i++)\n\t\t{\n\t\t\tthis.logStreamsInfo[i].info(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\twarn(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsWarn.length; i++)\n\t\t{\n\t\t\tthis.logStreamsWarn[i].warn(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\terror(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsError.length; i++)\n\t\t{\n\t\t\tthis.logStreamsError[i].error(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tfatal(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsFatal.length; i++)\n\t\t{\n\t\t\tthis.logStreamsFatal[i].fatal(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tinitialize()\n\t{\n\t\t// \"initialize\" each logger as defined in the logging parameters\n\t\tfor (let i = 0; i < this._StreamDefinitions.length; i++)\n\t\t{\n\t\t\tlet tmpStreamDefinition = Object.assign({loggertype:'default',streamtype:'console',level:'info'},this._StreamDefinitions[i]);\n\n\t\t\tif (!this._Providers.hasOwnProperty(tmpStreamDefinition.loggertype))\n\t\t\t{\n\t\t\t\tconsole.log(`Error initializing log stream: bad loggertype in stream definition ${JSON.stringify(tmpStreamDefinition)}`);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.addLogger(new this._Providers[tmpStreamDefinition.loggertype](tmpStreamDefinition, this), tmpStreamDefinition.level);\n\t\t\t}\n\t\t}\n\n\t\t// Now initialize each one.\n\t\tfor (let i = 0; i < this.logStreams.length; i++)\n\t\t{\n\t\t\tthis.logStreams[i].initialize();\n\t\t}\n\t}\n\n\tlogTime(pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time';\n\t\tlet tmpTime = new Date();\n\t\tthis.info(`${tmpMessage} ${tmpTime} (epoch ${+tmpTime})`, pDatum);\n\t}\n\n\t// Get a timestamp\n\tgetTimeStamp()\n\t{\n\t\treturn +new Date();\n\t}\n\n\tgetTimeDelta(pTimeStamp)\n\t{\n\t\tlet tmpEndTime = +new Date();\n\t\treturn tmpEndTime-pTimeStamp;\n\t}\n\n\t// Log the delta between a timestamp, and now with a message\n\tlogTimeDelta(pTimeDelta, pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time Measurement';\n\t\tlet tmpDatum = (typeof(pDatum) === 'object') ? pDatum : {};\n\n\t\tlet tmpEndTime = +new Date();\n\n\t\tthis.info(`${tmpMessage} logged at (epoch ${+tmpEndTime}) took (${pTimeDelta}ms)`, pDatum);\n\t}\n\n\tlogTimeDeltaHuman(pTimeDelta, pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time Measurement';\n\n\t\tlet tmpEndTime = +new Date();\n\n\t\tlet tmpMs = parseInt(pTimeDelta%1000);\n\t\tlet tmpSeconds = parseInt((pTimeDelta/1000)%60);\n\t\tlet tmpMinutes = parseInt((pTimeDelta/(1000*60))%60);\n\t\tlet tmpHours = parseInt(pTimeDelta/(1000*60*60));\n\n\t\ttmpMs = (tmpMs < 10) ? \"00\"+tmpMs : (tmpMs < 100) ? \"0\"+tmpMs : tmpMs;\n\t\ttmpSeconds = (tmpSeconds < 10) ? \"0\"+tmpSeconds : tmpSeconds;\n\t\ttmpMinutes = (tmpMinutes < 10) ? \"0\"+tmpMinutes : tmpMinutes;\n\t\ttmpHours = (tmpHours < 10) ? \"0\"+tmpHours : tmpHours;\n\n\t\tthis.info(`${tmpMessage} logged at (epoch ${+tmpEndTime}) took (${pTimeDelta}ms) or (${tmpHours}:${tmpMinutes}:${tmpSeconds}.${tmpMs})`, pDatum);\n\t}\n\n\tlogTimeDeltaRelative(pStartTime, pMessage, pDatum)\n\t{\n\t\tthis.logTimeDelta(this.getTimeDelta(pStartTime), pMessage, pDatum);\n\t}\n\n\tlogTimeDeltaRelativeHuman(pStartTime, pMessage, pDatum)\n\t{\n\t\tthis.logTimeDeltaHuman(this.getTimeDelta(pStartTime), pMessage, pDatum);\n\t}\n}\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new FableLog(pSettings);\n}\n\n\nmodule.exports = FableLog;\nmodule.exports.new = autoConstruct;\nmodule.exports.LogProviderBase = require('./Fable-Log-BaseLogger.js');\nmodule.exports.LogProviderConsole = require('./Fable-Log-Logger-Console.js');\nmodule.exports.LogProviderConsole = require('./Fable-Log-Logger-SimpleFlatFile.js');\n\n},{\"./Fable-Log-BaseLogger.js\":17,\"./Fable-Log-DefaultProviders-Node.js\":18,\"./Fable-Log-DefaultStreams.json\":19,\"./Fable-Log-Logger-Console.js\":20,\"./Fable-Log-Logger-SimpleFlatFile.js\":21}],23:[function(require,module,exports){\nmodule.exports={\n\t\"Product\": \"ApplicationNameHere\",\n\t\"ProductVersion\": \"0.0.0\",\n\n\t\"ConfigFile\": false,\n\n\t\"LogStreams\":\n\t[\n\t\t{\n\t\t\t\"level\": \"trace\"\n\t\t}\n\t]\n}\n\n},{}],24:[function(require,module,exports){\n(function (process){(function (){\n/**\n* Fable Settings Template Processor\n*\n* This class allows environment variables to come in via templated expressions, and defaults to be set.\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable Settings\n*/\n\nclass FableSettingsTemplateProcessor\n{\n\tconstructor(pDependencies)\n\t{\n        // Use a no-dependencies templating engine to parse out environment variables\n\t\tthis.templateProcessor = new pDependencies.precedent();\n\n        // TODO: Make the environment variable wrap expression demarcation characters configurable?\n\t\tthis.templateProcessor.addPattern('${', '}',\n\t\t\t(pTemplateValue)=>\n\t\t\t{\n\t\t\t\tlet tmpTemplateValue = pTemplateValue.trim();\n\n\t\t\t\tlet tmpSeparatorIndex = tmpTemplateValue.indexOf('|');\n\n\t\t\t\t// If there is no pipe, the default value will end up being whatever the variable name is.\n\t\t\t\tlet tmpDefaultValue = tmpTemplateValue.substring(tmpSeparatorIndex+1);\n\n\t\t\t\tlet tmpEnvironmentVariableName = (tmpSeparatorIndex > -1) ? tmpTemplateValue.substring(0, tmpSeparatorIndex) : tmpTemplateValue;\n\n\t\t\t\tif (process.env.hasOwnProperty(tmpEnvironmentVariableName))\n\t\t\t\t{\n\t\t\t\t\treturn process.env[tmpEnvironmentVariableName];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn tmpDefaultValue;\n\t\t\t\t}\n\t\t\t});\n    }\n\n    parseSetting(pString)\n    {\n        return this.templateProcessor.parseString(pString);\n    }\n}\n\nmodule.exports = FableSettingsTemplateProcessor;\n}).call(this)}).call(this,require('_process'))\n\n},{\"_process\":32}],25:[function(require,module,exports){\n/**\n* Fable Settings Add-on\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable Settings\n*/\n\nconst libPrecedent = require('precedent');\nconst libFableSettingsTemplateProcessor = require('./Fable-Settings-TemplateProcessor.js');\n\nclass FableSettings\n{\n\tconstructor(pFableSettings)\n\t{\n\t\t// Expose the dependencies for downstream re-use\n\t\tthis.dependencies = (\n\t\t\t{\n\t\t\t\tprecedent: libPrecedent\n\t\t\t});\n\n\t\t// Initialize the settings value template processor\n\t\tthis.settingsTemplateProcessor = new libFableSettingsTemplateProcessor(this.dependencies);\n\n\t\t// set straight away so anything that uses it respects the initial setting\n\t\tthis._configureEnvTemplating(pFableSettings);\n\n\t\tthis.default = this.buildDefaultSettings();\n\n\t\t// Construct a new settings object\n\t\tlet tmpSettings = this.merge(pFableSettings, this.buildDefaultSettings());\n\n\t\t// The base settings object (what they were on initialization, before other actors have altered them)\n\t\tthis.base = JSON.parse(JSON.stringify(tmpSettings));\n\n\t\tif (tmpSettings.DefaultConfigFile)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// If there is a DEFAULT configuration file, try to load and merge it.\n\t\t\t\ttmpSettings = this.merge(require(tmpSettings.DefaultConfigFile), tmpSettings);\n\t\t\t}\n\t\t\tcatch (pException)\n\t\t\t{\n\t\t\t\t// Why this?  Often for an app we want settings to work out of the box, but\n\t\t\t\t// would potentially want to have a config file for complex settings.\n\t\t\t\tconsole.log('Fable-Settings Warning: Default configuration file specified but there was a problem loading it.  Falling back to base.');\n\t\t\t\tconsole.log('     Loading Exception: '+pException);\n\t\t\t}\n\t\t}\n\n\t\tif (tmpSettings.ConfigFile)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// If there is a configuration file, try to load and merge it.\n\t\t\t\ttmpSettings = this.merge(require(tmpSettings.ConfigFile), tmpSettings);\n\t\t\t}\n\t\t\tcatch (pException)\n\t\t\t{\n\t\t\t\t// Why this?  Often for an app we want settings to work out of the box, but\n\t\t\t\t// would potentially want to have a config file for complex settings.\n\t\t\t\tconsole.log('Fable-Settings Warning: Configuration file specified but there was a problem loading it.  Falling back to base.');\n\t\t\t\tconsole.log('     Loading Exception: '+pException);\n\t\t\t}\n\t\t}\n\n\t\tthis.settings = tmpSettings;\n\t}\n\n\t// Build a default settings object.  Use the JSON jimmy to ensure it is always a new object.\n\tbuildDefaultSettings()\n\t{\n\t\treturn JSON.parse(JSON.stringify(require('./Fable-Settings-Default')));\n\t}\n\n\t// Update the configuration for environment variable templating based on the current settings object\n\t_configureEnvTemplating(pSettings)\n\t{\n\t\t// default environment variable templating to on\n\t\tthis._PerformEnvTemplating = !pSettings || pSettings.NoEnvReplacement !== true;\n\t}\n\n\t// Resolve (recursive) any environment variables found in settings object.\n\t_resolveEnv(pSettings)\n\t{\n\t\tfor (const tmpKey in pSettings)\n\t\t{\n\t\t\tif (typeof(pSettings[tmpKey]) === 'object')\n\t\t\t{\n\t\t\t\tthis._resolveEnv(pSettings[tmpKey]);\n\t\t\t}\n\t\t\telse if (typeof(pSettings[tmpKey]) === 'string')\n\t\t\t{\n\t\t\t\tpSettings[tmpKey] = this.settingsTemplateProcessor.parseSetting(pSettings[tmpKey]);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Check to see if a value is an object (but not an array).\n\t */\n\t_isObject(value)\n\t{\n\t\treturn typeof(value) === 'object' && !Array.isArray(value);\n\t}\n\n\t/**\n\t * Merge two plain objects. Keys that are objects in both will be merged property-wise.\n\t */\n\t_deepMergeObjects(toObject, fromObject)\n\t{\n\t\tif (!fromObject || !this._isObject(fromObject))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tObject.keys(fromObject).forEach((key) =>\n\t\t{\n\t\t\tconst fromValue = fromObject[key];\n\t\t\tif (this._isObject(fromValue))\n\t\t\t{\n\t\t\t\tconst toValue = toObject[key];\n\t\t\t\tif (toValue && this._isObject(toValue))\n\t\t\t\t{\n\t\t\t\t\t// both are objects, so do a recursive merge\n\t\t\t\t\tthis._deepMergeObjects(toValue, fromValue);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttoObject[key] = fromValue;\n\t\t});\n\t\treturn toObject;\n\t}\n\n\t// Merge some new object into the existing settings.\n\tmerge(pSettingsFrom, pSettingsTo)\n\t{\n\t\t// If an invalid settings from object is passed in (e.g. object constructor without passing in anything) this should still work\n\t\tlet tmpSettingsFrom = (typeof(pSettingsFrom) === 'object') ? pSettingsFrom : {};\n\t\t// Default to the settings object if none is passed in for the merge.\n\t\tlet tmpSettingsTo = (typeof(pSettingsTo) === 'object') ? pSettingsTo : this.settings;\n\n\t\t// do not mutate the From object property values\n\t\tlet tmpSettingsFromCopy = JSON.parse(JSON.stringify(tmpSettingsFrom));\n\t\ttmpSettingsTo = this._deepMergeObjects(tmpSettingsTo, tmpSettingsFromCopy);\n\n\t\tif (this._PerformEnvTemplating)\n\t\t{\n\t\t\tthis._resolveEnv(tmpSettingsTo);\n\t\t}\n\t\t// Update env tempating config, since we just updated the config object, and it may have changed\n\t\tthis._configureEnvTemplating(tmpSettingsTo);\n\n\t\treturn tmpSettingsTo;\n\t}\n\n\t// Fill in settings gaps without overwriting settings that are already there\n\tfill(pSettingsFrom)\n\t{\n\t\t// If an invalid settings from object is passed in (e.g. object constructor without passing in anything) this should still work\n\t\tlet tmpSettingsFrom = (typeof(pSettingsFrom) === 'object') ? pSettingsFrom : {};\n\n\t\t// do not mutate the From object property values\n\t\tlet tmpSettingsFromCopy = JSON.parse(JSON.stringify(tmpSettingsFrom));\n\n\t\tthis.settings = this._deepMergeObjects(tmpSettingsFromCopy, this.settings);\n\n\t\treturn this.settings;\n\t}\n};\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new FableSettings(pSettings);\n}\n\nmodule.exports = FableSettings;\nmodule.exports.new = autoConstruct;\nmodule.exports.precedent = libPrecedent;\n},{\"./Fable-Settings-Default\":23,\"./Fable-Settings-TemplateProcessor.js\":24,\"precedent\":29}],26:[function(require,module,exports){\n/**\n* Random Byte Generator - Browser version\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\n// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\nclass RandomBytes\n{\n\tconstructor()\n\t{\n\n\t\t// getRandomValues needs to be invoked in a context where \"this\" is a Crypto\n\t\t// implementation. Also, find the complete implementation of crypto on IE11.\n\t\tthis.getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||\n                      \t\t(typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));\n\t}\n\n\t// WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n\tgenerateWhatWGBytes()\n\t{\n\t\tlet tmpBuffer = new Uint8Array(16); // eslint-disable-line no-undef\n\n\t\tthis.getRandomValues(tmpBuffer);\n\t\treturn tmpBuffer;\n\t}\n\n\t// Math.random()-based (RNG)\n\tgenerateRandomBytes()\n\t{\n\t\t// If all else fails, use Math.random().  It's fast, but is of unspecified\n\t\t// quality.\n\t\tlet tmpBuffer = new Uint8Array(16); // eslint-disable-line no-undef\n\n\t\tfor (let i = 0, tmpValue; i < 16; i++)\n\t\t{\n\t\t\tif ((i & 0x03) === 0)\n\t\t\t{\n\t\t\t\ttmpValue = Math.random() * 0x100000000;\n\t\t\t}\n\n\t\t\ttmpBuffer[i] = tmpValue >>> ((i & 0x03) << 3) & 0xff;\n\t\t}\n\n\t\treturn tmpBuffer;\n\t}\n\n\tgenerate()\n\t{\n\t\tif (this.getRandomValues)\n\t\t{\n\t\t\treturn this.generateWhatWGBytes();\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.generateRandomBytes();\n\t\t}\n\t}\n}\n\nmodule.exports = RandomBytes;\n\n},{}],27:[function(require,module,exports){\n/**\n* Fable UUID Generator\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable UUID\n*/\n\n/**\n* Fable Solution UUID Generation Main Class\n*\n* @class FableUUID\n* @constructor\n*/\n\nvar libRandomByteGenerator = require('./Fable-UUID-Random.js')\n\nclass FableUUID\n{\n\tconstructor(pSettings)\n\t{\n\t\t// Determine if the module is in \"Random UUID Mode\" which means just use the random character function rather than the v4 random UUID spec.\n\t\t// Note this allows UUIDs of various lengths (including very short ones) although guaranteed uniqueness goes downhill fast.\n\t\tthis._UUIDModeRandom = (typeof(pSettings) === 'object') && (pSettings.hasOwnProperty('UUIDModeRandom')) ? (pSettings.UUIDModeRandom == true) : false;\n\t\t// These two properties are only useful if we are in Random mode.  Otherwise it generates a v4 spec\n\t\t// Length for \"Random UUID Mode\" is set -- if not set it to 8\n\t\tthis._UUIDLength = (typeof(pSettings) === 'object') && (pSettings.hasOwnProperty('UUIDLength')) ? (pSettings.UUIDLength + 0) : 8;\n\t\t// Dictionary for \"Random UUID Mode\"\n\t\tthis._UUIDRandomDictionary = (typeof(pSettings) === 'object') && (pSettings.hasOwnProperty('UUIDDictionary')) ? (pSettings.UUIDDictionary + 0) : '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n\n\t\tthis.randomByteGenerator = new libRandomByteGenerator();\n\n\t\t// Lookup table for hex codes\n\t\tthis._HexLookup = [];\n\t\tfor (let i = 0; i < 256; ++i)\n\t\t{\n\t\t\tthis._HexLookup[i] = (i + 0x100).toString(16).substr(1);\n\t\t}\n\t}\n\n\t// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n\tbytesToUUID(pBuffer)\n\t{\n\t\tlet i = 0;\n\t\t// join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n\t\treturn ([\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], \n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]]\n\t\t\t\t]).join('');\n\t}\n\n\t// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n\tgenerateUUIDv4()\n\t{\n\t\tlet tmpBuffer = new Array(16);\n\t\tvar tmpRandomBytes = this.randomByteGenerator.generate();\n\n\t\t// Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\t\ttmpRandomBytes[6] = (tmpRandomBytes[6] & 0x0f) | 0x40;\n\t\ttmpRandomBytes[8] = (tmpRandomBytes[8] & 0x3f) | 0x80;\n\n\t\treturn this.bytesToUUID(tmpRandomBytes);\n\t}\n\n\t// Simple random UUID generation\n\tgenerateRandom()\n\t{\n\t\tlet tmpUUID = '';\n\n\t\tfor (let i = 0; i < this._UUIDLength; i++)\n\t\t{\n\t\t\ttmpUUID += this._UUIDRandomDictionary.charAt(Math.floor(Math.random() * (this._UUIDRandomDictionary.length-1)));\n\t\t}\n\n\t\treturn tmpUUID;\n\t}\n\n\t// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n\tgetUUID()\n\t{\n\t\tif (this._UUIDModeRandom)\n\t\t{\n\t\t\treturn this.generateRandom();\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.generateUUIDv4();\n\t\t}\n\t}\n}\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new FableUUID(pSettings);\n}\n\n\nmodule.exports = FableUUID;\nmodule.exports.new = autoConstruct;\n\n},{\"./Fable-UUID-Random.js\":26}],28:[function(require,module,exports){\n(function (process){(function (){\n// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n\n}).call(this)}).call(this,require('_process'))\n\n},{\"_process\":32}],29:[function(require,module,exports){\n/**\n* Precedent Meta-Templating\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Process text streams, parsing out meta-template expressions.\n*/\nvar libWordTree = require(`./WordTree.js`);\nvar libStringParser = require(`./StringParser.js`);\n\nclass Precedent\n{\n\t/**\n\t * Precedent Constructor\n\t */\n\tconstructor()\n\t{\n\t\tthis.WordTree = new libWordTree();\n\t\t\n\t\tthis.StringParser = new libStringParser();\n\n\t\tthis.ParseTree = this.WordTree.ParseTree;\n\t}\n\t\n\t/**\n\t * Add a Pattern to the Parse Tree\n\t * @method addPattern\n\t * @param {Object} pTree - A node on the parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @param {number} pIndex - callback function\n\t * @return {bool} True if adding the pattern was successful\n\t */\n\taddPattern(pPatternStart, pPatternEnd, pParser)\n\t{\n\t\treturn this.WordTree.addPattern(pPatternStart, pPatternEnd, pParser);\n\t}\n\t\n\t/**\n\t * Parse a string with the existing parse tree\n\t * @method parseString\n\t * @param {string} pString - The string to parse\n\t * @return {string} The result from the parser\n\t */\n\tparseString(pString)\n\t{\n\t\treturn this.StringParser.parseString(pString, this.ParseTree);\n\t}\n}\n\nmodule.exports = Precedent;\n\n},{\"./StringParser.js\":30,\"./WordTree.js\":31}],30:[function(require,module,exports){\n/**\n* String Parser\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Parse a string, properly processing each matched token in the word tree.\n*/\n\nclass StringParser\n{\n\t/**\n\t * StringParser Constructor\n\t */\n\tconstructor()\n\t{\n\t}\n\t\n\t/**\n\t * Create a fresh parsing state object to work with.\n\t * @method newParserState\n\t * @param {Object} pParseTree - A node on the parse tree to begin parsing from (usually root)\n\t * @return {Object} A new parser state object for running a character parser on\n\t * @private\n\t */\n\tnewParserState (pParseTree)\n\t{\n\t\treturn (\n\t\t{\n\t\t\tParseTree: pParseTree,\n\n\t\t\tOutput: '',\n\t\t\tOutputBuffer: '',\n\n\t\t\tPattern: false,\n\n\t\t\tPatternMatch: false,\n\t\t\tPatternMatchOutputBuffer: ''\n\t\t});\n\t}\n\t\t\n\t/**\n\t * Assign a node of the parser tree to be the next potential match.\n\t * If the node has a PatternEnd property, it is a valid match and supercedes the last valid match (or becomes the initial match).\n\t * @method assignNode\n\t * @param {Object} pNode - A node on the parse tree to assign\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tassignNode (pNode, pParserState)\n\t{\n\t\tpParserState.PatternMatch = pNode;\n\n\t\t// If the pattern has a END we can assume it has a parse function...\n\t\tif (pParserState.PatternMatch.hasOwnProperty('PatternEnd'))\n\t\t{\n\t\t\t// ... this is the legitimate start of a pattern.\n\t\t\tpParserState.Pattern = pParserState.PatternMatch;\n\t\t}\n\t}\n\t\n\t/**\n\t * Append a character to the output buffer in the parser state.\n\t * This output buffer is used when a potential match is being explored, or a match is being explored.\n\t * @method appendOutputBuffer\n\t * @param {string} pCharacter - The character to append\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tappendOutputBuffer (pCharacter, pParserState)\n\t{\n\t\tpParserState.OutputBuffer += pCharacter;\n\t}\n\t\n\t/**\n\t * Flush the output buffer to the output and clear it.\n\t * @method flushOutputBuffer\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tflushOutputBuffer (pParserState)\n\t{\n\t\tpParserState.Output += pParserState.OutputBuffer;\n\t\tpParserState.OutputBuffer = '';\n\t}\n\n\t\n\t/**\n\t * Check if the pattern has ended.  If it has, properly flush the buffer and start looking for new patterns.\n\t * @method checkPatternEnd\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tcheckPatternEnd (pParserState)\n\t{\n\t\tif ((pParserState.OutputBuffer.length >= pParserState.Pattern.PatternEnd.length+pParserState.Pattern.PatternStart.length) && \n\t\t\t(pParserState.OutputBuffer.substr(-pParserState.Pattern.PatternEnd.length) === pParserState.Pattern.PatternEnd))\n\t\t{\n\t\t\t// ... this is the end of a pattern, cut off the end tag and parse it.\n\t\t\t// Trim the start and end tags off the output buffer now\n\t\t\tpParserState.OutputBuffer = pParserState.Pattern.Parse(pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStart.length, pParserState.OutputBuffer.length - (pParserState.Pattern.PatternStart.length+pParserState.Pattern.PatternEnd.length)));\n\t\t\t// Flush the output buffer.\n\t\t\tthis.flushOutputBuffer(pParserState);\n\t\t\t// End pattern mode\n\t\t\tpParserState.Pattern = false;\n\t\t\tpParserState.PatternMatch = false;\n\t\t}\n\t}\n\t\n\t/**\n\t * Parse a character in the buffer.\n\t * @method parseCharacter\n\t * @param {string} pCharacter - The character to append\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tparseCharacter (pCharacter, pParserState)\n\t{\n\t\t// (1) If we aren't in a pattern match, and we aren't potentially matching, and this may be the start of a new pattern....\n\t\tif (!pParserState.PatternMatch && pParserState.ParseTree.hasOwnProperty(pCharacter))\n\t\t{\n\t\t\t// ... assign the node as the matched node.\n\t\t\tthis.assignNode(pParserState.ParseTree[pCharacter], pParserState);\n\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t}\n\t\t// (2) If we are in a pattern match (actively seeing if this is part of a new pattern token)\n\t\telse if (pParserState.PatternMatch)\n\t\t{\n\t\t\t// If the pattern has a subpattern with this key\n\t\t\tif (pParserState.PatternMatch.hasOwnProperty(pCharacter))\n\t\t\t{\n\t\t\t\t// Continue matching patterns.\n\t\t\t\tthis.assignNode(pParserState.PatternMatch[pCharacter], pParserState);\n\t\t\t}\n\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\tif (pParserState.Pattern)\n\t\t\t{\n\t\t\t\t// ... Check if this is the end of the pattern (if we are matching a valid pattern)...\n\t\t\t\tthis.checkPatternEnd(pParserState);\n\t\t\t}\n\t\t}\n\t\t// (3) If we aren't in a pattern match or pattern, and this isn't the start of a new pattern (RAW mode)....\n\t\telse\n\t\t{\n\t\t\tpParserState.Output += pCharacter;\n\t\t}\n\t}\n\t\n\t/**\n\t * Parse a string for matches, and process any template segments that occur.\n\t * @method parseString\n\t * @param {string} pString - The string to parse.\n\t * @param {Object} pParseTree - The parse tree to begin parsing from (usually root)\n\t */\n\tparseString (pString, pParseTree)\n\t{\n\t\tlet tmpParserState = this.newParserState(pParseTree);\n\n\t\tfor (var i = 0; i < pString.length; i++)\n\t\t{\n\t\t\t// TODO: This is not fast.\n\t\t\tthis.parseCharacter(pString[i], tmpParserState);\n\t\t}\n\t\t\n\t\tthis.flushOutputBuffer(tmpParserState);\n\t\t\n\t\treturn tmpParserState.Output;\n\t}\n}\n\nmodule.exports = StringParser;\n\n},{}],31:[function(require,module,exports){\n/**\n* Word Tree\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Create a tree (directed graph) of Javascript objects, one character per object.\n*/\n\nclass WordTree\n{\n\t/**\n\t * WordTree Constructor\n\t */\n\tconstructor()\n\t{\n\t\tthis.ParseTree = {};\n\t}\n\t\n\t/** \n\t * Add a child character to a Parse Tree node\n\t * @method addChild\n\t * @param {Object} pTree - A parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @param {number} pIndex - The index of the character in the pattern\n\t * @returns {Object} The resulting leaf node that was added (or found)\n\t * @private\n\t */\n\taddChild (pTree, pPattern, pIndex)\n\t{\n\t\tif (!pTree.hasOwnProperty(pPattern[pIndex]))\n\t\t\tpTree[pPattern[pIndex]] = {};\n\t\t\n\t\treturn pTree[pPattern[pIndex]];\n\t}\n\t\n\t/** Add a Pattern to the Parse Tree\n\t * @method addPattern\n\t * @param {Object} pPatternStart - The starting string for the pattern (e.g. \"${\")\n\t * @param {string} pPatternEnd - The ending string for the pattern (e.g. \"}\")\n\t * @param {number} pParser - The function to parse if this is the matched pattern, once the Pattern End is met.  If this is a string, a simple replacement occurs.\n\t * @return {bool} True if adding the pattern was successful\n\t */\n\taddPattern (pPatternStart, pPatternEnd, pParser)\n\t{\n\t\tif (pPatternStart.length < 1)\n\t\t\treturn false;\n\n\t\tif ((typeof(pPatternEnd) === 'string') && (pPatternEnd.length < 1))\n\t\t\treturn false;\n\n\t\tlet tmpLeaf = this.ParseTree;\n\n\t\t// Add the tree of leaves iteratively\n\t\tfor (var i = 0; i < pPatternStart.length; i++)\n\t\t\ttmpLeaf = this.addChild(tmpLeaf, pPatternStart, i);\n\n\t\ttmpLeaf.PatternStart = pPatternStart;\n\t\ttmpLeaf.PatternEnd = ((typeof(pPatternEnd) === 'string') && (pPatternEnd.length > 0)) ? pPatternEnd : pPatternStart;\n\t\ttmpLeaf.Parse = (typeof(pParser) === 'function') ? pParser : \n\t\t\t\t\t\t(typeof(pParser) === 'string') ? () => { return pParser; } :\n\t\t\t\t\t\t(pData) => { return pData; };\n\n\t\treturn true;\n\t}\n}\n\nmodule.exports = WordTree;\n\n},{}],32:[function(require,module,exports){\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],33:[function(require,module,exports){\n(function (setImmediate,clearImmediate){(function (){\nvar nextTick = require('process/browser.js').nextTick;\nvar apply = Function.prototype.apply;\nvar slice = Array.prototype.slice;\nvar immediateIds = {};\nvar nextImmediateId = 0;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) { timeout.close(); };\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// That's not how node.js implements it but the exposed api is the same.\nexports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n  var id = nextImmediateId++;\n  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n  immediateIds[id] = true;\n\n  nextTick(function onNextTick() {\n    if (immediateIds[id]) {\n      // fn.call() is faster so we optimize for the common use-case\n      // @see http://jsperf.com/call-apply-segu\n      if (args) {\n        fn.apply(null, args);\n      } else {\n        fn.call(null);\n      }\n      // Prevent ids from leaking\n      exports.clearImmediate(id);\n    }\n  });\n\n  return id;\n};\n\nexports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n  delete immediateIds[id];\n};\n}).call(this)}).call(this,require(\"timers\").setImmediate,require(\"timers\").clearImmediate)\n\n},{\"process/browser.js\":32,\"timers\":33}],34:[function(require,module,exports){\nvar libNPMModuleWrapper = require('./Fable.js');\n\nif ((typeof(window) === 'object') && !window.hasOwnProperty('Fable'))\n{\n\twindow.Fable = libNPMModuleWrapper;\n}\n\nmodule.exports = libNPMModuleWrapper;\n},{\"./Fable.js\":40}],35:[function(require,module,exports){\nconst _OperationStatePrototype = JSON.stringify(\n{\n\t\"Metadata\": {\n\t\t\"GUID\": false,\n\t\t\"Hash\": false,\n\n\t\t\"Title\": \"\",\n\t\t\"Summary\": \"\",\n\n\t\t\"Version\": 0\n\t},\n\t\"Status\": {\n        \"Completed\": false,\n\n        \"CompletionProgress\": 0,\n        \"CompletionTimeElapsed\": 0,\n\n        \"Steps\": 1,\n        \"StepsCompleted\": 0,\n\n        \"StartTime\": 0,\n        \"EndTime\": 0\n\t},\n\t\"Errors\": [],\n\t\"Log\": []\n});\n\nclass FableOperation\n{\n\tconstructor(pFable, pOperationName, pOperationHash)\n\t{\n\t\tthis.fable = pFable;\n\n\t\tthis.name = pOperationName;\n\n\t\tthis.state = JSON.parse(_OperationStatePrototype);\n\n\t\tthis.state.Metadata.GUID = this.fable.getUUID();\n\t\tthis.state.Metadata.Hash = this.state.GUID;\n\n\t\tif (typeof(pOperationHash) == 'string')\n\t\t{\n\t\t\tthis.state.Metadata.Hash = pOperationHash;\n\t\t}\n\t}\n\n\tget GUID()\n\t{\n\t\treturn this.state.Metadata.GUID;\n\t}\n\n\tget Hash()\n\t{\n\t\treturn this.state.Metadata.Hash;\n\t}\n\n\tget log()\n\t{\n\t\treturn this;\n\t}\n\n\twriteOperationLog(pLogLevel, pLogText, pLogObject)\n\t{\n\t\tthis.state.Log.push(`${new Date().toUTCString()} [${pLogLevel}]: ${pLogText}`);\n\n\t\tif (typeof(pLogObject) == 'object')\n\t\t{\n\t\t\tthis.state.Log.push(JSON.stringify(pLogObject));\n\t\t}\n\t}\n\n\twriteOperationErrors(pLogText, pLogObject)\n\t{\n\t\tthis.state.Errors.push(`${pLogText}`);\n\n\t\tif (typeof(pLogObject) == 'object')\n\t\t{\n\t\t\tthis.state.Errors.push(JSON.stringify(pLogObject));\n\t\t}\n\t}\n\n\ttrace(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('TRACE', pLogText, pLogObject);\n\t\tthis.fable.log.trace(pLogText, pLogObject);\n\t}\n\n\tdebug(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('DEBUG', pLogText, pLogObject);\n\t\tthis.fable.log.debug(pLogText, pLogObject);\n\t}\n\n\tinfo(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('INFO', pLogText, pLogObject);\n\t\tthis.fable.log.info(pLogText, pLogObject);\n\t}\n\n\twarn(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('WARN', pLogText, pLogObject);\n\t\tthis.fable.log.warn(pLogText, pLogObject);\n\t}\n\n\terror(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('ERROR', pLogText, pLogObject);\n\t\tthis.writeOperationErrors(pLogText, pLogObject);\n\t\tthis.fable.log.error(pLogText, pLogObject);\n\t}\n\n\tfatal(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('FATAL', pLogText, pLogObject);\n\t\tthis.writeOperationErrors(pLogText, pLogObject);\n\t\tthis.fable.log.fatal(pLogText, pLogObject);\n\t}\n}\n\nmodule.exports = FableOperation;\n},{}],36:[function(require,module,exports){\nconst libFableServiceBase = require('./Fable-ServiceProviderBase.js');\n\nclass FableServiceTemplate extends libFableServiceBase\n{\n\t// Underscore and lodash have a behavior, _.template, which compiles a\n\t// string-based template with code snippets into simple executable pieces,\n\t// with the added twist of returning a precompiled function ready to go.\n\t//\n\t// NOTE: This does not implement underscore escape expressions\n\t// NOTE: This does not implement underscore magic browser variable assignment\n\t//\n\t// This is an implementation of that.\n\t// TODO: Make this use precedent, add configuration, add debugging.\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n        super(pFable, pOptions, pServiceHash);\n\n        this.serviceType = 'Template';\n\n\t\t// These are the exact regex's used in lodash/underscore\n\t\t// TODO: Switch this to precedent\n\t\tthis.Matchers = (\n\t\t\t{\n\t\t\t\tEvaluate: /<%([\\s\\S]+?)%>/g,\n\t\t\t\tInterpolate: /<%=([\\s\\S]+?)%>/g,\n\t\t\t\tEscaper: /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g,\n\t\t\t\tUnescaper: /\\\\(\\\\|'|r|n|t|u2028|u2029)/g,\n\t\t\t\t// This is how underscore does it, so we are keeping it for now.\n\t\t\t\tGuaranteedNonMatch: /.^/\n\t\t\t});\n\n\t\t// This is a helper for the escaper and unescaper functions.\n\t\t// Right now we are going to keep what underscore is doing, but, not forever.\n\t\tthis.templateEscapes = {\n\t\t\t'\\\\': '\\\\',\n\t\t\t\"'\": \"'\",\n\t\t\t'r': '\\r',\n\t\t\t'\\r': 'r',\n\t\t\t'n': '\\n',\n\t\t\t'\\n': 'n',\n\t\t\t't': '\\t',\n\t\t\t'\\t': 't',\n\t\t\t'u2028': '\\u2028',\n\t\t\t'\\u2028': 'u2028',\n\t\t\t'u2029': '\\u2029',\n\t\t\t'\\u2029': 'u2029'\n\t\t};\n\n\t\t// This is defined as such to underscore that it is a dynamic programming\n\t\t// function on this class.\n\t\tthis.renderFunction = false;\n        this.templateString = false;\n\t}\n\n\trenderTemplate(pData)\n\t{\n\t\treturn this.renderFunction(pData);\n\t}\n\n\ttemplateFunction(pData)\n\t{\n\t\tlet fRenderTemplateBound = this.renderTemplate.bind(this);\n\t\treturn fRenderTemplateBound;\n\t}\n\n\tbuildTemplateFunction(pTemplateText, pData)\n\t{\n\t\t// For now this is being kept in a weird form ... this is to mimic the old\n\t\t// underscore code until this is rewritten using precedent.\n\t\tthis.TemplateSource = \"__p+='\" + pTemplateText\n\t\t\t.replace(this.Matchers.Escaper,\n\t\t\t\t(pMatch)=>\n\t\t\t\t{\n\t\t\t\t\treturn `\\\\${this.templateEscapes[pMatch]}`;\n\t\t\t\t})\n\t\t\t.replace(this.Matchers.Interpolate || this.Matchers.GuaranteedNonMatch,\n\t\t\t\t(pMatch, pCode) =>\n\t\t\t\t{\n\t\t\t\t\treturn `'+\\n(${decodeURIComponent(pCode)})+\\n'`;\n\t\t\t\t})\n\t\t\t.replace(this.Matchers.Evaluate || this.Matchers.GuaranteedNonMatch,\n\t\t\t\t(pMatch, pCode) =>\n\t\t\t\t{\n\t\t\t\t\treturn `';\\n${decodeURIComponent(pCode)}\\n;__p+='`;\n\t\t\t\t}) + `';\\n`;\n\n\n\t\tthis.TemplateSource = `with(pTemplateDataObject||{}){\\n${this.TemplateSource}}\\n`;\n\t\tthis.TemplateSource = `var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};\\n${this.TemplateSource}return __p;\\n`;\n\n\t\tthis.renderFunction = new Function('pTemplateDataObject', this.TemplateSource);\n\n\t\tif (typeof(pData) != 'undefined')\n\t\t{\n\t\t\treturn this.renderFunction(pData);\n\t\t}\n\n\t\t// Provide the compiled function source as a convenience for build time\n\t\t// precompilation.\n\t\tthis.TemplateSourceCompiled = 'function(obj){\\n' + this.TemplateSource + '}';\n\n\t\treturn this.templateFunction();\n\t}\n}\n\nmodule.exports = FableServiceTemplate;\n},{\"./Fable-ServiceProviderBase.js\":38}],37:[function(require,module,exports){\n/**\n* Fable Application Services Management\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\nconst libFableServiceBase = require('./Fable-ServiceProviderBase.js');\n\nclass FableService\n{\n\tconstructor(pFable)\n\t{\n\t\tthis.fable = pFable;\n\n\t\tthis.serviceTypes = [];\n\n\t\t// A map of instantiated services\n\t\tthis.services = {};\n\n\t\t// A map of the default instantiated service by type\n\t\tthis.defaultServices = {};\n\n\t\t// A map of class constructors for services\n\t\tthis.serviceClasses = {};\n\t}\n\n\taddServiceType(pServiceType, pServiceClass)\n\t{\n\t\t// Add the type to the list of types\n\t\tthis.serviceTypes.push(pServiceType);\n\n\t\t// Add the container for instantiated services to go in\n\t\tthis.services[pServiceType] = {};\n\n\t\tif ((typeof(pServiceClass) == 'function') && (pServiceClass.prototype instanceof libFableServiceBase))\n\t\t{\n\t\t\t// Add the class to the list of classes\n\t\t\tthis.serviceClasses[pServiceType] = pServiceClass;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Add the base class to the list of classes\n\t\t\tthis.serviceClasses[pServiceType] = libFableServiceBase;\n\t\t}\n\t}\n\n\tinstantiateServiceProvider(pServiceType, pOptions, pCustomServiceHash)\n\t{\n\t\t// Instantiate the service\n\t\tlet tmpService = this.instantiateServiceProviderWithoutRegistration(pServiceType, pOptions, pCustomServiceHash);\n\n\t\t// Add the service to the service map\n\t\tthis.services[pServiceType][tmpService.Hash] = tmpService;\n\n\t\t// If this is the first service of this type, make it the default\n\t\tif (!this.defaultServices.hasOwnProperty(pServiceType))\n\t\t{\n\t\t\tthis.defaultServices[pServiceType] = tmpService;\n\t\t}\n\n\t\treturn tmpService;\n\t}\n\n\t// Create a service provider but don't register it to live forever in fable.services\n\tinstantiateServiceProviderWithoutRegistration(pServiceType, pOptions, pCustomServiceHash)\n\t{\n\t\t// Instantiate the service\n\t\tlet tmpService = new this.serviceClasses[pServiceType](this.fable, pOptions, pCustomServiceHash);\n\t\treturn tmpService;\n\t}\n\n\tsetDefaultServiceInstantiation(pServiceType, pServiceHash)\n\t{\n\t\tif (this.services[pServiceType].hasOwnProperty(pServiceHash))\n\t\t{\n\t\t\tthis.defaultServices[pServiceType] = this.services[pServiceType][pServiceHash];\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n}\n\nmodule.exports = FableService;\n\nmodule.exports.ServiceProviderBase = libFableServiceBase;\n},{\"./Fable-ServiceProviderBase.js\":38}],38:[function(require,module,exports){\n/**\n* Fable Service Base\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\nclass FableServiceProviderBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tthis.fable = pFable;\n\n\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions : {};\n\n        this.serviceType = 'Unknown';\n\n        this.UUID = pFable.getUUID();\n\n        this.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash : `${this.UUID}`;\n\t}\n}\n\nmodule.exports = FableServiceProviderBase;\n\n},{}],39:[function(require,module,exports){\n// TODO: These are still pretty big -- consider the smaller polyfills\nconst libAsyncWaterfall = require('async.waterfall');\nconst libAsyncEachLimit = require('async.eachlimit');\n\nclass FableUtility\n{\n\tconstructor(pFable)\n\t{\n\t\tthis.fable = pFable;\n\n\t\tthis.templates = {};\n\n\t\t// These two functions are used extensively throughout\n\t\tthis.waterfall = libAsyncWaterfall;\n\t\tthis.eachLimit = libAsyncEachLimit;\n\t}\n\n\t// Underscore and lodash have a behavior, _.extend, which merges objects.\n\t// Now that es6 gives us this, use the native thingy.\n\textend(pDestinationObject, ...pSourceObjects)\n\t{\n\t\treturn Object.assign(pDestinationObject, ...pSourceObjects);\n\t}\n\n\t// Underscore and lodash have a behavior, _.template, which compiles a\n\t// string-based template with code snippets into simple executable pieces,\n\t// with the added twist of returning a precompiled function ready to go.\n\ttemplate(pTemplateText, pData)\n\t{\n\t\tlet tmpTemplate = this.fable.serviceManager.instantiateServiceProviderWithoutRegistration('Template');\n\n\t\treturn tmpTemplate.buildTemplateFunction(pTemplateText, pData);\n\t}\n\n\t// Build a template function from a template hash, and, register it with the service provider\n\tbuildHashedTemplate(pTemplateHash, pTemplateText, pData)\n\t{\n\t\tlet tmpTemplate = this.fable.serviceManager.instantiateServiceProvider('Template', {}, pTemplateHash);\n\n\t\tthis.templates[pTemplateHash] = tmpTemplate.buildTemplateFunction(pTemplateText, pData);\n\n\t\treturn this.templates[pTemplateHash];\n\t}\n\n\t// This is a safe, modern version of chunk from underscore\n\t// Algorithm pulled from a mix of these two polyfills:\n\t// https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_chunk\n\t// https://youmightnotneed.com/lodash\n\t// This implementation was most tolerant in browsers.  Uglify can fix the rest.\n\tchunk (pInput, pChunkSize, pChunkCache)\n\t{\n\t\tlet tmpInputArray = [...pInput];\n\t\t// Note lodash defaults to 1, underscore defaults to 0\n\t\tlet tmpChunkSize = (typeof(pChunkSize) == 'number') ? pChunkSize : 0;\n\t\tlet tmpChunkCache = (typeof(pChunkCache) != 'undefined') ? pChunkCache : [];\n\n\t\tif (tmpChunkSize <= 0)\n\t\t{\n\t\t\treturn tmpChunkCache;\n\t\t}\n\n\t\twhile (tmpInputArray.length)\n\t\t{\n\t\t\ttmpChunkCache.push(tmpInputArray.splice(0, tmpChunkSize));\n\t\t}\n\n\t\treturn tmpChunkCache;\n\t}\n}\n\nmodule.exports = FableUtility;\n},{\"async.eachlimit\":1,\"async.waterfall\":15}],40:[function(require,module,exports){\n/**\n* Fable Application Services Support Library\n* @license MIT\n* @author <steven@velozo.com>\n*/\nconst libFableSettings = require('fable-settings');\nconst libFableUUID = require('fable-uuid');\nconst libFableLog = require('fable-log');\n\nconst libFableUtility = require('./Fable-Utility.js');\nconst libFableServiceManager = require('./Fable-ServiceManager.js');\n\nconst libFableServiceTemplate = require('./Fable-Service-Template.js');\n\nconst libFableOperation = require('./Fable-Operation.js');\n\nclass Fable\n{\n\tconstructor(pSettings)\n\t{\n\t\tlet tmpSettings = new libFableSettings(pSettings);\n\n\t\tthis.settingsManager = tmpSettings;\n\n\t\t// Instantiate the UUID generator\n\t\tthis.libUUID = new libFableUUID(this.settingsManager.settings);\n\n\t\tthis.log = new libFableLog(this.settingsManager.settings);\n\t\tthis.log.initialize();\n\n\t\t// Built-in utility belt functions\n\t\tthis.Utility = new libFableUtility(this);\n\n\t\t// Built-in dependencies\n\t\tthis.Dependencies = (\n\t\t\t{\n\t\t\t\tprecedent: libFableSettings.precedent\n\t\t\t});\n\n\t\t// Location for Operation state\n\t\tthis.Operations = {};\n\n\t\tthis.serviceManager = new libFableServiceManager(this);\n\n\t\tthis.serviceManager.addServiceType('Template', libFableServiceTemplate);\n\n\t\tthis.services = this.serviceManager.services;\n\t\tthis.defaultServices = this.serviceManager.defaultServices;\n\t}\n\n\tget settings()\n\t{\n\t\treturn this.settingsManager.settings;\n\t}\n\n\tget fable()\n\t{\n\t\treturn this;\n\t}\n\n\tgetUUID()\n\t{\n\t\treturn this.libUUID.getUUID();\n\t}\n\n\tcreateOperation(pOperationName, pOperationHash)\n\t{\n\t\tlet tmpOperation = new libFableOperation(this, pOperationName, pOperationHash);\n\n\t\tif (this.Operations.hasOwnProperty(tmpOperation.Hash))\n\t\t{\n\t\t\t// Uh Oh ...... Operation Hash Collision!\n\t\t\t// TODO: What to do?!\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.Operations[tmpOperation.Hash] = tmpOperation;\n\t\t}\n\n\t\treturn tmpOperation;\n\t}\n\n\tgetOperation(pOperationHash)\n\t{\n\t\tif (!this.Operations.hasOwnProperty(pOperationHash))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.Operations[pOperationHash];\n\t\t}\n\t}\n}\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new Fable(pSettings);\n}\n\nmodule.exports = Fable;\nmodule.exports.new = autoConstruct;\n\nmodule.exports.LogProviderBase = libFableLog.LogProviderBase;\nmodule.exports.ServiceProviderBase = libFableServiceManager.ServiceProviderBase;\n\nmodule.exports.precedent = libFableSettings.precedent;\n},{\"./Fable-Operation.js\":35,\"./Fable-Service-Template.js\":36,\"./Fable-ServiceManager.js\":37,\"./Fable-Utility.js\":39,\"fable-log\":22,\"fable-settings\":25,\"fable-uuid\":27}]},{},[34])(34)\n});\n\n","'use strict';\n\nmodule.exports = function(tasks) {\n    function makeCallback(index) {\n        function fn() {\n            if (tasks.length) {\n                tasks[index].apply(null, arguments);\n            }\n            return fn.next();\n        }\n        fn.next = function() {\n            return (index < tasks.length - 1) ? makeCallback(index + 1) : null;\n        };\n        return fn;\n    }\n    return makeCallback(0);\n};\n","var once = require('async.util.once');\nvar noop = require('async.util.noop');\nvar onlyOnce = require('async.util.onlyonce');\nvar keyIterator = require('async.util.keyiterator');\n\nmodule.exports = function eachOfLimit(limit) {\n    return function(obj, iterator, cb) {\n        cb = once(cb || noop);\n        obj = obj || [];\n        var nextKey = keyIterator(obj);\n        if (limit <= 0) {\n            return cb(null);\n        }\n        var done = false;\n        var running = 0;\n        var errored = false;\n\n        (function replenish() {\n            if (done && running <= 0) {\n                return cb(null);\n            }\n\n            while (running < limit && !errored) {\n                var key = nextKey();\n                if (key === null) {\n                    done = true;\n                    if (running <= 0) {\n                        cb(null);\n                    }\n                    return;\n                }\n                running += 1;\n                iterator(obj[key], key, onlyOnce(function(err) {\n                    running -= 1;\n                    if (err) {\n                        cb(err);\n                        errored = true;\n                    } else {\n                        replenish();\n                    }\n                }));\n            }\n        })();\n    };\n};\n","'use strict';\nvar setImmediate = require('async.util.setimmediate');\nvar restParam = require('async.util.restparam');\n\nmodule.exports = function(fn) {\n    return restParam(function(args) {\n        var callback = args.pop();\n        args.push(function() {\n            var innerArgs = arguments;\n            if (sync) {\n                setImmediate(function() {\n                    callback.apply(null, innerArgs);\n                });\n            } else {\n                callback.apply(null, innerArgs);\n            }\n        });\n        var sync = true;\n        fn.apply(this, args);\n        sync = false;\n    });\n};\n","'use strict';\n\nmodule.exports = Array.isArray || function isArray(obj) {\n    return Object.prototype.toString.call(obj) === '[object Array]';\n};\n","'use strict';\n\nvar isArray = require('async.util.isarray');\n\nmodule.exports = function isArrayLike(arr) {\n    return isArray(arr) || (\n        // has a positive integer length property\n        typeof arr.length === 'number' &&\n        arr.length >= 0 &&\n        arr.length % 1 === 0\n    );\n};\n","'use strict';\n\nvar _keys = require('async.util.keys');\nvar isArrayLike = require('async.util.isarraylike');\n\nmodule.exports = function keyIterator(coll) {\n    var i = -1;\n    var len;\n    var keys;\n    if (isArrayLike(coll)) {\n        len = coll.length;\n        return function next() {\n            i++;\n            return i < len ? i : null;\n        };\n    } else {\n        keys = _keys(coll);\n        len = keys.length;\n        return function next() {\n            i++;\n            return i < len ? keys[i] : null;\n        };\n    }\n};\n","'use strict';\n\nmodule.exports = Object.keys || function keys(obj) {\n    var _keys = [];\n    for (var k in obj) {\n        if (obj.hasOwnProperty(k)) {\n            _keys.push(k);\n        }\n    }\n    return _keys;\n};\n","'use strict';\n\nmodule.exports = function noop () {};\n","'use strict';\n\nmodule.exports = function once(fn) {\n    return function() {\n        if (fn === null) return;\n        fn.apply(this, arguments);\n        fn = null;\n    };\n};\n","'use strict';\n\nmodule.exports = function only_once(fn) {\n    return function() {\n        if (fn === null) throw new Error('Callback was already called.');\n        fn.apply(this, arguments);\n        fn = null;\n    };\n};\n","'use strict';\nmodule.exports = function restParam(func, startIndex) {\n    startIndex = startIndex == null ? func.length - 1 : +startIndex;\n    return function() {\n        var length = Math.max(arguments.length - startIndex, 0);\n        var rest = new Array(length);\n        for (var index = 0; index < length; index++) {\n            rest[index] = arguments[index + startIndex];\n        }\n        switch (startIndex) {\n            case 0:\n                return func.call(this, rest);\n            case 1:\n                return func.call(this, arguments[0], rest);\n        }\n    };\n};\n","'use strict';\n\nvar _setImmediate = typeof setImmediate === 'function' && setImmediate;\nvar fallback = function(fn) {\n    setTimeout(fn, 0);\n};\n\nmodule.exports = function setImmediate(fn) {\n    // not a direct alias for IE10 compatibility\n    return (_setImmediate || fallback)(fn);\n};\n","'use strict';\n\nmodule.exports = function withoutIndex(iterator) {\n    return function(value, index, callback) {\n        return iterator(value, callback);\n    };\n};\n","'use strict';\n\nvar once = require('async.util.once');\nvar noop = require('async.util.noop');\nvar isArray = require('async.util.isarray');\nvar restParam = require('async.util.restparam');\nvar ensureAsync = require('async.util.ensureasync');\nvar iterator = require('async.iterator');\n\nmodule.exports = function(tasks, cb) {\n    cb = once(cb || noop);\n    if (!isArray(tasks)) return cb(new Error('First argument to waterfall must be an array of functions'));\n    if (!tasks.length) return cb();\n\n    function wrapIterator(iterator) {\n        return restParam(function(err, args) {\n            if (err) {\n                cb.apply(null, [err].concat(args));\n            } else {\n                var next = iterator.next();\n                if (next) {\n                    args.push(wrapIterator(next));\n                } else {\n                    args.push(cb);\n                }\n                ensureAsync(iterator).apply(null, args);\n            }\n        });\n    }\n    wrapIterator(iterator(tasks))();\n};\n","/**\n* Base Logger Class\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\nclass BaseLogger\n{\n\tconstructor(pLogStreamSettings, pFableLog)\n\t{\n\t\t// This should not possibly be able to be instantiated without a settings object\n\t\tthis._Settings = (typeof(pLogStreamSettings) == 'object') ? pLogStreamSettings : {};\n\n\t\t// The base logger does nothing but associate a UUID with itself\n\t\t// We added this as the mechanism for tracking loggers to allow multiple simultaneous streams\n\t\t// to the same provider.\n\t\tthis.loggerUUID = this.generateInsecureUUID();\n\n\t\t// Eventually we can use this array to ompute which levels the provider allows.\n\t\t// For now it's just used to precompute some string concatenations.\n\t\tthis.levels = (\n\t\t\t[\n\t\t\t\t\"trace\",\n\t\t\t\t\"debug\",\n\t\t\t\t\"info\",\n\t\t\t\t\"warn\",\n\t\t\t\t\"error\",\n\t\t\t\t\"fatal\"\n\t\t\t]);\n\t}\n\n\t// This is meant to generate programmatically insecure UUIDs to identify loggers\n\tgenerateInsecureUUID()\n\t{\n\t\tlet tmpDate = new Date().getTime();\n\t\tlet tmpUUID = 'LOGSTREAM-xxxxxx-yxxxxx'.replace(/[xy]/g,\n\t\t\t\t(pCharacter) =>\n\t\t\t\t{\n\t\t\t\t\t// Funny algorithm from w3resource that is twister-ish without the deep math and security\n\t\t\t\t\t// ..but good enough for unique log stream identifiers\n\t\t\t\t\tlet tmpRandomData = (tmpDate + Math.random()*16)%16 | 0;\n\t\t\t\t\ttmpDate = Math.floor(tmpDate/16);\n\n\t\t\t\t\treturn (pCharacter =='x' ? tmpRandomData : (tmpRandomData&0x3|0x8)).toString(16);\n\t\t\t\t});\n\t\treturn tmpUUID;\n\t}\n\n\tinitialize()\n\t{\n\t\t// No operation.\n\t}\n\n\ttrace(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"trace\", pLogText, pLogObject);\n\t}\n\n\tdebug(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"debug\", pLogText, pLogObject);\n\t}\n\n\tinfo(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"info\", pLogText, pLogObject);\n\t}\n\n\twarn(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"warn\", pLogText, pLogObject);\n\t}\n\n\terror(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"error\", pLogText, pLogObject);\n\t}\n\n\tfatal(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"fatal\", pLogText, pLogObject);\n\t}\n\n\twrite(pLogLevel, pLogText, pLogObject)\n\t{\n\t\t// The base logger does nothing.\n\t\treturn true;\n\t}\n}\n\nmodule.exports = BaseLogger;\n","/**\n* Default Logger Provider Function\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\n// Return the providers that are available without extensions loaded\ngetDefaultProviders = () =>\n{\n\tlet tmpDefaultProviders = {};\n\n\ttmpDefaultProviders.console = require('./Fable-Log-Logger-Console.js');\n\n\ttmpDefaultProviders.default = tmpDefaultProviders.console;\n\n\treturn tmpDefaultProviders;\n}\n\nmodule.exports = getDefaultProviders();","module.exports=[\n    {\n        \"loggertype\": \"console\",\n        \"streamtype\": \"console\",\n        \"level\": \"trace\"\n    }\n]","let libBaseLogger = require('./Fable-Log-BaseLogger.js');\n\nclass ConsoleLogger extends libBaseLogger\n{\n\tconstructor(pLogStreamSettings, pFableLog)\n\t{\n\t\tsuper(pLogStreamSettings);\n\n\t\tthis._ShowTimeStamps = this._Settings.hasOwnProperty('showtimestamps') ? (this._Settings.showtimestamps == true) : true;\n\t\tthis._FormattedTimeStamps = this._Settings.hasOwnProperty('formattedtimestamps') ? (this._Settings.formattedtimestamps == true) : true;\n\n\t\tthis._ContextMessage = this._Settings.hasOwnProperty('Context') ? `(${this._Settings.Context})` : \n\t\t\t\t\t\t\t\tpFableLog._Settings.hasOwnProperty('Product') ? `(${pFableLog._Settings.Product})` :\n\t\t\t\t\t\t\t\t'Unnamed_Log_Context';\n\n\t\t// Allow the user to decide what gets output to the console\n\t\tthis._OutputLogLinesToConsole = this._Settings.hasOwnProperty('outputloglinestoconsole') ? this._Settings.outputloglinestoconsole : true;\n\t\tthis._OutputObjectsToConsole = this._Settings.hasOwnProperty('outputobjectstoconsole') ? this._Settings.outputobjectstoconsole : true;\n\n\t\t// Precompute the prefix for each level\n\t\tthis.prefixCache = {};\n\t\tfor (let i = 0; i <= this.levels.length; i++)\n\t\t{\n\t\t\tthis.prefixCache[this.levels[i]] = `[${this.levels[i]}] ${this._ContextMessage}: `;\n\n\t\t\tif (this._ShowTimeStamps)\n\t\t\t{\n\t\t\t\t// If there is a timestamp we need a to prepend space before the prefixcache string, since the timestamp comes first\n\t\t\t\tthis.prefixCache[this.levels[i]] = ' '+this.prefixCache[this.levels[i]];\n\t\t\t}\n\t\t}\n\t}\n\n\twrite(pLevel, pLogText, pObject)\n\t{\n\t\tlet tmpTimeStamp = '';\n\t\tif (this._ShowTimeStamps && this._FormattedTimeStamps)\n\t\t{\n\t\t\ttmpTimeStamp = (new Date()).toISOString();\n\t\t}\n\t\telse if (this._ShowTimeStamps)\n\t\t{\n\t\t\ttmpTimeStamp = +new Date();\n\t\t}\n\n\t\tlet tmpLogLine = `${tmpTimeStamp}${this.prefixCache[pLevel]}${pLogText}`;\n\n\t\tif (this._OutputLogLinesToConsole)\n\t\t{\n\t\t\tconsole.log(tmpLogLine);\n\t\t}\n\n\t\t// Write out the object on a separate line if it is passed in\n\t\tif (this._OutputObjectsToConsole && (typeof(pObject) !== 'undefined'))\n\t\t{\n\t\t\tconsole.log(JSON.stringify(pObject, null, 2));\n\t\t}\n\n\t\t// Provide an easy way to be overridden and be consistent\n\t\treturn tmpLogLine;\n\t}\n}\n\nmodule.exports = ConsoleLogger;","const libConsoleLog = require('./Fable-Log-Logger-Console.js');\nconst libFS = require('fs');\nconst libPath = require('path');\n\nclass SimpleFlatFileLogger extends libConsoleLog\n{\n\tconstructor(pLogStreamSettings, pFableLog)\n\t{\n\t\tsuper(pLogStreamSettings, pFableLog);\n\n\t\t// If a path isn't provided for the logfile, it tries to use the ProductName or Context\n\t\tthis.logFileRawPath = (this._Settings.hasOwnProperty('path')) ? this._Settings.path : `./${this._ContextMessage}.log`;\n\t\tthis.logFilePath = libPath.normalize(this.logFileRawPath);\n\n\t\tthis.logFileStreamOptions = (this._Settings.hasOwnProperty('fileStreamoptions')) ? this._Settings.fileStreamOptions : (\n\t\t\t{\n\t\t\t\t\"flags\": \"a\",\n\t\t\t\t\"encoding\": \"utf8\"\n\t\t\t})\n\n\t\tthis.fileWriter = libFS.createWriteStream(this.logFilePath, this.logFileStreamOptions);\n\n\t\tthis.activelyWriting = false;\n\n\t\tthis.logLineStrings = [];\n\t\tthis.logObjectStrings = [];\n\n\t\tthis.defaultWriteCompleteCallback = ()=>{};\n\t\tthis.defaultBufferFlushCallback = ()=>{};\n\t}\n\n\tcloseWriter(fCloseComplete)\n\t{\n\t\tlet tmpCloseComplete = (typeof(fCloseComplete) == 'function') ? fCloseComplete : ()=>{};\n\t\tif (this.fileWriter)\n\t\t{\n\t\t\tthis.fileWriter.end('\\n');\n\t\t\treturn this.fileWriter.once('finish', tmpCloseComplete.bind(this));\n\t\t}\n\t};\n\n\tcompleteBufferFlushToLogFile(fFlushComplete)\n\t{\n\t\tthis.activelyWriting = false;\n\t\tlet tmpFlushComplete = (typeof(fFlushComplete) == 'function') ? fFlushComplete : this.defaultBufferFlushCallback;\n\n\t\tif (this.logLineStrings.length > 0)\n\t\t{\n\t\t\tthis.flushBufferToLogFile(tmpFlushComplete);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn tmpFlushComplete();\n\t\t}\n\t}\n\n\tflushBufferToLogFile(fFlushComplete)\n\t{\n\t\tif (!this.activelyWriting)\n\t\t{\n\t\t\t// Only want to be writing one thing at a time....\n\t\t\tthis.activelyWriting = true;\n\n\t\t\tlet tmpFlushComplete = (typeof(fFlushComplete) == 'function') ? fFlushComplete : this.defaultBufferFlushCallback;\n\n\t\t\t// Get the current buffer arrays.  These should always have matching number of elements.\n\t\t\tlet tmpLineStrings = this.logLineStrings;\n\t\t\tlet tmpObjectStrings = this.logObjectStrings;\n\n\t\t\t// Reset these to be filled while we process this queue...\n\t\t\tthis.logLineStrings = [];\n\t\t\tthis.logObjectStrings = [];\n\n\t\t\t// This is where we will put each line before writing it to the file...\n\t\t\tlet tmpConstructedBufferOutputString = '';\n\n\t\t\tfor (let i = 0; i < tmpLineStrings.length; i++)\n\t\t\t{\n\t\t\t\t// TODO: Windows Newline?   ....... yo no se!\n\t\t\t\ttmpConstructedBufferOutputString += `${tmpLineStrings[i]}\\n`;\n\t\t\t\tif (tmpObjectStrings[i] !== false)\n\t\t\t\t{\n\t\t\t\t\ttmpConstructedBufferOutputString += `${tmpObjectStrings[i]}\\n`;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!this.fileWriter.write(tmpConstructedBufferOutputString, 'utf8'))\n\t\t\t{\n\t\t\t\t// If the streamwriter returns false, we need to wait for it to drain.\n\t\t\t\tthis.fileWriter.once('drain', this.completeBufferFlushToLogFile.bind(this, tmpFlushComplete));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn this.completeBufferFlushToLogFile(tmpFlushComplete);\n\t\t\t}\n\t\t}\n\t}\n\n\twrite(pLevel, pLogText, pObject)\n\t{\n\t\tlet tmpLogLine = super.write(pLevel, pLogText, pObject);\n\n\t\t// Use a very simple array as the write buffer\n\t\tthis.logLineStrings.push(tmpLogLine);\n\n\t\t// Write out the object on a separate line if it is passed in\n\t\tif (typeof(pObject) !== 'undefined')\n\t\t{\n\t\t\tthis.logObjectStrings.push(JSON.stringify(pObject, null, 4));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logObjectStrings.push(false);\n\t\t}\n\n\t\tthis.flushBufferToLogFile();\n\t}\n}\n\nmodule.exports = SimpleFlatFileLogger;","/**\n* Fable Logging Add-on\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable Logger\n*/\n\n/**\n* Fable Solution Log Wrapper Main Class\n*\n* @class FableLog\n* @constructor\n*/\nclass FableLog\n{\n\tconstructor(pFableSettings, pFable)\n\t{\n\t\tlet tmpSettings = (typeof(pFableSettings) === 'object') ? pFableSettings : {}\n\t\tthis._Settings = tmpSettings;\n\n\t\tthis._Providers = require('./Fable-Log-DefaultProviders-Node.js');\n\n\t\tthis._StreamDefinitions = (tmpSettings.hasOwnProperty('LogStreams')) ? tmpSettings.LogStreams : require('./Fable-Log-DefaultStreams.json');\n\n\t\tthis.logStreams = [];\n\n\t\t// This object gets decorated for one-time instantiated providers that\n\t\t//  have multiple outputs, such as bunyan.\n\t\tthis.logProviders = {};\n\n\t\t// A hash list of the GUIDs for each log stream, so they can't be added to the set more than one time\n\t\tthis.activeLogStreams = {};\n\n\t\tthis.logStreamsTrace = [];\n\t\tthis.logStreamsDebug = [];\n\t\tthis.logStreamsInfo = [];\n\t\tthis.logStreamsWarn = [];\n\t\tthis.logStreamsError = [];\n\t\tthis.logStreamsFatal = [];\n\n\t\tthis.datumDecorator = (pDatum) => pDatum;\n\n\t\tthis.uuid = (typeof(tmpSettings.Product) === 'string') ? tmpSettings.Product : 'Default';\n\t}\n\n\taddLogger(pLogger, pLevel)\n\t{\n\t\t// Bail out if we've already created one.\n\t\tif (this.activeLogStreams.hasOwnProperty(pLogger.loggerUUID))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// Add it to the streams and to the mutex\n\t\tthis.logStreams.push(pLogger);\n\t\tthis.activeLogStreams[pLogger.loggerUUID] = true;\n\n\t\t// Make sure a kosher level was passed in\n\t\tswitch (pLevel)\n\t\t{\n\t\t\tcase 'trace':\n\t\t\t\tthis.logStreamsTrace.push(pLogger);\n\t\t\tcase 'debug':\n\t\t\t\tthis.logStreamsDebug.push(pLogger);\n\t\t\tcase 'info':\n\t\t\t\tthis.logStreamsInfo.push(pLogger);\n\t\t\tcase 'warn':\n\t\t\t\tthis.logStreamsWarn.push(pLogger);\n\t\t\tcase 'error':\n\t\t\t\tthis.logStreamsError.push(pLogger);\n\t\t\tcase 'fatal':\n\t\t\t\tthis.logStreamsFatal.push(pLogger);\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tsetDatumDecorator(fDatumDecorator)\n\t{\n\t\tif (typeof(fDatumDecorator) === 'function')\n\t\t{\n\t\t\tthis.datumDecorator = fDatumDecorator;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.datumDecorator = (pDatum) => pDatum;\n\t\t}\n\t}\n\n\ttrace(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsTrace.length; i++)\n\t\t{\n\t\t\tthis.logStreamsTrace[i].trace(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tdebug(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsDebug.length; i++)\n\t\t{\n\t\t\tthis.logStreamsDebug[i].debug(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tinfo(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsInfo.length; i++)\n\t\t{\n\t\t\tthis.logStreamsInfo[i].info(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\twarn(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsWarn.length; i++)\n\t\t{\n\t\t\tthis.logStreamsWarn[i].warn(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\terror(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsError.length; i++)\n\t\t{\n\t\t\tthis.logStreamsError[i].error(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tfatal(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsFatal.length; i++)\n\t\t{\n\t\t\tthis.logStreamsFatal[i].fatal(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tinitialize()\n\t{\n\t\t// \"initialize\" each logger as defined in the logging parameters\n\t\tfor (let i = 0; i < this._StreamDefinitions.length; i++)\n\t\t{\n\t\t\tlet tmpStreamDefinition = Object.assign({loggertype:'default',streamtype:'console',level:'info'},this._StreamDefinitions[i]);\n\n\t\t\tif (!this._Providers.hasOwnProperty(tmpStreamDefinition.loggertype))\n\t\t\t{\n\t\t\t\tconsole.log(`Error initializing log stream: bad loggertype in stream definition ${JSON.stringify(tmpStreamDefinition)}`);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.addLogger(new this._Providers[tmpStreamDefinition.loggertype](tmpStreamDefinition, this), tmpStreamDefinition.level);\n\t\t\t}\n\t\t}\n\n\t\t// Now initialize each one.\n\t\tfor (let i = 0; i < this.logStreams.length; i++)\n\t\t{\n\t\t\tthis.logStreams[i].initialize();\n\t\t}\n\t}\n\n\tlogTime(pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time';\n\t\tlet tmpTime = new Date();\n\t\tthis.info(`${tmpMessage} ${tmpTime} (epoch ${+tmpTime})`, pDatum);\n\t}\n\n\t// Get a timestamp\n\tgetTimeStamp()\n\t{\n\t\treturn +new Date();\n\t}\n\n\tgetTimeDelta(pTimeStamp)\n\t{\n\t\tlet tmpEndTime = +new Date();\n\t\treturn tmpEndTime-pTimeStamp;\n\t}\n\n\t// Log the delta between a timestamp, and now with a message\n\tlogTimeDelta(pTimeDelta, pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time Measurement';\n\t\tlet tmpDatum = (typeof(pDatum) === 'object') ? pDatum : {};\n\n\t\tlet tmpEndTime = +new Date();\n\n\t\tthis.info(`${tmpMessage} logged at (epoch ${+tmpEndTime}) took (${pTimeDelta}ms)`, pDatum);\n\t}\n\n\tlogTimeDeltaHuman(pTimeDelta, pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time Measurement';\n\n\t\tlet tmpEndTime = +new Date();\n\n\t\tlet tmpMs = parseInt(pTimeDelta%1000);\n\t\tlet tmpSeconds = parseInt((pTimeDelta/1000)%60);\n\t\tlet tmpMinutes = parseInt((pTimeDelta/(1000*60))%60);\n\t\tlet tmpHours = parseInt(pTimeDelta/(1000*60*60));\n\n\t\ttmpMs = (tmpMs < 10) ? \"00\"+tmpMs : (tmpMs < 100) ? \"0\"+tmpMs : tmpMs;\n\t\ttmpSeconds = (tmpSeconds < 10) ? \"0\"+tmpSeconds : tmpSeconds;\n\t\ttmpMinutes = (tmpMinutes < 10) ? \"0\"+tmpMinutes : tmpMinutes;\n\t\ttmpHours = (tmpHours < 10) ? \"0\"+tmpHours : tmpHours;\n\n\t\tthis.info(`${tmpMessage} logged at (epoch ${+tmpEndTime}) took (${pTimeDelta}ms) or (${tmpHours}:${tmpMinutes}:${tmpSeconds}.${tmpMs})`, pDatum);\n\t}\n\n\tlogTimeDeltaRelative(pStartTime, pMessage, pDatum)\n\t{\n\t\tthis.logTimeDelta(this.getTimeDelta(pStartTime), pMessage, pDatum);\n\t}\n\n\tlogTimeDeltaRelativeHuman(pStartTime, pMessage, pDatum)\n\t{\n\t\tthis.logTimeDeltaHuman(this.getTimeDelta(pStartTime), pMessage, pDatum);\n\t}\n}\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new FableLog(pSettings);\n}\n\n\nmodule.exports = FableLog;\nmodule.exports.new = autoConstruct;\nmodule.exports.LogProviderBase = require('./Fable-Log-BaseLogger.js');\nmodule.exports.LogProviderConsole = require('./Fable-Log-Logger-Console.js');\nmodule.exports.LogProviderConsole = require('./Fable-Log-Logger-SimpleFlatFile.js');\n","module.exports={\n\t\"Product\": \"ApplicationNameHere\",\n\t\"ProductVersion\": \"0.0.0\",\n\n\t\"ConfigFile\": false,\n\n\t\"LogStreams\":\n\t[\n\t\t{\n\t\t\t\"level\": \"trace\"\n\t\t}\n\t]\n}\n","/**\n* Fable Settings Template Processor\n*\n* This class allows environment variables to come in via templated expressions, and defaults to be set.\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable Settings\n*/\n\nclass FableSettingsTemplateProcessor\n{\n\tconstructor(pDependencies)\n\t{\n        // Use a no-dependencies templating engine to parse out environment variables\n\t\tthis.templateProcessor = new pDependencies.precedent();\n\n        // TODO: Make the environment variable wrap expression demarcation characters configurable?\n\t\tthis.templateProcessor.addPattern('${', '}',\n\t\t\t(pTemplateValue)=>\n\t\t\t{\n\t\t\t\tlet tmpTemplateValue = pTemplateValue.trim();\n\n\t\t\t\tlet tmpSeparatorIndex = tmpTemplateValue.indexOf('|');\n\n\t\t\t\t// If there is no pipe, the default value will end up being whatever the variable name is.\n\t\t\t\tlet tmpDefaultValue = tmpTemplateValue.substring(tmpSeparatorIndex+1);\n\n\t\t\t\tlet tmpEnvironmentVariableName = (tmpSeparatorIndex > -1) ? tmpTemplateValue.substring(0, tmpSeparatorIndex) : tmpTemplateValue;\n\n\t\t\t\tif (process.env.hasOwnProperty(tmpEnvironmentVariableName))\n\t\t\t\t{\n\t\t\t\t\treturn process.env[tmpEnvironmentVariableName];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn tmpDefaultValue;\n\t\t\t\t}\n\t\t\t});\n    }\n\n    parseSetting(pString)\n    {\n        return this.templateProcessor.parseString(pString);\n    }\n}\n\nmodule.exports = FableSettingsTemplateProcessor;","/**\n* Fable Settings Add-on\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable Settings\n*/\n\nconst libPrecedent = require('precedent');\nconst libFableSettingsTemplateProcessor = require('./Fable-Settings-TemplateProcessor.js');\n\nclass FableSettings\n{\n\tconstructor(pFableSettings)\n\t{\n\t\t// Expose the dependencies for downstream re-use\n\t\tthis.dependencies = (\n\t\t\t{\n\t\t\t\tprecedent: libPrecedent\n\t\t\t});\n\n\t\t// Initialize the settings value template processor\n\t\tthis.settingsTemplateProcessor = new libFableSettingsTemplateProcessor(this.dependencies);\n\n\t\t// set straight away so anything that uses it respects the initial setting\n\t\tthis._configureEnvTemplating(pFableSettings);\n\n\t\tthis.default = this.buildDefaultSettings();\n\n\t\t// Construct a new settings object\n\t\tlet tmpSettings = this.merge(pFableSettings, this.buildDefaultSettings());\n\n\t\t// The base settings object (what they were on initialization, before other actors have altered them)\n\t\tthis.base = JSON.parse(JSON.stringify(tmpSettings));\n\n\t\tif (tmpSettings.DefaultConfigFile)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// If there is a DEFAULT configuration file, try to load and merge it.\n\t\t\t\ttmpSettings = this.merge(require(tmpSettings.DefaultConfigFile), tmpSettings);\n\t\t\t}\n\t\t\tcatch (pException)\n\t\t\t{\n\t\t\t\t// Why this?  Often for an app we want settings to work out of the box, but\n\t\t\t\t// would potentially want to have a config file for complex settings.\n\t\t\t\tconsole.log('Fable-Settings Warning: Default configuration file specified but there was a problem loading it.  Falling back to base.');\n\t\t\t\tconsole.log('     Loading Exception: '+pException);\n\t\t\t}\n\t\t}\n\n\t\tif (tmpSettings.ConfigFile)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// If there is a configuration file, try to load and merge it.\n\t\t\t\ttmpSettings = this.merge(require(tmpSettings.ConfigFile), tmpSettings);\n\t\t\t}\n\t\t\tcatch (pException)\n\t\t\t{\n\t\t\t\t// Why this?  Often for an app we want settings to work out of the box, but\n\t\t\t\t// would potentially want to have a config file for complex settings.\n\t\t\t\tconsole.log('Fable-Settings Warning: Configuration file specified but there was a problem loading it.  Falling back to base.');\n\t\t\t\tconsole.log('     Loading Exception: '+pException);\n\t\t\t}\n\t\t}\n\n\t\tthis.settings = tmpSettings;\n\t}\n\n\t// Build a default settings object.  Use the JSON jimmy to ensure it is always a new object.\n\tbuildDefaultSettings()\n\t{\n\t\treturn JSON.parse(JSON.stringify(require('./Fable-Settings-Default')));\n\t}\n\n\t// Update the configuration for environment variable templating based on the current settings object\n\t_configureEnvTemplating(pSettings)\n\t{\n\t\t// default environment variable templating to on\n\t\tthis._PerformEnvTemplating = !pSettings || pSettings.NoEnvReplacement !== true;\n\t}\n\n\t// Resolve (recursive) any environment variables found in settings object.\n\t_resolveEnv(pSettings)\n\t{\n\t\tfor (const tmpKey in pSettings)\n\t\t{\n\t\t\tif (typeof(pSettings[tmpKey]) === 'object')\n\t\t\t{\n\t\t\t\tthis._resolveEnv(pSettings[tmpKey]);\n\t\t\t}\n\t\t\telse if (typeof(pSettings[tmpKey]) === 'string')\n\t\t\t{\n\t\t\t\tpSettings[tmpKey] = this.settingsTemplateProcessor.parseSetting(pSettings[tmpKey]);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Check to see if a value is an object (but not an array).\n\t */\n\t_isObject(value)\n\t{\n\t\treturn typeof(value) === 'object' && !Array.isArray(value);\n\t}\n\n\t/**\n\t * Merge two plain objects. Keys that are objects in both will be merged property-wise.\n\t */\n\t_deepMergeObjects(toObject, fromObject)\n\t{\n\t\tif (!fromObject || !this._isObject(fromObject))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tObject.keys(fromObject).forEach((key) =>\n\t\t{\n\t\t\tconst fromValue = fromObject[key];\n\t\t\tif (this._isObject(fromValue))\n\t\t\t{\n\t\t\t\tconst toValue = toObject[key];\n\t\t\t\tif (toValue && this._isObject(toValue))\n\t\t\t\t{\n\t\t\t\t\t// both are objects, so do a recursive merge\n\t\t\t\t\tthis._deepMergeObjects(toValue, fromValue);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttoObject[key] = fromValue;\n\t\t});\n\t\treturn toObject;\n\t}\n\n\t// Merge some new object into the existing settings.\n\tmerge(pSettingsFrom, pSettingsTo)\n\t{\n\t\t// If an invalid settings from object is passed in (e.g. object constructor without passing in anything) this should still work\n\t\tlet tmpSettingsFrom = (typeof(pSettingsFrom) === 'object') ? pSettingsFrom : {};\n\t\t// Default to the settings object if none is passed in for the merge.\n\t\tlet tmpSettingsTo = (typeof(pSettingsTo) === 'object') ? pSettingsTo : this.settings;\n\n\t\t// do not mutate the From object property values\n\t\tlet tmpSettingsFromCopy = JSON.parse(JSON.stringify(tmpSettingsFrom));\n\t\ttmpSettingsTo = this._deepMergeObjects(tmpSettingsTo, tmpSettingsFromCopy);\n\n\t\tif (this._PerformEnvTemplating)\n\t\t{\n\t\t\tthis._resolveEnv(tmpSettingsTo);\n\t\t}\n\t\t// Update env tempating config, since we just updated the config object, and it may have changed\n\t\tthis._configureEnvTemplating(tmpSettingsTo);\n\n\t\treturn tmpSettingsTo;\n\t}\n\n\t// Fill in settings gaps without overwriting settings that are already there\n\tfill(pSettingsFrom)\n\t{\n\t\t// If an invalid settings from object is passed in (e.g. object constructor without passing in anything) this should still work\n\t\tlet tmpSettingsFrom = (typeof(pSettingsFrom) === 'object') ? pSettingsFrom : {};\n\n\t\t// do not mutate the From object property values\n\t\tlet tmpSettingsFromCopy = JSON.parse(JSON.stringify(tmpSettingsFrom));\n\n\t\tthis.settings = this._deepMergeObjects(tmpSettingsFromCopy, this.settings);\n\n\t\treturn this.settings;\n\t}\n};\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new FableSettings(pSettings);\n}\n\nmodule.exports = FableSettings;\nmodule.exports.new = autoConstruct;\nmodule.exports.precedent = libPrecedent;","/**\n* Random Byte Generator - Browser version\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\n// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\nclass RandomBytes\n{\n\tconstructor()\n\t{\n\n\t\t// getRandomValues needs to be invoked in a context where \"this\" is a Crypto\n\t\t// implementation. Also, find the complete implementation of crypto on IE11.\n\t\tthis.getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||\n                      \t\t(typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));\n\t}\n\n\t// WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n\tgenerateWhatWGBytes()\n\t{\n\t\tlet tmpBuffer = new Uint8Array(16); // eslint-disable-line no-undef\n\n\t\tthis.getRandomValues(tmpBuffer);\n\t\treturn tmpBuffer;\n\t}\n\n\t// Math.random()-based (RNG)\n\tgenerateRandomBytes()\n\t{\n\t\t// If all else fails, use Math.random().  It's fast, but is of unspecified\n\t\t// quality.\n\t\tlet tmpBuffer = new Uint8Array(16); // eslint-disable-line no-undef\n\n\t\tfor (let i = 0, tmpValue; i < 16; i++)\n\t\t{\n\t\t\tif ((i & 0x03) === 0)\n\t\t\t{\n\t\t\t\ttmpValue = Math.random() * 0x100000000;\n\t\t\t}\n\n\t\t\ttmpBuffer[i] = tmpValue >>> ((i & 0x03) << 3) & 0xff;\n\t\t}\n\n\t\treturn tmpBuffer;\n\t}\n\n\tgenerate()\n\t{\n\t\tif (this.getRandomValues)\n\t\t{\n\t\t\treturn this.generateWhatWGBytes();\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.generateRandomBytes();\n\t\t}\n\t}\n}\n\nmodule.exports = RandomBytes;\n","/**\n* Fable UUID Generator\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable UUID\n*/\n\n/**\n* Fable Solution UUID Generation Main Class\n*\n* @class FableUUID\n* @constructor\n*/\n\nvar libRandomByteGenerator = require('./Fable-UUID-Random.js')\n\nclass FableUUID\n{\n\tconstructor(pSettings)\n\t{\n\t\t// Determine if the module is in \"Random UUID Mode\" which means just use the random character function rather than the v4 random UUID spec.\n\t\t// Note this allows UUIDs of various lengths (including very short ones) although guaranteed uniqueness goes downhill fast.\n\t\tthis._UUIDModeRandom = (typeof(pSettings) === 'object') && (pSettings.hasOwnProperty('UUIDModeRandom')) ? (pSettings.UUIDModeRandom == true) : false;\n\t\t// These two properties are only useful if we are in Random mode.  Otherwise it generates a v4 spec\n\t\t// Length for \"Random UUID Mode\" is set -- if not set it to 8\n\t\tthis._UUIDLength = (typeof(pSettings) === 'object') && (pSettings.hasOwnProperty('UUIDLength')) ? (pSettings.UUIDLength + 0) : 8;\n\t\t// Dictionary for \"Random UUID Mode\"\n\t\tthis._UUIDRandomDictionary = (typeof(pSettings) === 'object') && (pSettings.hasOwnProperty('UUIDDictionary')) ? (pSettings.UUIDDictionary + 0) : '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n\n\t\tthis.randomByteGenerator = new libRandomByteGenerator();\n\n\t\t// Lookup table for hex codes\n\t\tthis._HexLookup = [];\n\t\tfor (let i = 0; i < 256; ++i)\n\t\t{\n\t\t\tthis._HexLookup[i] = (i + 0x100).toString(16).substr(1);\n\t\t}\n\t}\n\n\t// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n\tbytesToUUID(pBuffer)\n\t{\n\t\tlet i = 0;\n\t\t// join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n\t\treturn ([\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], \n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]]\n\t\t\t\t]).join('');\n\t}\n\n\t// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n\tgenerateUUIDv4()\n\t{\n\t\tlet tmpBuffer = new Array(16);\n\t\tvar tmpRandomBytes = this.randomByteGenerator.generate();\n\n\t\t// Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\t\ttmpRandomBytes[6] = (tmpRandomBytes[6] & 0x0f) | 0x40;\n\t\ttmpRandomBytes[8] = (tmpRandomBytes[8] & 0x3f) | 0x80;\n\n\t\treturn this.bytesToUUID(tmpRandomBytes);\n\t}\n\n\t// Simple random UUID generation\n\tgenerateRandom()\n\t{\n\t\tlet tmpUUID = '';\n\n\t\tfor (let i = 0; i < this._UUIDLength; i++)\n\t\t{\n\t\t\ttmpUUID += this._UUIDRandomDictionary.charAt(Math.floor(Math.random() * (this._UUIDRandomDictionary.length-1)));\n\t\t}\n\n\t\treturn tmpUUID;\n\t}\n\n\t// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n\tgetUUID()\n\t{\n\t\tif (this._UUIDModeRandom)\n\t\t{\n\t\t\treturn this.generateRandom();\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.generateUUIDv4();\n\t\t}\n\t}\n}\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new FableUUID(pSettings);\n}\n\n\nmodule.exports = FableUUID;\nmodule.exports.new = autoConstruct;\n","// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n","/**\n* Precedent Meta-Templating\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Process text streams, parsing out meta-template expressions.\n*/\nvar libWordTree = require(`./WordTree.js`);\nvar libStringParser = require(`./StringParser.js`);\n\nclass Precedent\n{\n\t/**\n\t * Precedent Constructor\n\t */\n\tconstructor()\n\t{\n\t\tthis.WordTree = new libWordTree();\n\t\t\n\t\tthis.StringParser = new libStringParser();\n\n\t\tthis.ParseTree = this.WordTree.ParseTree;\n\t}\n\t\n\t/**\n\t * Add a Pattern to the Parse Tree\n\t * @method addPattern\n\t * @param {Object} pTree - A node on the parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @param {number} pIndex - callback function\n\t * @return {bool} True if adding the pattern was successful\n\t */\n\taddPattern(pPatternStart, pPatternEnd, pParser)\n\t{\n\t\treturn this.WordTree.addPattern(pPatternStart, pPatternEnd, pParser);\n\t}\n\t\n\t/**\n\t * Parse a string with the existing parse tree\n\t * @method parseString\n\t * @param {string} pString - The string to parse\n\t * @return {string} The result from the parser\n\t */\n\tparseString(pString)\n\t{\n\t\treturn this.StringParser.parseString(pString, this.ParseTree);\n\t}\n}\n\nmodule.exports = Precedent;\n","/**\n* String Parser\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Parse a string, properly processing each matched token in the word tree.\n*/\n\nclass StringParser\n{\n\t/**\n\t * StringParser Constructor\n\t */\n\tconstructor()\n\t{\n\t}\n\t\n\t/**\n\t * Create a fresh parsing state object to work with.\n\t * @method newParserState\n\t * @param {Object} pParseTree - A node on the parse tree to begin parsing from (usually root)\n\t * @return {Object} A new parser state object for running a character parser on\n\t * @private\n\t */\n\tnewParserState (pParseTree)\n\t{\n\t\treturn (\n\t\t{\n\t\t\tParseTree: pParseTree,\n\n\t\t\tOutput: '',\n\t\t\tOutputBuffer: '',\n\n\t\t\tPattern: false,\n\n\t\t\tPatternMatch: false,\n\t\t\tPatternMatchOutputBuffer: ''\n\t\t});\n\t}\n\t\t\n\t/**\n\t * Assign a node of the parser tree to be the next potential match.\n\t * If the node has a PatternEnd property, it is a valid match and supercedes the last valid match (or becomes the initial match).\n\t * @method assignNode\n\t * @param {Object} pNode - A node on the parse tree to assign\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tassignNode (pNode, pParserState)\n\t{\n\t\tpParserState.PatternMatch = pNode;\n\n\t\t// If the pattern has a END we can assume it has a parse function...\n\t\tif (pParserState.PatternMatch.hasOwnProperty('PatternEnd'))\n\t\t{\n\t\t\t// ... this is the legitimate start of a pattern.\n\t\t\tpParserState.Pattern = pParserState.PatternMatch;\n\t\t}\n\t}\n\t\n\t/**\n\t * Append a character to the output buffer in the parser state.\n\t * This output buffer is used when a potential match is being explored, or a match is being explored.\n\t * @method appendOutputBuffer\n\t * @param {string} pCharacter - The character to append\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tappendOutputBuffer (pCharacter, pParserState)\n\t{\n\t\tpParserState.OutputBuffer += pCharacter;\n\t}\n\t\n\t/**\n\t * Flush the output buffer to the output and clear it.\n\t * @method flushOutputBuffer\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tflushOutputBuffer (pParserState)\n\t{\n\t\tpParserState.Output += pParserState.OutputBuffer;\n\t\tpParserState.OutputBuffer = '';\n\t}\n\n\t\n\t/**\n\t * Check if the pattern has ended.  If it has, properly flush the buffer and start looking for new patterns.\n\t * @method checkPatternEnd\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tcheckPatternEnd (pParserState)\n\t{\n\t\tif ((pParserState.OutputBuffer.length >= pParserState.Pattern.PatternEnd.length+pParserState.Pattern.PatternStart.length) && \n\t\t\t(pParserState.OutputBuffer.substr(-pParserState.Pattern.PatternEnd.length) === pParserState.Pattern.PatternEnd))\n\t\t{\n\t\t\t// ... this is the end of a pattern, cut off the end tag and parse it.\n\t\t\t// Trim the start and end tags off the output buffer now\n\t\t\tpParserState.OutputBuffer = pParserState.Pattern.Parse(pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStart.length, pParserState.OutputBuffer.length - (pParserState.Pattern.PatternStart.length+pParserState.Pattern.PatternEnd.length)));\n\t\t\t// Flush the output buffer.\n\t\t\tthis.flushOutputBuffer(pParserState);\n\t\t\t// End pattern mode\n\t\t\tpParserState.Pattern = false;\n\t\t\tpParserState.PatternMatch = false;\n\t\t}\n\t}\n\t\n\t/**\n\t * Parse a character in the buffer.\n\t * @method parseCharacter\n\t * @param {string} pCharacter - The character to append\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tparseCharacter (pCharacter, pParserState)\n\t{\n\t\t// (1) If we aren't in a pattern match, and we aren't potentially matching, and this may be the start of a new pattern....\n\t\tif (!pParserState.PatternMatch && pParserState.ParseTree.hasOwnProperty(pCharacter))\n\t\t{\n\t\t\t// ... assign the node as the matched node.\n\t\t\tthis.assignNode(pParserState.ParseTree[pCharacter], pParserState);\n\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t}\n\t\t// (2) If we are in a pattern match (actively seeing if this is part of a new pattern token)\n\t\telse if (pParserState.PatternMatch)\n\t\t{\n\t\t\t// If the pattern has a subpattern with this key\n\t\t\tif (pParserState.PatternMatch.hasOwnProperty(pCharacter))\n\t\t\t{\n\t\t\t\t// Continue matching patterns.\n\t\t\t\tthis.assignNode(pParserState.PatternMatch[pCharacter], pParserState);\n\t\t\t}\n\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\tif (pParserState.Pattern)\n\t\t\t{\n\t\t\t\t// ... Check if this is the end of the pattern (if we are matching a valid pattern)...\n\t\t\t\tthis.checkPatternEnd(pParserState);\n\t\t\t}\n\t\t}\n\t\t// (3) If we aren't in a pattern match or pattern, and this isn't the start of a new pattern (RAW mode)....\n\t\telse\n\t\t{\n\t\t\tpParserState.Output += pCharacter;\n\t\t}\n\t}\n\t\n\t/**\n\t * Parse a string for matches, and process any template segments that occur.\n\t * @method parseString\n\t * @param {string} pString - The string to parse.\n\t * @param {Object} pParseTree - The parse tree to begin parsing from (usually root)\n\t */\n\tparseString (pString, pParseTree)\n\t{\n\t\tlet tmpParserState = this.newParserState(pParseTree);\n\n\t\tfor (var i = 0; i < pString.length; i++)\n\t\t{\n\t\t\t// TODO: This is not fast.\n\t\t\tthis.parseCharacter(pString[i], tmpParserState);\n\t\t}\n\t\t\n\t\tthis.flushOutputBuffer(tmpParserState);\n\t\t\n\t\treturn tmpParserState.Output;\n\t}\n}\n\nmodule.exports = StringParser;\n","/**\n* Word Tree\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Create a tree (directed graph) of Javascript objects, one character per object.\n*/\n\nclass WordTree\n{\n\t/**\n\t * WordTree Constructor\n\t */\n\tconstructor()\n\t{\n\t\tthis.ParseTree = {};\n\t}\n\t\n\t/** \n\t * Add a child character to a Parse Tree node\n\t * @method addChild\n\t * @param {Object} pTree - A parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @param {number} pIndex - The index of the character in the pattern\n\t * @returns {Object} The resulting leaf node that was added (or found)\n\t * @private\n\t */\n\taddChild (pTree, pPattern, pIndex)\n\t{\n\t\tif (!pTree.hasOwnProperty(pPattern[pIndex]))\n\t\t\tpTree[pPattern[pIndex]] = {};\n\t\t\n\t\treturn pTree[pPattern[pIndex]];\n\t}\n\t\n\t/** Add a Pattern to the Parse Tree\n\t * @method addPattern\n\t * @param {Object} pPatternStart - The starting string for the pattern (e.g. \"${\")\n\t * @param {string} pPatternEnd - The ending string for the pattern (e.g. \"}\")\n\t * @param {number} pParser - The function to parse if this is the matched pattern, once the Pattern End is met.  If this is a string, a simple replacement occurs.\n\t * @return {bool} True if adding the pattern was successful\n\t */\n\taddPattern (pPatternStart, pPatternEnd, pParser)\n\t{\n\t\tif (pPatternStart.length < 1)\n\t\t\treturn false;\n\n\t\tif ((typeof(pPatternEnd) === 'string') && (pPatternEnd.length < 1))\n\t\t\treturn false;\n\n\t\tlet tmpLeaf = this.ParseTree;\n\n\t\t// Add the tree of leaves iteratively\n\t\tfor (var i = 0; i < pPatternStart.length; i++)\n\t\t\ttmpLeaf = this.addChild(tmpLeaf, pPatternStart, i);\n\n\t\ttmpLeaf.PatternStart = pPatternStart;\n\t\ttmpLeaf.PatternEnd = ((typeof(pPatternEnd) === 'string') && (pPatternEnd.length > 0)) ? pPatternEnd : pPatternStart;\n\t\ttmpLeaf.Parse = (typeof(pParser) === 'function') ? pParser : \n\t\t\t\t\t\t(typeof(pParser) === 'string') ? () => { return pParser; } :\n\t\t\t\t\t\t(pData) => { return pData; };\n\n\t\treturn true;\n\t}\n}\n\nmodule.exports = WordTree;\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","var nextTick = require('process/browser.js').nextTick;\nvar apply = Function.prototype.apply;\nvar slice = Array.prototype.slice;\nvar immediateIds = {};\nvar nextImmediateId = 0;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) { timeout.close(); };\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// That's not how node.js implements it but the exposed api is the same.\nexports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n  var id = nextImmediateId++;\n  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n  immediateIds[id] = true;\n\n  nextTick(function onNextTick() {\n    if (immediateIds[id]) {\n      // fn.call() is faster so we optimize for the common use-case\n      // @see http://jsperf.com/call-apply-segu\n      if (args) {\n        fn.apply(null, args);\n      } else {\n        fn.call(null);\n      }\n      // Prevent ids from leaking\n      exports.clearImmediate(id);\n    }\n  });\n\n  return id;\n};\n\nexports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n  delete immediateIds[id];\n};","var libNPMModuleWrapper = require('./Fable.js');\n\nif ((typeof(window) === 'object') && !window.hasOwnProperty('Fable'))\n{\n\twindow.Fable = libNPMModuleWrapper;\n}\n\nmodule.exports = libNPMModuleWrapper;","const _OperationStatePrototype = JSON.stringify(\n{\n\t\"Metadata\": {\n\t\t\"GUID\": false,\n\t\t\"Hash\": false,\n\n\t\t\"Title\": \"\",\n\t\t\"Summary\": \"\",\n\n\t\t\"Version\": 0\n\t},\n\t\"Status\": {\n        \"Completed\": false,\n\n        \"CompletionProgress\": 0,\n        \"CompletionTimeElapsed\": 0,\n\n        \"Steps\": 1,\n        \"StepsCompleted\": 0,\n\n        \"StartTime\": 0,\n        \"EndTime\": 0\n\t},\n\t\"Errors\": [],\n\t\"Log\": []\n});\n\nclass FableOperation\n{\n\tconstructor(pFable, pOperationName, pOperationHash)\n\t{\n\t\tthis.fable = pFable;\n\n\t\tthis.name = pOperationName;\n\n\t\tthis.state = JSON.parse(_OperationStatePrototype);\n\n\t\tthis.state.Metadata.GUID = this.fable.getUUID();\n\t\tthis.state.Metadata.Hash = this.state.GUID;\n\n\t\tif (typeof(pOperationHash) == 'string')\n\t\t{\n\t\t\tthis.state.Metadata.Hash = pOperationHash;\n\t\t}\n\t}\n\n\tget GUID()\n\t{\n\t\treturn this.state.Metadata.GUID;\n\t}\n\n\tget Hash()\n\t{\n\t\treturn this.state.Metadata.Hash;\n\t}\n\n\tget log()\n\t{\n\t\treturn this;\n\t}\n\n\twriteOperationLog(pLogLevel, pLogText, pLogObject)\n\t{\n\t\tthis.state.Log.push(`${new Date().toUTCString()} [${pLogLevel}]: ${pLogText}`);\n\n\t\tif (typeof(pLogObject) == 'object')\n\t\t{\n\t\t\tthis.state.Log.push(JSON.stringify(pLogObject));\n\t\t}\n\t}\n\n\twriteOperationErrors(pLogText, pLogObject)\n\t{\n\t\tthis.state.Errors.push(`${pLogText}`);\n\n\t\tif (typeof(pLogObject) == 'object')\n\t\t{\n\t\t\tthis.state.Errors.push(JSON.stringify(pLogObject));\n\t\t}\n\t}\n\n\ttrace(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('TRACE', pLogText, pLogObject);\n\t\tthis.fable.log.trace(pLogText, pLogObject);\n\t}\n\n\tdebug(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('DEBUG', pLogText, pLogObject);\n\t\tthis.fable.log.debug(pLogText, pLogObject);\n\t}\n\n\tinfo(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('INFO', pLogText, pLogObject);\n\t\tthis.fable.log.info(pLogText, pLogObject);\n\t}\n\n\twarn(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('WARN', pLogText, pLogObject);\n\t\tthis.fable.log.warn(pLogText, pLogObject);\n\t}\n\n\terror(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('ERROR', pLogText, pLogObject);\n\t\tthis.writeOperationErrors(pLogText, pLogObject);\n\t\tthis.fable.log.error(pLogText, pLogObject);\n\t}\n\n\tfatal(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('FATAL', pLogText, pLogObject);\n\t\tthis.writeOperationErrors(pLogText, pLogObject);\n\t\tthis.fable.log.fatal(pLogText, pLogObject);\n\t}\n}\n\nmodule.exports = FableOperation;","const libFableServiceBase = require('./Fable-ServiceProviderBase.js');\n\nclass FableServiceTemplate extends libFableServiceBase\n{\n\t// Underscore and lodash have a behavior, _.template, which compiles a\n\t// string-based template with code snippets into simple executable pieces,\n\t// with the added twist of returning a precompiled function ready to go.\n\t//\n\t// NOTE: This does not implement underscore escape expressions\n\t// NOTE: This does not implement underscore magic browser variable assignment\n\t//\n\t// This is an implementation of that.\n\t// TODO: Make this use precedent, add configuration, add debugging.\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n        super(pFable, pOptions, pServiceHash);\n\n        this.serviceType = 'Template';\n\n\t\t// These are the exact regex's used in lodash/underscore\n\t\t// TODO: Switch this to precedent\n\t\tthis.Matchers = (\n\t\t\t{\n\t\t\t\tEvaluate: /<%([\\s\\S]+?)%>/g,\n\t\t\t\tInterpolate: /<%=([\\s\\S]+?)%>/g,\n\t\t\t\tEscaper: /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g,\n\t\t\t\tUnescaper: /\\\\(\\\\|'|r|n|t|u2028|u2029)/g,\n\t\t\t\t// This is how underscore does it, so we are keeping it for now.\n\t\t\t\tGuaranteedNonMatch: /.^/\n\t\t\t});\n\n\t\t// This is a helper for the escaper and unescaper functions.\n\t\t// Right now we are going to keep what underscore is doing, but, not forever.\n\t\tthis.templateEscapes = {\n\t\t\t'\\\\': '\\\\',\n\t\t\t\"'\": \"'\",\n\t\t\t'r': '\\r',\n\t\t\t'\\r': 'r',\n\t\t\t'n': '\\n',\n\t\t\t'\\n': 'n',\n\t\t\t't': '\\t',\n\t\t\t'\\t': 't',\n\t\t\t'u2028': '\\u2028',\n\t\t\t'\\u2028': 'u2028',\n\t\t\t'u2029': '\\u2029',\n\t\t\t'\\u2029': 'u2029'\n\t\t};\n\n\t\t// This is defined as such to underscore that it is a dynamic programming\n\t\t// function on this class.\n\t\tthis.renderFunction = false;\n        this.templateString = false;\n\t}\n\n\trenderTemplate(pData)\n\t{\n\t\treturn this.renderFunction(pData);\n\t}\n\n\ttemplateFunction(pData)\n\t{\n\t\tlet fRenderTemplateBound = this.renderTemplate.bind(this);\n\t\treturn fRenderTemplateBound;\n\t}\n\n\tbuildTemplateFunction(pTemplateText, pData)\n\t{\n\t\t// For now this is being kept in a weird form ... this is to mimic the old\n\t\t// underscore code until this is rewritten using precedent.\n\t\tthis.TemplateSource = \"__p+='\" + pTemplateText\n\t\t\t.replace(this.Matchers.Escaper,\n\t\t\t\t(pMatch)=>\n\t\t\t\t{\n\t\t\t\t\treturn `\\\\${this.templateEscapes[pMatch]}`;\n\t\t\t\t})\n\t\t\t.replace(this.Matchers.Interpolate || this.Matchers.GuaranteedNonMatch,\n\t\t\t\t(pMatch, pCode) =>\n\t\t\t\t{\n\t\t\t\t\treturn `'+\\n(${decodeURIComponent(pCode)})+\\n'`;\n\t\t\t\t})\n\t\t\t.replace(this.Matchers.Evaluate || this.Matchers.GuaranteedNonMatch,\n\t\t\t\t(pMatch, pCode) =>\n\t\t\t\t{\n\t\t\t\t\treturn `';\\n${decodeURIComponent(pCode)}\\n;__p+='`;\n\t\t\t\t}) + `';\\n`;\n\n\n\t\tthis.TemplateSource = `with(pTemplateDataObject||{}){\\n${this.TemplateSource}}\\n`;\n\t\tthis.TemplateSource = `var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};\\n${this.TemplateSource}return __p;\\n`;\n\n\t\tthis.renderFunction = new Function('pTemplateDataObject', this.TemplateSource);\n\n\t\tif (typeof(pData) != 'undefined')\n\t\t{\n\t\t\treturn this.renderFunction(pData);\n\t\t}\n\n\t\t// Provide the compiled function source as a convenience for build time\n\t\t// precompilation.\n\t\tthis.TemplateSourceCompiled = 'function(obj){\\n' + this.TemplateSource + '}';\n\n\t\treturn this.templateFunction();\n\t}\n}\n\nmodule.exports = FableServiceTemplate;","/**\n* Fable Application Services Management\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\nconst libFableServiceBase = require('./Fable-ServiceProviderBase.js');\n\nclass FableService\n{\n\tconstructor(pFable)\n\t{\n\t\tthis.fable = pFable;\n\n\t\tthis.serviceTypes = [];\n\n\t\t// A map of instantiated services\n\t\tthis.services = {};\n\n\t\t// A map of the default instantiated service by type\n\t\tthis.defaultServices = {};\n\n\t\t// A map of class constructors for services\n\t\tthis.serviceClasses = {};\n\t}\n\n\taddServiceType(pServiceType, pServiceClass)\n\t{\n\t\t// Add the type to the list of types\n\t\tthis.serviceTypes.push(pServiceType);\n\n\t\t// Add the container for instantiated services to go in\n\t\tthis.services[pServiceType] = {};\n\n\t\tif ((typeof(pServiceClass) == 'function') && (pServiceClass.prototype instanceof libFableServiceBase))\n\t\t{\n\t\t\t// Add the class to the list of classes\n\t\t\tthis.serviceClasses[pServiceType] = pServiceClass;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Add the base class to the list of classes\n\t\t\tthis.serviceClasses[pServiceType] = libFableServiceBase;\n\t\t}\n\t}\n\n\tinstantiateServiceProvider(pServiceType, pOptions, pCustomServiceHash)\n\t{\n\t\t// Instantiate the service\n\t\tlet tmpService = this.instantiateServiceProviderWithoutRegistration(pServiceType, pOptions, pCustomServiceHash);\n\n\t\t// Add the service to the service map\n\t\tthis.services[pServiceType][tmpService.Hash] = tmpService;\n\n\t\t// If this is the first service of this type, make it the default\n\t\tif (!this.defaultServices.hasOwnProperty(pServiceType))\n\t\t{\n\t\t\tthis.defaultServices[pServiceType] = tmpService;\n\t\t}\n\n\t\treturn tmpService;\n\t}\n\n\t// Create a service provider but don't register it to live forever in fable.services\n\tinstantiateServiceProviderWithoutRegistration(pServiceType, pOptions, pCustomServiceHash)\n\t{\n\t\t// Instantiate the service\n\t\tlet tmpService = new this.serviceClasses[pServiceType](this.fable, pOptions, pCustomServiceHash);\n\t\treturn tmpService;\n\t}\n\n\tsetDefaultServiceInstantiation(pServiceType, pServiceHash)\n\t{\n\t\tif (this.services[pServiceType].hasOwnProperty(pServiceHash))\n\t\t{\n\t\t\tthis.defaultServices[pServiceType] = this.services[pServiceType][pServiceHash];\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n}\n\nmodule.exports = FableService;\n\nmodule.exports.ServiceProviderBase = libFableServiceBase;","/**\n* Fable Service Base\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\nclass FableServiceProviderBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tthis.fable = pFable;\n\n\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions : {};\n\n        this.serviceType = 'Unknown';\n\n        this.UUID = pFable.getUUID();\n\n        this.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash : `${this.UUID}`;\n\t}\n}\n\nmodule.exports = FableServiceProviderBase;\n","// TODO: These are still pretty big -- consider the smaller polyfills\nconst libAsyncWaterfall = require('async.waterfall');\nconst libAsyncEachLimit = require('async.eachlimit');\n\nclass FableUtility\n{\n\tconstructor(pFable)\n\t{\n\t\tthis.fable = pFable;\n\n\t\tthis.templates = {};\n\n\t\t// These two functions are used extensively throughout\n\t\tthis.waterfall = libAsyncWaterfall;\n\t\tthis.eachLimit = libAsyncEachLimit;\n\t}\n\n\t// Underscore and lodash have a behavior, _.extend, which merges objects.\n\t// Now that es6 gives us this, use the native thingy.\n\textend(pDestinationObject, ...pSourceObjects)\n\t{\n\t\treturn Object.assign(pDestinationObject, ...pSourceObjects);\n\t}\n\n\t// Underscore and lodash have a behavior, _.template, which compiles a\n\t// string-based template with code snippets into simple executable pieces,\n\t// with the added twist of returning a precompiled function ready to go.\n\ttemplate(pTemplateText, pData)\n\t{\n\t\tlet tmpTemplate = this.fable.serviceManager.instantiateServiceProviderWithoutRegistration('Template');\n\n\t\treturn tmpTemplate.buildTemplateFunction(pTemplateText, pData);\n\t}\n\n\t// Build a template function from a template hash, and, register it with the service provider\n\tbuildHashedTemplate(pTemplateHash, pTemplateText, pData)\n\t{\n\t\tlet tmpTemplate = this.fable.serviceManager.instantiateServiceProvider('Template', {}, pTemplateHash);\n\n\t\tthis.templates[pTemplateHash] = tmpTemplate.buildTemplateFunction(pTemplateText, pData);\n\n\t\treturn this.templates[pTemplateHash];\n\t}\n\n\t// This is a safe, modern version of chunk from underscore\n\t// Algorithm pulled from a mix of these two polyfills:\n\t// https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_chunk\n\t// https://youmightnotneed.com/lodash\n\t// This implementation was most tolerant in browsers.  Uglify can fix the rest.\n\tchunk (pInput, pChunkSize, pChunkCache)\n\t{\n\t\tlet tmpInputArray = [...pInput];\n\t\t// Note lodash defaults to 1, underscore defaults to 0\n\t\tlet tmpChunkSize = (typeof(pChunkSize) == 'number') ? pChunkSize : 0;\n\t\tlet tmpChunkCache = (typeof(pChunkCache) != 'undefined') ? pChunkCache : [];\n\n\t\tif (tmpChunkSize <= 0)\n\t\t{\n\t\t\treturn tmpChunkCache;\n\t\t}\n\n\t\twhile (tmpInputArray.length)\n\t\t{\n\t\t\ttmpChunkCache.push(tmpInputArray.splice(0, tmpChunkSize));\n\t\t}\n\n\t\treturn tmpChunkCache;\n\t}\n}\n\nmodule.exports = FableUtility;","/**\n* Fable Application Services Support Library\n* @license MIT\n* @author <steven@velozo.com>\n*/\nconst libFableSettings = require('fable-settings');\nconst libFableUUID = require('fable-uuid');\nconst libFableLog = require('fable-log');\n\nconst libFableUtility = require('./Fable-Utility.js');\nconst libFableServiceManager = require('./Fable-ServiceManager.js');\n\nconst libFableServiceTemplate = require('./Fable-Service-Template.js');\n\nconst libFableOperation = require('./Fable-Operation.js');\n\nclass Fable\n{\n\tconstructor(pSettings)\n\t{\n\t\tlet tmpSettings = new libFableSettings(pSettings);\n\n\t\tthis.settingsManager = tmpSettings;\n\n\t\t// Instantiate the UUID generator\n\t\tthis.libUUID = new libFableUUID(this.settingsManager.settings);\n\n\t\tthis.log = new libFableLog(this.settingsManager.settings);\n\t\tthis.log.initialize();\n\n\t\t// Built-in utility belt functions\n\t\tthis.Utility = new libFableUtility(this);\n\n\t\t// Built-in dependencies\n\t\tthis.Dependencies = (\n\t\t\t{\n\t\t\t\tprecedent: libFableSettings.precedent\n\t\t\t});\n\n\t\t// Location for Operation state\n\t\tthis.Operations = {};\n\n\t\tthis.serviceManager = new libFableServiceManager(this);\n\n\t\tthis.serviceManager.addServiceType('Template', libFableServiceTemplate);\n\n\t\tthis.services = this.serviceManager.services;\n\t\tthis.defaultServices = this.serviceManager.defaultServices;\n\t}\n\n\tget settings()\n\t{\n\t\treturn this.settingsManager.settings;\n\t}\n\n\tget fable()\n\t{\n\t\treturn this;\n\t}\n\n\tgetUUID()\n\t{\n\t\treturn this.libUUID.getUUID();\n\t}\n\n\tcreateOperation(pOperationName, pOperationHash)\n\t{\n\t\tlet tmpOperation = new libFableOperation(this, pOperationName, pOperationHash);\n\n\t\tif (this.Operations.hasOwnProperty(tmpOperation.Hash))\n\t\t{\n\t\t\t// Uh Oh ...... Operation Hash Collision!\n\t\t\t// TODO: What to do?!\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.Operations[tmpOperation.Hash] = tmpOperation;\n\t\t}\n\n\t\treturn tmpOperation;\n\t}\n\n\tgetOperation(pOperationHash)\n\t{\n\t\tif (!this.Operations.hasOwnProperty(pOperationHash))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.Operations[pOperationHash];\n\t\t}\n\t}\n}\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new Fable(pSettings);\n}\n\nmodule.exports = Fable;\nmodule.exports.new = autoConstruct;\n\nmodule.exports.LogProviderBase = libFableLog.LogProviderBase;\nmodule.exports.ServiceProviderBase = libFableServiceManager.ServiceProviderBase;\n\nmodule.exports.precedent = libFableSettings.precedent;"]}