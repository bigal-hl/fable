{"version":3,"sources":["fable.min.js","node_modules/browser-pack/_prelude.js","node_modules/async.eachlimit/index.js","node_modules/async.iterator/index.js","node_modules/async.util.eachoflimit/index.js","node_modules/async.util.ensureasync/index.js","node_modules/async.util.isarray/index.js","node_modules/async.util.isarraylike/index.js","node_modules/async.util.keyiterator/index.js","node_modules/async.util.keys/index.js","node_modules/async.util.noop/index.js","node_modules/async.util.once/index.js","node_modules/async.util.onlyonce/index.js","node_modules/async.util.restparam/index.js","node_modules/async.util.setimmediate/index.js","node_modules/async.util.withoutindex/index.js","node_modules/async.waterfall/index.js","node_modules/data-arithmatic/source/DataArithmatic.js","node_modules/fable-log/source/Fable-Log-BaseLogger.js","node_modules/fable-log/source/Fable-Log-DefaultProviders-Web.js","node_modules/fable-log/source/Fable-Log-DefaultStreams.json","node_modules/fable-log/source/Fable-Log-Logger-Console.js","node_modules/fable-log/source/Fable-Log-Logger-SimpleFlatFile.js","node_modules/fable-log/source/Fable-Log.js","node_modules/fable-settings/source/Fable-Settings-Default.json","node_modules/fable-settings/source/Fable-Settings-TemplateProcessor.js","node_modules/fable-settings/source/Fable-Settings.js","node_modules/fable-uuid/source/Fable-UUID-Random-Browser.js","node_modules/fable-uuid/source/Fable-UUID.js","node_modules/path-browserify/index.js","node_modules/precedent/source/Precedent.js","node_modules/precedent/source/StringParser.js","node_modules/precedent/source/WordTree.js","node_modules/process/browser.js","node_modules/timers-browserify/main.js","source/Fable-Browser-Shim.js","source/Fable-Operation.js","source/Fable-Service-DataArithmatic.js","source/Fable-Service-MetaTemplate.js","source/Fable-Service-Template.js","source/Fable-Service-Utility.js","source/Fable-ServiceManager.js","source/Fable-ServiceProviderBase.js","source/Fable.js"],"names":["f","exports","module","define","amd","window","global","self","this","Fable","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","eachOfLimit","withoutIndex","arr","limit","iterator","cb","tasks","makeCallback","index","fn","apply","arguments","next","once","noop","onlyOnce","keyIterator","obj","nextKey","done","running","errored","replenish","key","err","setImmediate","restParam","args","callback","pop","push","innerArgs","sync","Array","isArray","Object","prototype","toString","_keys","isArrayLike","coll","len","keys","k","hasOwnProperty","func","startIndex","Math","max","rest","_setImmediate","fallback","setTimeout","timers","value","ensureAsync","wrapIterator","concat","constructor","_Regex_formatterInsertCommas","_Regex_formatterAddCommasToNumber","_Regex_formatterDollarsRemoveCommas","_Regex_formatterCleanNonAlpha","_Value_MoneySign_Currency","_Value_NaN_Currency","_Value_GroupSeparator_Number","_Value_Prefix_StringHash","_Value_Clean_formatterCleanNonAlpha","_UseEngineStringStartsWith","String","startsWith","_UseEngineStringEndsWith","endsWith","stringReverse","pString","split","reverse","join","stringStartsWith","pSearchString","pStartIndex","stringStartsWith_Polyfill","slice","stringEndsWith","pEndIndex","stringEndsWith_Polyfill","substr","insecureStringHash","tmpHash","tmpStringLength","tmpCharacterIndex","charCodeAt","cleanEnclosureWrapCharacters","pWrapCharacter","substring","cleanNonAlphaCharacters","replace","formatterInsertCommas","tmpReversedWithCommas","match","processAddCommasToNumberRegex","pMatch","pSign","pZeros","pBefore","pDecimal","pAfter","formatterAddCommasToNumber","pNumber","bind","formatterDollars","pValue","tmpDollarAmount","parseFloat","toFixed","isNaN","formatterRoundNumber","pDigits","tmpDigits","tmpValue","stringBeforeMatch","stringAfterMatch","tmpStringSplitLocation","indexOf","stringCountEnclosures","pEnclosureStart","pEnclosureEnd","tmpString","tmpEnclosureStart","tmpEnclosureEnd","tmpEnclosureCount","tmpEnclosureDepth","stringGetEnclosureValueByIndex","pEnclosureIndexToGet","tmpEnclosureIndexToGet","tmpMatchedEnclosureIndex","tmpEnclosedValueStartIndex","tmpEnclosedValueEndIndex","stringRemoveEnclosureByIndex","pEnclosureIndexToRemove","tmpEnclosureIndexToRemove","tmpEnclosureStartIndex","tmpEnclosureEndIndex","tmpReturnString","pLogStreamSettings","pFableLog","_Settings","loggerUUID","generateInsecureUUID","levels","tmpDate","Date","getTime","pCharacter","tmpRandomData","random","floor","initialize","trace","pLogText","pLogObject","write","debug","info","warn","error","fatal","pLogLevel","getDefaultProviders","tmpDefaultProviders","console","default","loggertype","streamtype","level","libBaseLogger","super","_ShowTimeStamps","showtimestamps","_FormattedTimeStamps","formattedtimestamps","_ContextMessage","Context","Product","_OutputLogLinesToConsole","outputloglinestoconsole","_OutputObjectsToConsole","outputobjectstoconsole","prefixCache","pLevel","pObject","tmpTimeStamp","toISOString","tmpLogLine","log","JSON","stringify","libConsoleLog","libFS","libPath","logFileRawPath","path","logFilePath","normalize","logFileStreamOptions","fileStreamOptions","flags","encoding","fileWriter","createWriteStream","activelyWriting","logLineStrings","logObjectStrings","defaultWriteCompleteCallback","defaultBufferFlushCallback","closeWriter","fCloseComplete","tmpCloseComplete","end","completeBufferFlushToLogFile","fFlushComplete","tmpFlushComplete","flushBufferToLogFile","tmpLineStrings","tmpObjectStrings","tmpConstructedBufferOutputString","fs","FableLog","pFableSettings","pFable","tmpSettings","_Providers","_StreamDefinitions","LogStreams","logStreams","logProviders","activeLogStreams","logStreamsTrace","logStreamsDebug","logStreamsInfo","logStreamsWarn","logStreamsError","logStreamsFatal","datumDecorator","pDatum","uuid","addLogger","pLogger","setDatumDecorator","fDatumDecorator","pMessage","tmpDecoratedDatum","tmpStreamDefinition","assign","logTime","tmpMessage","tmpTime","getTimeStamp","getTimeDelta","pTimeStamp","logTimeDelta","pTimeDelta","tmpEndTime","logTimeDeltaHuman","tmpMs","parseInt","tmpSeconds","tmpMinutes","tmpHours","logTimeDeltaRelative","pStartTime","logTimeDeltaRelativeHuman","new","pSettings","LogProviderBase","LogProviderConsole","ProductVersion","ConfigFile","process","pDependencies","templateProcessor","precedent","addPattern","pTemplateValue","tmpTemplateValue","trim","tmpSeparatorIndex","tmpDefaultValue","tmpEnvironmentVariableName","env","parseSetting","parseString","_process","libPrecedent","libFableSettingsTemplateProcessor","FableSettings","dependencies","settingsTemplateProcessor","_configureEnvTemplating","buildDefaultSettings","merge","base","parse","DefaultConfigFile","pException","settings","_PerformEnvTemplating","NoEnvReplacement","_resolveEnv","tmpKey","_isObject","_deepMergeObjects","toObject","fromObject","forEach","fromValue","toValue","pSettingsFrom","pSettingsTo","tmpSettingsFrom","tmpSettingsTo","tmpSettingsFromCopy","fill","getRandomValues","crypto","msCrypto","generateWhatWGBytes","tmpBuffer","Uint8Array","generateRandomBytes","generate","libRandomByteGenerator","FableUUID","_UUIDModeRandom","UUIDModeRandom","_UUIDLength","UUIDLength","_UUIDRandomDictionary","UUIDDictionary","randomByteGenerator","_HexLookup","bytesToUUID","pBuffer","generateUUIDv4","tmpRandomBytes","generateRandom","tmpUUID","charAt","getUUID","assertPath","TypeError","normalizeStringPosix","allowAboveRoot","res","lastSegmentLength","lastSlash","dots","lastSlashIndex","lastIndexOf","posix","resolve","cwd","resolvedPath","resolvedAbsolute","undefined","isAbsolute","trailingSeparator","joined","arg","relative","from","to","fromStart","fromEnd","fromLen","toStart","toLen","lastCommonSep","fromCode","out","_makeLong","dirname","hasRoot","matchedSlash","basename","ext","start","extIdx","firstNonSlashEnd","extname","startDot","startPart","preDotState","format","pathObject","sep","dir","root","name","_format","ret","delimiter","win32","libWordTree","libStringParser","WordTree","StringParser","ParseTree","pPatternStart","pPatternEnd","pParser","pData","newParserState","pParseTree","Output","OutputBuffer","Pattern","PatternMatch","PatternMatchOutputBuffer","assignNode","pNode","pParserState","appendOutputBuffer","flushOutputBuffer","checkPatternEnd","PatternEnd","PatternStart","Parse","parseCharacter","tmpParserState","addChild","pTree","pPattern","pIndex","tmpLeaf","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","fun","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","drainQueue","timeout","run","marker","runClearTimeout","Item","array","nextTick","title","browser","argv","version","versions","on","addListener","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","chdir","umask","clearImmediate","Function","immediateIds","nextImmediateId","Timeout","id","clearFn","_id","_clearFn","setInterval","clearInterval","close","unref","ref","enroll","item","msecs","_idleTimeoutId","_idleTimeout","unenroll","_unrefActive","active","_onTimeout","libNPMModuleWrapper","_OperationStatePrototype","Metadata","GUID","Hash","Title","Summary","Version","Status","Completed","CompletionProgress","CompletionTimeElapsed","Steps","StepsCompleted","StartTime","EndTime","Errors","Log","pOperationName","pOperationHash","fable","state","writeOperationLog","toUTCString","writeOperationErrors","libFableServiceBase","libDataArithmatic","pOptions","pServiceHash","serviceType","_DataArithmaticLibrary","_MetaTemplateLibrary","options","Matchers","Evaluate","Interpolate","Escaper","Unescaper","GuaranteedNonMatch","templateEscapes","u2028","u2029","renderFunction","templateString","renderTemplate","templateFunction","buildTemplateFunction","pTemplateText","TemplateSource","pCode","decodeURIComponent","TemplateSourceCompiled","libAsyncWaterfall","libAsyncEachLimit","templates","waterfall","eachLimit","extend","pDestinationObject","_len","pSourceObjects","_key","template","serviceManager","instantiateServiceProviderWithoutRegistration","buildHashedTemplate","pTemplateHash","tmpTemplate","instantiateServiceProvider","chunk","pInput","pChunkSize","pChunkCache","tmpInputArray","tmpChunkSize","tmpChunkCache","splice","serviceTypes","services","defaultServices","serviceClasses","addServiceType","pServiceType","pServiceClass","pCustomServiceHash","tmpService","setDefaultServiceInstantiation","ServiceProviderBase","UUID","libFableSettings","libFableUUID","libFableLog","libFableServiceManager","libFableServiceDataArithmatic","libFableServiceTemplate","libFableServiceMetaTemplate","libFableServiceUtility","libFableOperation","settingsManager","libUUID","Dependencies","Operations","DataArithmatic","Utility","createOperation","tmpOperation","getOperation"],"mappings":"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","file":"fable.min.js","sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.Fable = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n'use strict';\n\nvar eachOfLimit = require('async.util.eachoflimit');\nvar withoutIndex = require('async.util.withoutindex');\n\nmodule.exports = function eachLimit(arr, limit, iterator, cb) {\n    return eachOfLimit(limit)(arr, withoutIndex(iterator), cb);\n};\n\n},{\"async.util.eachoflimit\":3,\"async.util.withoutindex\":14}],2:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function(tasks) {\n    function makeCallback(index) {\n        function fn() {\n            if (tasks.length) {\n                tasks[index].apply(null, arguments);\n            }\n            return fn.next();\n        }\n        fn.next = function() {\n            return (index < tasks.length - 1) ? makeCallback(index + 1) : null;\n        };\n        return fn;\n    }\n    return makeCallback(0);\n};\n\n},{}],3:[function(require,module,exports){\nvar once = require('async.util.once');\nvar noop = require('async.util.noop');\nvar onlyOnce = require('async.util.onlyonce');\nvar keyIterator = require('async.util.keyiterator');\n\nmodule.exports = function eachOfLimit(limit) {\n    return function(obj, iterator, cb) {\n        cb = once(cb || noop);\n        obj = obj || [];\n        var nextKey = keyIterator(obj);\n        if (limit <= 0) {\n            return cb(null);\n        }\n        var done = false;\n        var running = 0;\n        var errored = false;\n\n        (function replenish() {\n            if (done && running <= 0) {\n                return cb(null);\n            }\n\n            while (running < limit && !errored) {\n                var key = nextKey();\n                if (key === null) {\n                    done = true;\n                    if (running <= 0) {\n                        cb(null);\n                    }\n                    return;\n                }\n                running += 1;\n                iterator(obj[key], key, onlyOnce(function(err) {\n                    running -= 1;\n                    if (err) {\n                        cb(err);\n                        errored = true;\n                    } else {\n                        replenish();\n                    }\n                }));\n            }\n        })();\n    };\n};\n\n},{\"async.util.keyiterator\":7,\"async.util.noop\":9,\"async.util.once\":10,\"async.util.onlyonce\":11}],4:[function(require,module,exports){\n'use strict';\nvar setImmediate = require('async.util.setimmediate');\nvar restParam = require('async.util.restparam');\n\nmodule.exports = function(fn) {\n    return restParam(function(args) {\n        var callback = args.pop();\n        args.push(function() {\n            var innerArgs = arguments;\n            if (sync) {\n                setImmediate(function() {\n                    callback.apply(null, innerArgs);\n                });\n            } else {\n                callback.apply(null, innerArgs);\n            }\n        });\n        var sync = true;\n        fn.apply(this, args);\n        sync = false;\n    });\n};\n\n},{\"async.util.restparam\":12,\"async.util.setimmediate\":13}],5:[function(require,module,exports){\n'use strict';\n\nmodule.exports = Array.isArray || function isArray(obj) {\n    return Object.prototype.toString.call(obj) === '[object Array]';\n};\n\n},{}],6:[function(require,module,exports){\n'use strict';\n\nvar isArray = require('async.util.isarray');\n\nmodule.exports = function isArrayLike(arr) {\n    return isArray(arr) || (\n        // has a positive integer length property\n        typeof arr.length === 'number' &&\n        arr.length >= 0 &&\n        arr.length % 1 === 0\n    );\n};\n\n},{\"async.util.isarray\":5}],7:[function(require,module,exports){\n'use strict';\n\nvar _keys = require('async.util.keys');\nvar isArrayLike = require('async.util.isarraylike');\n\nmodule.exports = function keyIterator(coll) {\n    var i = -1;\n    var len;\n    var keys;\n    if (isArrayLike(coll)) {\n        len = coll.length;\n        return function next() {\n            i++;\n            return i < len ? i : null;\n        };\n    } else {\n        keys = _keys(coll);\n        len = keys.length;\n        return function next() {\n            i++;\n            return i < len ? keys[i] : null;\n        };\n    }\n};\n\n},{\"async.util.isarraylike\":6,\"async.util.keys\":8}],8:[function(require,module,exports){\n'use strict';\n\nmodule.exports = Object.keys || function keys(obj) {\n    var _keys = [];\n    for (var k in obj) {\n        if (obj.hasOwnProperty(k)) {\n            _keys.push(k);\n        }\n    }\n    return _keys;\n};\n\n},{}],9:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function noop () {};\n\n},{}],10:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function once(fn) {\n    return function() {\n        if (fn === null) return;\n        fn.apply(this, arguments);\n        fn = null;\n    };\n};\n\n},{}],11:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function only_once(fn) {\n    return function() {\n        if (fn === null) throw new Error('Callback was already called.');\n        fn.apply(this, arguments);\n        fn = null;\n    };\n};\n\n},{}],12:[function(require,module,exports){\n'use strict';\nmodule.exports = function restParam(func, startIndex) {\n    startIndex = startIndex == null ? func.length - 1 : +startIndex;\n    return function() {\n        var length = Math.max(arguments.length - startIndex, 0);\n        var rest = new Array(length);\n        for (var index = 0; index < length; index++) {\n            rest[index] = arguments[index + startIndex];\n        }\n        switch (startIndex) {\n            case 0:\n                return func.call(this, rest);\n            case 1:\n                return func.call(this, arguments[0], rest);\n        }\n    };\n};\n\n},{}],13:[function(require,module,exports){\n(function (setImmediate){(function (){\n'use strict';\n\nvar _setImmediate = typeof setImmediate === 'function' && setImmediate;\nvar fallback = function(fn) {\n    setTimeout(fn, 0);\n};\n\nmodule.exports = function setImmediate(fn) {\n    // not a direct alias for IE10 compatibility\n    return (_setImmediate || fallback)(fn);\n};\n\n}).call(this)}).call(this,require(\"timers\").setImmediate)\n\n},{\"timers\":34}],14:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function withoutIndex(iterator) {\n    return function(value, index, callback) {\n        return iterator(value, callback);\n    };\n};\n\n},{}],15:[function(require,module,exports){\n'use strict';\n\nvar once = require('async.util.once');\nvar noop = require('async.util.noop');\nvar isArray = require('async.util.isarray');\nvar restParam = require('async.util.restparam');\nvar ensureAsync = require('async.util.ensureasync');\nvar iterator = require('async.iterator');\n\nmodule.exports = function(tasks, cb) {\n    cb = once(cb || noop);\n    if (!isArray(tasks)) return cb(new Error('First argument to waterfall must be an array of functions'));\n    if (!tasks.length) return cb();\n\n    function wrapIterator(iterator) {\n        return restParam(function(err, args) {\n            if (err) {\n                cb.apply(null, [err].concat(args));\n            } else {\n                var next = iterator.next();\n                if (next) {\n                    args.push(wrapIterator(next));\n                } else {\n                    args.push(cb);\n                }\n                ensureAsync(iterator).apply(null, args);\n            }\n        });\n    }\n    wrapIterator(iterator(tasks))();\n};\n\n},{\"async.iterator\":2,\"async.util.ensureasync\":4,\"async.util.isarray\":5,\"async.util.noop\":9,\"async.util.once\":10,\"async.util.restparam\":12}],16:[function(require,module,exports){\n\n},{}],17:[function(require,module,exports){\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\n/**\n* Data Arithmatic\n*\n* @class DataArithmatic\n*/\nclass DataArithmatic\n{\n\tconstructor()\n\t{\n\t\t// Regular Expressions (so they don't have to be recompiled every time)\n\t\t// These could be defined as static, but I'm not sure if that will work with browserify ... and specifically the QT browser.\n\t\tthis._Regex_formatterInsertCommas = /.{1,3}/g;\n\t\t// Match Function:\n\t\t// function(pMatch, pSign, pZeros, pBefore, pDecimal, pAfter)\n\t\t// Thoughts about below:   /^([+-]?)(0*)(\\d+)(\\.(\\d+))?$/;\n\t\tthis._Regex_formatterAddCommasToNumber = /^([-+]?)(0?)(\\d+)(.?)(\\d+)$/g;\n\t\tthis._Regex_formatterDollarsRemoveCommas = /,/gi;\n\t\tthis._Regex_formatterCleanNonAlpha = /[^a-z0-9]/gi;\n\n\t\t// TODO: Potentially pull these in from a configuration.\n\t\t// TODO: Use locale data for this if it's defaults all the way down.\n\t\tthis._Value_MoneySign_Currency = '$';\n\t\tthis._Value_NaN_Currency = '--';\n\t\tthis._Value_GroupSeparator_Number = ',';\n\n\t\tthis._Value_Prefix_StringHash = 'HSH';\n\t\tthis._Value_Clean_formatterCleanNonAlpha = '_';\n\n\t\tthis._UseEngineStringStartsWith = (typeof(String.prototype.startsWith) === 'function');\n\t\tthis._UseEngineStringEndsWith = (typeof(String.prototype.endsWith) === 'function');\n\t}\n\n\n\t/*************************************************************************\n\t * String Manipulation and Comparison Functions\n\t *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/\n\n\t/**\n\t * Reverse a string\n\t *\n\t * @param {string} pString - The string to reverse\n\t * @returns {string}\n\t */\n\tstringReverse (pString)\n\t{\n\t\t// TODO: Benchmark if there are faster ways we want to do this with all the newer JS stuff\n\t\t//       ... and if it will work with browserify in a clean way.\n\t    return pString.split('').reverse().join('');\n\t}\n\n\t/**\n\t * Test if a string starts with a given substring.\n\t *\n\t * @param {*} pString\n\t * @param {*} pSearchString\n\t * @param {*} pStartIndex\n\t * @returns {*}\n\t */\n\tstringStartsWith (pString, pSearchString, pStartIndex)\n\t{\n\t\tif (this._UseEngineStringStartsWith)\n\t\t{\n\t\t\treturn pString.startsWith(pSearchString, pStartIndex);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.stringStartsWith_Polyfill.call(pString, pSearchString, pStartIndex);\n\t\t}\n\t}\n\n\t/**\n\t * Check if a string starts with a given substring.  This is a safe polyfill for the ES6 string.startsWith() function.\n\t *\n\t * @param {*} pSearchString - The string to search for\n\t * @param {*} pStartIndex - The index to start the search at\n\t * @returns {boolean}\n\t */\n\tstringStartsWith_Polyfill (pSearchString, pStartIndex)\n\t{\n\t\treturn this.slice(pStartIndex || 0, pSearchString.length) === pSearchString;\n\t}\n\n\t/**\n\t * Test if a string starts with a given substring.\n\t *\n\t * @param {*} pString\n\t * @param {*} pSearchString\n\t * @param {*} pEndIndex\n\t * @returns {*}\n\t */\n\tstringEndsWith (pString, pSearchString, pEndIndex)\n\t{\n\t\tif (this._UseEngineStringEndsWith)\n\t\t{\n\t\t\treturn pString.endsWith(pSearchString, pEndIndex);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.stringEndsWith_Polyfill.call(pString, pSearchString, pEndIndex);\n\t\t}\n\t}\n\n\t/**\n\t * Check if a string starts with a given substring.  This is a safe polyfill for the ES6 string.startsWith() function.\n\t *\n\t * @param {*} pSearchString - The string to search for\n\t * @param {*} pEndIndex - The index to end the search at\n\t * @returns {boolean}\n\t */\n\tstringEndsWith_Polyfill (pSearchString, pEndIndex)\n\t{\n\t\t// This works much better than >= because\n\t\t// it compensates for NaN:\n\t\tif (!(pEndIndex < this.length))\n\t\t{\n\t\t\tpEndIndex = this.length;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpEndIndex |= 0; // round position\n\t\t}\n\t\treturn this.substr(pEndIndex - pSearchString.length, pSearchString.length) === pSearchString;\n\t}\n\n\t/**\n\t * Generate an insecure string hash.  Not meant to be secure, just a quick way to generate a hash for a string.  This is not a cryptographic hash.  Additional warranty and disclaimer ... this is not for passwords!\n\t *\n\t * @param {string} pString\n\t * @returns {string}\n\t */\n\tinsecureStringHash (pString)\n\t{\n\t    let tmpHash = 0;\n\t    let tmpStringLength = pString.length;\n\t    let tmpCharacterIndex = 0;\n\n\t    while (tmpCharacterIndex < tmpStringLength)\n\t    {\n\t        tmpHash = (tmpHash << 5) - tmpHash + pString.charCodeAt(tmpCharacterIndex++) | 0;\n\t    }\n\n\t    return `${this._Value_Prefix_StringHash}${tmpHash}`;\n\t}\n\n\t/**\n\t * Clean wrapping characters if they exist consistently around the string.  If they do not, the string is returned unchanged.\n\t *\n\t * @param {string} pWrapCharacter - The character expected as the wrapping character\n\t * @param {string} pString - the string to clean\n\t * @returns {string}\n\t */\n\tcleanEnclosureWrapCharacters (pWrapCharacter, pString)\n\t{\n\t\t// # Use case from ManyFest DSL:\n\t\t//\n\t\t// When a boxed property is passed in, it should have quotes of some\n\t\t// kind around it.\n\t\t//\n\t\t// For instance:\n\t\t// \t\tMyValues['Name']\n\t\t// \t\tMyValues[\"Age\"]\n\t\t// \t\tMyValues[`Cost`]\n\t\t//\n\t\t// This function is necessary to remove the wrapping quotes before object\n\t\t// resolution can occur.\n\t\tif (pString.startsWith(pWrapCharacter) && pString.endsWith(pWrapCharacter))\n\t\t{\n\t\t\treturn pString.substring(1, pString.length - 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn pString;\n\t\t}\n\t}\n\n\t/**\n\t *\n\t * @param {*} pString\n\t * @returns\n\t */\n\tcleanNonAlphaCharacters (pString)\n\t{\n\t    if ((typeof(pString) == 'string') && (pString != ''))\n\t    {\n\t        return pString.replace(this._Regex_formatterCleanNonAlpha, this._Value_Clean_formatterCleanNonAlpha);\n\t    }\n\t}\n\n\n\t/*************************************************************************\n\t * Number Formatting Functions\n\t *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/\n\n\t/**\n\t * Insert commas every 3 characters from the right.  Used by formatterAddCommasToNumber().\n\t *\n\t * @param {*} pString\n\t * @returns {*}\n\t */\n\tformatterInsertCommas (pString)\n\t{\n\t    // Reverse, because it's easier to do things from the left, given arbitrary digit counts\n\t    let tmpReversed = this.stringReverse(pString);\n\t    // Add commas every three characters\n\t    let tmpReversedWithCommas = tmpReversed.match(this._Regex_formatterInsertCommas).join(',');\n\t    // Reverse again (back to normal direction)\n\t    return this.stringReverse(tmpReversedWithCommas);\n\t}\n\n\tprocessAddCommasToNumberRegex(pMatch, pSign, pZeros, pBefore, pDecimal, pAfter)\n\t{\n\t\t// If there was no decimal, the last capture grabs the final digit, so\n\t\t// we have to put it back together with the 'before' substring\n\t\treturn pSign + (pDecimal ? this.formatterInsertCommas(pBefore) + pDecimal + pAfter : this.formatterInsertCommas(pBefore + pAfter));\n\t}\n\n\t/**\n\t * Add Commas to a Number for readability.\n\t *\n\t * @param {*} pNumber\n\t * @returns {string}\n\t */\n\tformatterAddCommasToNumber (pNumber)\n\t{\n\t    // If the regex doesn't match, `replace` returns the string unmodified\n\t    return (pNumber.toString()).replace\n\t    (\n\t\t\tthis._Regex_formatterAddCommasToNumber,\n\t        this.processAddCommasToNumberRegex.bind(this)\n\t    );\n\t}\n\n\t/**\n\t * This will take a number and format it as a dollar string.  It will also add commas to the number.  If the number is not a number, it will return '--'.\n\t *\n\t * @param {*} pValue\n\t * @returns {string}\n\t */\n\tformatterDollars (pValue)\n\t{\n\t    let tmpDollarAmount = parseFloat(pValue).toFixed(2);\n\n\t    if (isNaN(tmpDollarAmount))\n\t    {\n\t        // Try again and see if what was passed in was a dollars string.\n\t        if (typeof(pValue) == 'string')\n\t        {\n\t\t\t\t// TODO: Better rounding function?  This is a hack to get rid of the currency symbol and commas.\n\t            tmpDollarAmount = parseFloat(pValue.replace(this._Value_MoneySign_Currency,'').replace(this._Regex_formatterDollarsRemoveCommas,'')).toFixed(2);\n\t        }\n\t\t\t// If we didn't get a number, return the \"not a number\" string.\n\t        if (isNaN(tmpDollarAmount))\n\t        {\n\t            return this._Value_NaN_Currency;\n\t        }\n\t    }\n\n\t    // TODO: Get locale data and use that for this stuff.\n\t    return `$${this.formatterAddCommasToNumber(tmpDollarAmount)}`;\n\t}\n\n\t/**\n\t * Round a number to a certain number of digits.  If the number is not a number, it will return 0.  If no digits are specified, it will default to 2 significant digits.\n\t *\n\t * @param {*} pValue\n\t * @param {number} pDigits\n\t * @returns {string}\n\t */\n\tformatterRoundNumber (pValue, pDigits)\n\t{\n\t    let tmpDigits = (typeof(pDigits) == 'undefined') ? 2 : pDigits;\n\n\t    let tmpValue = parseFloat(pValue).toFixed(tmpDigits);\n\t    if (isNaN(tmpValue))\n\t    {\n\t        let tmpZed = 0;\n\t        return tmpZed.toFixed(tmpDigits);\n\t    }\n\t    else\n\t    {\n\t        return tmpValue;\n\t    }\n\t}\n\n\n\t/*************************************************************************\n\t * String Tokenization Functions\n\t *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/\n\n\t/**\n\t * Return the string before the matched substring.\n\t *\n\t * If the substring is not found, the entire string is returned.  This only deals with the *first* match.\n\t *\n\t * @param {string} pString\n\t * @param {string} pMatch\n\t * @returns {string}\n\t */\n\tstringBeforeMatch (pString, pMatch)\n\t{\n\t\treturn pString.split(pMatch)[0];\n\t}\n\n\t/**\n\t * Return the string after the matched substring.\n\t *\n\t * If the substring is not found, an empty string is returned.  This only deals with the *first* match.\n\t *\n\t * @param {string} pString\n\t * @param {string} pMatch\n\t * @returns {string}\n\t */\n\tstringAfterMatch (pString, pMatch)\n\t{\n\t    let tmpStringSplitLocation = pString.indexOf(pMatch);\n\n\t\tif ((tmpStringSplitLocation < 0) || ((tmpStringSplitLocation + pMatch.length) >= pString.length))\n\t    {\n\t        return '';\n\t    }\n\n\t    return pString.substring(tmpStringSplitLocation + pMatch.length);\n\t}\n\n\t/**\n\t * Count the number of enclosures in a string based on the start and end characters.\n\t *\n\t * If no start or end characters are specified, it will default to parentheses.  If the string is not a string, it will return 0.\n\t *\n\t * @param {string} pString\n\t * @param {string} pEnclosureStart\n\t * @param {string} pEnclosureEnd\n\t * @returns the count of full in the string\n\t */\n\tstringCountEnclosures (pString, pEnclosureStart, pEnclosureEnd)\n\t{\n\t    let tmpString = (typeof(pString) == 'string') ? pString : '';\n\t    let tmpEnclosureStart = (typeof(pEnclosureStart) == 'string') ? pEnclosureStart : '(';\n\t    let tmpEnclosureEnd = (typeof(pEnclosureEnd) == 'string') ? pEnclosureEnd : ')';\n\n\t    let tmpEnclosureCount = 0;\n\t    let tmpEnclosureDepth = 0;\n\t    for (let i = 0; i < tmpString.length; i++)\n\t    {\n\t        // This is the start of an enclosure\n\t        if (tmpString[i] == tmpEnclosureStart)\n\t        {\n\t            if (tmpEnclosureDepth == 0)\n\t            {\n\t                tmpEnclosureCount++;\n\t            }\n\t            tmpEnclosureDepth++;\n\t        }\n\t        else if (tmpString[i] == tmpEnclosureEnd)\n\t        {\n\t            tmpEnclosureDepth--;\n\t        }\n\t    }\n\n\t    return tmpEnclosureCount;\n\t}\n\n\n\t/**\n\t * Get the value of the enclosure at the specified index.\n\t *\n\t * If the index is not a number, it will default to 0.  If the string is not a string, it will return an empty string.  If the enclosure is not found, it will return an empty string.  If the enclosure\n\t *\n\t * @param {string} pString\n\t * @param {number} pEnclosureIndexToGet\n\t * @param {string} pEnclosureStart\n\t * @param {string}} pEnclosureEnd\n\t * @returns {string}\n\t */\n\tstringGetEnclosureValueByIndex (pString, pEnclosureIndexToGet, pEnclosureStart, pEnclosureEnd)\n\t{\n\t    let tmpString = (typeof(pString) == 'string') ? pString : '';\n\t    let tmpEnclosureIndexToGet = (typeof(pEnclosureIndexToGet) == 'number') ? pEnclosureIndexToGet : 0;\n\t    let tmpEnclosureStart = (typeof(pEnclosureStart) == 'string') ? pEnclosureStart : '(';\n\t    let tmpEnclosureEnd = (typeof(pEnclosureEnd) == 'string') ? pEnclosureEnd : ')';\n\n\t    let tmpEnclosureCount = 0;\n\t    let tmpEnclosureDepth = 0;\n\n\t\tlet tmpMatchedEnclosureIndex = false;\n\t    let tmpEnclosedValueStartIndex = 0;\n\t    let tmpEnclosedValueEndIndex = 0;\n\n\t    for (let i = 0; i < tmpString.length; i++)\n\t    {\n\t        // This is the start of an enclosure\n\t        if (tmpString[i] == tmpEnclosureStart)\n\t        {\n\t            tmpEnclosureDepth++;\n\n\t\t\t\t// Only count enclosures at depth 1, but still this parses both pairs of all of them.\n\t\t\t\tif (tmpEnclosureDepth == 1)\n\t\t\t\t{\n\t\t\t\t\ttmpEnclosureCount++;\n\t\t\t\t\tif (tmpEnclosureIndexToGet == (tmpEnclosureCount - 1))\n\t\t\t\t\t{\n\t\t\t\t\t\t// This is the start of *the* enclosure\n\t\t\t\t\t\ttmpMatchedEnclosureIndex = true;\n\t\t\t\t\t\ttmpEnclosedValueStartIndex = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t        }\n\t\t\t// This is the end of an enclosure\n\t        else if (tmpString[i] == tmpEnclosureEnd)\n\t        {\n\t            tmpEnclosureDepth--;\n\n\t\t\t\t// Again, only count enclosures at depth 1, but still this parses both pairs of all of them.\n\t\t\t\tif ((tmpEnclosureDepth == 0) &&\n\t\t\t\t\ttmpMatchedEnclosureIndex &&\n\t\t\t\t\t(tmpEnclosedValueEndIndex <= tmpEnclosedValueStartIndex))\n\t\t\t\t{\n\t\t\t\t\ttmpEnclosedValueEndIndex = i;\n\t\t\t\t\ttmpMatchedEnclosureIndex = false;\n\t\t\t\t}\n\t        }\n\t    }\n\n\t    if (tmpEnclosureCount <= tmpEnclosureIndexToGet)\n\t    {\n\t\t\t// Return an empty string if the enclosure is not found\n\t        return '';\n\t    }\n\n\t    if ((tmpEnclosedValueEndIndex > 0) && (tmpEnclosedValueEndIndex > tmpEnclosedValueStartIndex))\n\t    {\n\t        return tmpString.substring(tmpEnclosedValueStartIndex+1, tmpEnclosedValueEndIndex);\n\t    }\n\t    else\n\t    {\n\t        return tmpString.substring(tmpEnclosedValueStartIndex+1);\n\t    }\n\t}\n\n\n\t/**\n\t * Remove an enclosure from a string based on the index of the enclosure.\n\t *\n\t * @param {string} pString\n\t * @param {number} pEnclosureIndexToRemove\n\t * @param {number} pEnclosureStart\n\t * @param {number} pEnclosureEnd\n\t * @returns {string}\n\t */\n\tstringRemoveEnclosureByIndex (pString, pEnclosureIndexToRemove, pEnclosureStart, pEnclosureEnd)\n\t{\n\t    let tmpString = (typeof(pString) == 'string') ? pString : '';\n\t    let tmpEnclosureIndexToRemove = (typeof(pEnclosureIndexToRemove) == 'number') ? pEnclosureIndexToRemove : 0;\n\t    let tmpEnclosureStart = (typeof(pEnclosureStart) == 'string') ? pEnclosureStart : '(';\n\t    let tmpEnclosureEnd = (typeof(pEnclosureEnd) == 'string') ? pEnclosureEnd : ')';\n\n\t    let tmpEnclosureCount = 0;\n\t    let tmpEnclosureDepth = 0;\n\n\t\tlet tmpMatchedEnclosureIndex = false;\n\t    let tmpEnclosureStartIndex = 0;\n\t    let tmpEnclosureEndIndex = 0;\n\n\t    for (let i = 0; i < tmpString.length; i++)\n\t    {\n\t        // This is the start of an enclosure\n\t        if (tmpString[i] == tmpEnclosureStart)\n\t        {\n\t            tmpEnclosureDepth++;\n\n\t            if (tmpEnclosureDepth == 1)\n\t            {\n\t                tmpEnclosureCount++;\n\t\t\t\t\tif (tmpEnclosureIndexToRemove == (tmpEnclosureCount - 1))\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpMatchedEnclosureIndex = true;\n\t\t\t\t\t\ttmpEnclosureStartIndex = i;\n\t\t\t\t\t}\n\t            }\n\t        }\n\t        else if (tmpString[i] == tmpEnclosureEnd)\n\t        {\n\t            tmpEnclosureDepth--;\n\n\t\t\t\tif ((tmpEnclosureDepth == 0) &&\n\t\t\t\t\ttmpMatchedEnclosureIndex &&\n\t\t\t\t\t(tmpEnclosureEndIndex <= tmpEnclosureStartIndex))\n\t\t\t\t{\n\t\t\t\t\ttmpEnclosureEndIndex = i;\n\t\t\t\t\ttmpMatchedEnclosureIndex = false;\n\t\t\t\t}\n\t        }\n\t    }\n\n\t    if (tmpEnclosureCount <= tmpEnclosureIndexToRemove)\n\t    {\n\t        return tmpString;\n\t    }\n\n\t    let tmpReturnString = '';\n\n\t    if (tmpEnclosureStartIndex > 1)\n\t    {\n\t        tmpReturnString = tmpString.substring(0, tmpEnclosureStartIndex);\n\t    }\n\n\t    if ((tmpString.length > (tmpEnclosureEndIndex + 1)) && (tmpEnclosureEndIndex > tmpEnclosureStartIndex))\n\t    {\n\t        tmpReturnString += tmpString.substring(tmpEnclosureEndIndex+1);\n\t    }\n\n\t    return tmpReturnString;\n\t}\n}\n\nmodule.exports = DataArithmatic;\n},{}],18:[function(require,module,exports){\n/**\n* Base Logger Class\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\nclass BaseLogger\n{\n\tconstructor(pLogStreamSettings, pFableLog)\n\t{\n\t\t// This should not possibly be able to be instantiated without a settings object\n\t\tthis._Settings = (typeof(pLogStreamSettings) == 'object') ? pLogStreamSettings : {};\n\n\t\t// The base logger does nothing but associate a UUID with itself\n\t\t// We added this as the mechanism for tracking loggers to allow multiple simultaneous streams\n\t\t// to the same provider.\n\t\tthis.loggerUUID = this.generateInsecureUUID();\n\n\t\t// Eventually we can use this array to ompute which levels the provider allows.\n\t\t// For now it's just used to precompute some string concatenations.\n\t\tthis.levels = (\n\t\t\t[\n\t\t\t\t\"trace\",\n\t\t\t\t\"debug\",\n\t\t\t\t\"info\",\n\t\t\t\t\"warn\",\n\t\t\t\t\"error\",\n\t\t\t\t\"fatal\"\n\t\t\t]);\n\t}\n\n\t// This is meant to generate programmatically insecure UUIDs to identify loggers\n\tgenerateInsecureUUID()\n\t{\n\t\tlet tmpDate = new Date().getTime();\n\t\tlet tmpUUID = 'LOGSTREAM-xxxxxx-yxxxxx'.replace(/[xy]/g,\n\t\t\t\t(pCharacter) =>\n\t\t\t\t{\n\t\t\t\t\t// Funny algorithm from w3resource that is twister-ish without the deep math and security\n\t\t\t\t\t// ..but good enough for unique log stream identifiers\n\t\t\t\t\tlet tmpRandomData = (tmpDate + Math.random()*16)%16 | 0;\n\t\t\t\t\ttmpDate = Math.floor(tmpDate/16);\n\n\t\t\t\t\treturn (pCharacter =='x' ? tmpRandomData : (tmpRandomData&0x3|0x8)).toString(16);\n\t\t\t\t});\n\t\treturn tmpUUID;\n\t}\n\n\tinitialize()\n\t{\n\t\t// No operation.\n\t}\n\n\ttrace(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"trace\", pLogText, pLogObject);\n\t}\n\n\tdebug(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"debug\", pLogText, pLogObject);\n\t}\n\n\tinfo(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"info\", pLogText, pLogObject);\n\t}\n\n\twarn(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"warn\", pLogText, pLogObject);\n\t}\n\n\terror(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"error\", pLogText, pLogObject);\n\t}\n\n\tfatal(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"fatal\", pLogText, pLogObject);\n\t}\n\n\twrite(pLogLevel, pLogText, pLogObject)\n\t{\n\t\t// The base logger does nothing.\n\t\treturn true;\n\t}\n}\n\nmodule.exports = BaseLogger;\n\n},{}],19:[function(require,module,exports){\n/**\n* Default Logger Provider Function\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\n// Return the providers that are available without extensions loaded\nvar getDefaultProviders = () =>\n{\n\tlet tmpDefaultProviders = {};\n\n\ttmpDefaultProviders.console = require('./Fable-Log-Logger-Console.js');\n\n\ttmpDefaultProviders.default = tmpDefaultProviders.console;\n\n\treturn tmpDefaultProviders;\n}\n\nmodule.exports = getDefaultProviders();\n},{\"./Fable-Log-Logger-Console.js\":21}],20:[function(require,module,exports){\nmodule.exports=[\n    {\n        \"loggertype\": \"console\",\n        \"streamtype\": \"console\",\n        \"level\": \"trace\"\n    }\n]\n},{}],21:[function(require,module,exports){\nlet libBaseLogger = require('./Fable-Log-BaseLogger.js');\n\nclass ConsoleLogger extends libBaseLogger\n{\n\tconstructor(pLogStreamSettings, pFableLog)\n\t{\n\t\tsuper(pLogStreamSettings);\n\n\t\tthis._ShowTimeStamps = this._Settings.hasOwnProperty('showtimestamps') ? (this._Settings.showtimestamps == true) : true;\n\t\tthis._FormattedTimeStamps = this._Settings.hasOwnProperty('formattedtimestamps') ? (this._Settings.formattedtimestamps == true) : true;\n\n\t\tthis._ContextMessage = this._Settings.hasOwnProperty('Context') ? `(${this._Settings.Context})` : \n\t\t\t\t\t\t\t\tpFableLog._Settings.hasOwnProperty('Product') ? `(${pFableLog._Settings.Product})` :\n\t\t\t\t\t\t\t\t'Unnamed_Log_Context';\n\n\t\t// Allow the user to decide what gets output to the console\n\t\tthis._OutputLogLinesToConsole = this._Settings.hasOwnProperty('outputloglinestoconsole') ? this._Settings.outputloglinestoconsole : true;\n\t\tthis._OutputObjectsToConsole = this._Settings.hasOwnProperty('outputobjectstoconsole') ? this._Settings.outputobjectstoconsole : true;\n\n\t\t// Precompute the prefix for each level\n\t\tthis.prefixCache = {};\n\t\tfor (let i = 0; i <= this.levels.length; i++)\n\t\t{\n\t\t\tthis.prefixCache[this.levels[i]] = `[${this.levels[i]}] ${this._ContextMessage}: `;\n\n\t\t\tif (this._ShowTimeStamps)\n\t\t\t{\n\t\t\t\t// If there is a timestamp we need a to prepend space before the prefixcache string, since the timestamp comes first\n\t\t\t\tthis.prefixCache[this.levels[i]] = ' '+this.prefixCache[this.levels[i]];\n\t\t\t}\n\t\t}\n\t}\n\n\twrite(pLevel, pLogText, pObject)\n\t{\n\t\tlet tmpTimeStamp = '';\n\t\tif (this._ShowTimeStamps && this._FormattedTimeStamps)\n\t\t{\n\t\t\ttmpTimeStamp = (new Date()).toISOString();\n\t\t}\n\t\telse if (this._ShowTimeStamps)\n\t\t{\n\t\t\ttmpTimeStamp = +new Date();\n\t\t}\n\n\t\tlet tmpLogLine = `${tmpTimeStamp}${this.prefixCache[pLevel]}${pLogText}`;\n\n\t\tif (this._OutputLogLinesToConsole)\n\t\t{\n\t\t\tconsole.log(tmpLogLine);\n\t\t}\n\n\t\t// Write out the object on a separate line if it is passed in\n\t\tif (this._OutputObjectsToConsole && (typeof(pObject) !== 'undefined'))\n\t\t{\n\t\t\tconsole.log(JSON.stringify(pObject, null, 2));\n\t\t}\n\n\t\t// Provide an easy way to be overridden and be consistent\n\t\treturn tmpLogLine;\n\t}\n}\n\nmodule.exports = ConsoleLogger;\n},{\"./Fable-Log-BaseLogger.js\":18}],22:[function(require,module,exports){\nconst libConsoleLog = require('./Fable-Log-Logger-Console.js');\nconst libFS = require('fs');\nconst libPath = require('path');\n\nclass SimpleFlatFileLogger extends libConsoleLog\n{\n\tconstructor(pLogStreamSettings, pFableLog)\n\t{\n\t\tsuper(pLogStreamSettings, pFableLog);\n\n\t\t// If a path isn't provided for the logfile, it tries to use the ProductName or Context\n\t\tthis.logFileRawPath = (this._Settings.hasOwnProperty('path')) ? this._Settings.path : `./${this._ContextMessage}.log`;\n\t\tthis.logFilePath = libPath.normalize(this.logFileRawPath);\n\n\t\tthis.logFileStreamOptions = (this._Settings.hasOwnProperty('fileStreamoptions')) ? this._Settings.fileStreamOptions : (\n\t\t\t{\n\t\t\t\t\"flags\": \"a\",\n\t\t\t\t\"encoding\": \"utf8\"\n\t\t\t})\n\n\t\tthis.fileWriter = libFS.createWriteStream(this.logFilePath, this.logFileStreamOptions);\n\n\t\tthis.activelyWriting = false;\n\n\t\tthis.logLineStrings = [];\n\t\tthis.logObjectStrings = [];\n\n\t\tthis.defaultWriteCompleteCallback = ()=>{};\n\t\tthis.defaultBufferFlushCallback = ()=>{};\n\t}\n\n\tcloseWriter(fCloseComplete)\n\t{\n\t\tlet tmpCloseComplete = (typeof(fCloseComplete) == 'function') ? fCloseComplete : ()=>{};\n\t\tif (this.fileWriter)\n\t\t{\n\t\t\tthis.fileWriter.end('\\n');\n\t\t\treturn this.fileWriter.once('finish', tmpCloseComplete.bind(this));\n\t\t}\n\t};\n\n\tcompleteBufferFlushToLogFile(fFlushComplete)\n\t{\n\t\tthis.activelyWriting = false;\n\t\tlet tmpFlushComplete = (typeof(fFlushComplete) == 'function') ? fFlushComplete : this.defaultBufferFlushCallback;\n\n\t\tif (this.logLineStrings.length > 0)\n\t\t{\n\t\t\tthis.flushBufferToLogFile(tmpFlushComplete);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn tmpFlushComplete();\n\t\t}\n\t}\n\n\tflushBufferToLogFile(fFlushComplete)\n\t{\n\t\tif (!this.activelyWriting)\n\t\t{\n\t\t\t// Only want to be writing one thing at a time....\n\t\t\tthis.activelyWriting = true;\n\n\t\t\tlet tmpFlushComplete = (typeof(fFlushComplete) == 'function') ? fFlushComplete : this.defaultBufferFlushCallback;\n\n\t\t\t// Get the current buffer arrays.  These should always have matching number of elements.\n\t\t\tlet tmpLineStrings = this.logLineStrings;\n\t\t\tlet tmpObjectStrings = this.logObjectStrings;\n\n\t\t\t// Reset these to be filled while we process this queue...\n\t\t\tthis.logLineStrings = [];\n\t\t\tthis.logObjectStrings = [];\n\n\t\t\t// This is where we will put each line before writing it to the file...\n\t\t\tlet tmpConstructedBufferOutputString = '';\n\n\t\t\tfor (let i = 0; i < tmpLineStrings.length; i++)\n\t\t\t{\n\t\t\t\t// TODO: Windows Newline?   ....... yo no se!\n\t\t\t\ttmpConstructedBufferOutputString += `${tmpLineStrings[i]}\\n`;\n\t\t\t\tif (tmpObjectStrings[i] !== false)\n\t\t\t\t{\n\t\t\t\t\ttmpConstructedBufferOutputString += `${tmpObjectStrings[i]}\\n`;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!this.fileWriter.write(tmpConstructedBufferOutputString, 'utf8'))\n\t\t\t{\n\t\t\t\t// If the streamwriter returns false, we need to wait for it to drain.\n\t\t\t\tthis.fileWriter.once('drain', this.completeBufferFlushToLogFile.bind(this, tmpFlushComplete));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn this.completeBufferFlushToLogFile(tmpFlushComplete);\n\t\t\t}\n\t\t}\n\t}\n\n\twrite(pLevel, pLogText, pObject)\n\t{\n\t\tlet tmpLogLine = super.write(pLevel, pLogText, pObject);\n\n\t\t// Use a very simple array as the write buffer\n\t\tthis.logLineStrings.push(tmpLogLine);\n\n\t\t// Write out the object on a separate line if it is passed in\n\t\tif (typeof(pObject) !== 'undefined')\n\t\t{\n\t\t\tthis.logObjectStrings.push(JSON.stringify(pObject, null, 4));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logObjectStrings.push(false);\n\t\t}\n\n\t\tthis.flushBufferToLogFile();\n\t}\n}\n\nmodule.exports = SimpleFlatFileLogger;\n},{\"./Fable-Log-Logger-Console.js\":21,\"fs\":16,\"path\":29}],23:[function(require,module,exports){\n/**\n* Fable Logging Add-on\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable Logger\n*/\n\n/**\n* Fable Solution Log Wrapper Main Class\n*\n* @class FableLog\n* @constructor\n*/\nclass FableLog\n{\n\tconstructor(pFableSettings, pFable)\n\t{\n\t\tlet tmpSettings = (typeof(pFableSettings) === 'object') ? pFableSettings : {}\n\t\tthis._Settings = tmpSettings;\n\n\t\tthis._Providers = require('./Fable-Log-DefaultProviders-Node.js');\n\n\t\tthis._StreamDefinitions = (tmpSettings.hasOwnProperty('LogStreams')) ? tmpSettings.LogStreams : require('./Fable-Log-DefaultStreams.json');\n\n\t\tthis.logStreams = [];\n\n\t\t// This object gets decorated for one-time instantiated providers that\n\t\t//  have multiple outputs, such as bunyan.\n\t\tthis.logProviders = {};\n\n\t\t// A hash list of the GUIDs for each log stream, so they can't be added to the set more than one time\n\t\tthis.activeLogStreams = {};\n\n\t\tthis.logStreamsTrace = [];\n\t\tthis.logStreamsDebug = [];\n\t\tthis.logStreamsInfo = [];\n\t\tthis.logStreamsWarn = [];\n\t\tthis.logStreamsError = [];\n\t\tthis.logStreamsFatal = [];\n\n\t\tthis.datumDecorator = (pDatum) => pDatum;\n\n\t\tthis.uuid = (typeof(tmpSettings.Product) === 'string') ? tmpSettings.Product : 'Default';\n\t}\n\n\taddLogger(pLogger, pLevel)\n\t{\n\t\t// Bail out if we've already created one.\n\t\tif (this.activeLogStreams.hasOwnProperty(pLogger.loggerUUID))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// Add it to the streams and to the mutex\n\t\tthis.logStreams.push(pLogger);\n\t\tthis.activeLogStreams[pLogger.loggerUUID] = true;\n\n\t\t// Make sure a kosher level was passed in\n\t\tswitch (pLevel)\n\t\t{\n\t\t\tcase 'trace':\n\t\t\t\tthis.logStreamsTrace.push(pLogger);\n\t\t\tcase 'debug':\n\t\t\t\tthis.logStreamsDebug.push(pLogger);\n\t\t\tcase 'info':\n\t\t\t\tthis.logStreamsInfo.push(pLogger);\n\t\t\tcase 'warn':\n\t\t\t\tthis.logStreamsWarn.push(pLogger);\n\t\t\tcase 'error':\n\t\t\t\tthis.logStreamsError.push(pLogger);\n\t\t\tcase 'fatal':\n\t\t\t\tthis.logStreamsFatal.push(pLogger);\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tsetDatumDecorator(fDatumDecorator)\n\t{\n\t\tif (typeof(fDatumDecorator) === 'function')\n\t\t{\n\t\t\tthis.datumDecorator = fDatumDecorator;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.datumDecorator = (pDatum) => pDatum;\n\t\t}\n\t}\n\n\ttrace(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsTrace.length; i++)\n\t\t{\n\t\t\tthis.logStreamsTrace[i].trace(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tdebug(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsDebug.length; i++)\n\t\t{\n\t\t\tthis.logStreamsDebug[i].debug(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tinfo(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsInfo.length; i++)\n\t\t{\n\t\t\tthis.logStreamsInfo[i].info(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\twarn(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsWarn.length; i++)\n\t\t{\n\t\t\tthis.logStreamsWarn[i].warn(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\terror(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsError.length; i++)\n\t\t{\n\t\t\tthis.logStreamsError[i].error(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tfatal(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsFatal.length; i++)\n\t\t{\n\t\t\tthis.logStreamsFatal[i].fatal(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tinitialize()\n\t{\n\t\t// \"initialize\" each logger as defined in the logging parameters\n\t\tfor (let i = 0; i < this._StreamDefinitions.length; i++)\n\t\t{\n\t\t\tlet tmpStreamDefinition = Object.assign({loggertype:'default',streamtype:'console',level:'info'},this._StreamDefinitions[i]);\n\n\t\t\tif (!this._Providers.hasOwnProperty(tmpStreamDefinition.loggertype))\n\t\t\t{\n\t\t\t\tconsole.log(`Error initializing log stream: bad loggertype in stream definition ${JSON.stringify(tmpStreamDefinition)}`);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.addLogger(new this._Providers[tmpStreamDefinition.loggertype](tmpStreamDefinition, this), tmpStreamDefinition.level);\n\t\t\t}\n\t\t}\n\n\t\t// Now initialize each one.\n\t\tfor (let i = 0; i < this.logStreams.length; i++)\n\t\t{\n\t\t\tthis.logStreams[i].initialize();\n\t\t}\n\t}\n\n\tlogTime(pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time';\n\t\tlet tmpTime = new Date();\n\t\tthis.info(`${tmpMessage} ${tmpTime} (epoch ${+tmpTime})`, pDatum);\n\t}\n\n\t// Get a timestamp\n\tgetTimeStamp()\n\t{\n\t\treturn +new Date();\n\t}\n\n\tgetTimeDelta(pTimeStamp)\n\t{\n\t\tlet tmpEndTime = +new Date();\n\t\treturn tmpEndTime-pTimeStamp;\n\t}\n\n\t// Log the delta between a timestamp, and now with a message\n\tlogTimeDelta(pTimeDelta, pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time Measurement';\n\t\tlet tmpDatum = (typeof(pDatum) === 'object') ? pDatum : {};\n\n\t\tlet tmpEndTime = +new Date();\n\n\t\tthis.info(`${tmpMessage} logged at (epoch ${+tmpEndTime}) took (${pTimeDelta}ms)`, pDatum);\n\t}\n\n\tlogTimeDeltaHuman(pTimeDelta, pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time Measurement';\n\n\t\tlet tmpEndTime = +new Date();\n\n\t\tlet tmpMs = parseInt(pTimeDelta%1000);\n\t\tlet tmpSeconds = parseInt((pTimeDelta/1000)%60);\n\t\tlet tmpMinutes = parseInt((pTimeDelta/(1000*60))%60);\n\t\tlet tmpHours = parseInt(pTimeDelta/(1000*60*60));\n\n\t\ttmpMs = (tmpMs < 10) ? \"00\"+tmpMs : (tmpMs < 100) ? \"0\"+tmpMs : tmpMs;\n\t\ttmpSeconds = (tmpSeconds < 10) ? \"0\"+tmpSeconds : tmpSeconds;\n\t\ttmpMinutes = (tmpMinutes < 10) ? \"0\"+tmpMinutes : tmpMinutes;\n\t\ttmpHours = (tmpHours < 10) ? \"0\"+tmpHours : tmpHours;\n\n\t\tthis.info(`${tmpMessage} logged at (epoch ${+tmpEndTime}) took (${pTimeDelta}ms) or (${tmpHours}:${tmpMinutes}:${tmpSeconds}.${tmpMs})`, pDatum);\n\t}\n\n\tlogTimeDeltaRelative(pStartTime, pMessage, pDatum)\n\t{\n\t\tthis.logTimeDelta(this.getTimeDelta(pStartTime), pMessage, pDatum);\n\t}\n\n\tlogTimeDeltaRelativeHuman(pStartTime, pMessage, pDatum)\n\t{\n\t\tthis.logTimeDeltaHuman(this.getTimeDelta(pStartTime), pMessage, pDatum);\n\t}\n}\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new FableLog(pSettings);\n}\n\n\nmodule.exports = FableLog;\nmodule.exports.new = autoConstruct;\nmodule.exports.LogProviderBase = require('./Fable-Log-BaseLogger.js');\nmodule.exports.LogProviderConsole = require('./Fable-Log-Logger-Console.js');\nmodule.exports.LogProviderConsole = require('./Fable-Log-Logger-SimpleFlatFile.js');\n\n},{\"./Fable-Log-BaseLogger.js\":18,\"./Fable-Log-DefaultProviders-Node.js\":19,\"./Fable-Log-DefaultStreams.json\":20,\"./Fable-Log-Logger-Console.js\":21,\"./Fable-Log-Logger-SimpleFlatFile.js\":22}],24:[function(require,module,exports){\nmodule.exports={\n\t\"Product\": \"ApplicationNameHere\",\n\t\"ProductVersion\": \"0.0.0\",\n\n\t\"ConfigFile\": false,\n\n\t\"LogStreams\":\n\t[\n\t\t{\n\t\t\t\"level\": \"trace\"\n\t\t}\n\t]\n}\n\n},{}],25:[function(require,module,exports){\n(function (process){(function (){\n/**\n* Fable Settings Template Processor\n*\n* This class allows environment variables to come in via templated expressions, and defaults to be set.\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable Settings\n*/\n\nclass FableSettingsTemplateProcessor\n{\n\tconstructor(pDependencies)\n\t{\n        // Use a no-dependencies templating engine to parse out environment variables\n\t\tthis.templateProcessor = new pDependencies.precedent();\n\n        // TODO: Make the environment variable wrap expression demarcation characters configurable?\n\t\tthis.templateProcessor.addPattern('${', '}',\n\t\t\t(pTemplateValue)=>\n\t\t\t{\n\t\t\t\tlet tmpTemplateValue = pTemplateValue.trim();\n\n\t\t\t\tlet tmpSeparatorIndex = tmpTemplateValue.indexOf('|');\n\n\t\t\t\t// If there is no pipe, the default value will end up being whatever the variable name is.\n\t\t\t\tlet tmpDefaultValue = tmpTemplateValue.substring(tmpSeparatorIndex+1);\n\n\t\t\t\tlet tmpEnvironmentVariableName = (tmpSeparatorIndex > -1) ? tmpTemplateValue.substring(0, tmpSeparatorIndex) : tmpTemplateValue;\n\n\t\t\t\tif (process.env.hasOwnProperty(tmpEnvironmentVariableName))\n\t\t\t\t{\n\t\t\t\t\treturn process.env[tmpEnvironmentVariableName];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn tmpDefaultValue;\n\t\t\t\t}\n\t\t\t});\n    }\n\n    parseSetting(pString)\n    {\n        return this.templateProcessor.parseString(pString);\n    }\n}\n\nmodule.exports = FableSettingsTemplateProcessor;\n}).call(this)}).call(this,require('_process'))\n\n},{\"_process\":33}],26:[function(require,module,exports){\n/**\n* Fable Settings Add-on\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable Settings\n*/\n\nconst libPrecedent = require('precedent');\nconst libFableSettingsTemplateProcessor = require('./Fable-Settings-TemplateProcessor.js');\n\nclass FableSettings\n{\n\tconstructor(pFableSettings)\n\t{\n\t\t// Expose the dependencies for downstream re-use\n\t\tthis.dependencies = (\n\t\t\t{\n\t\t\t\tprecedent: libPrecedent\n\t\t\t});\n\n\t\t// Initialize the settings value template processor\n\t\tthis.settingsTemplateProcessor = new libFableSettingsTemplateProcessor(this.dependencies);\n\n\t\t// set straight away so anything that uses it respects the initial setting\n\t\tthis._configureEnvTemplating(pFableSettings);\n\n\t\tthis.default = this.buildDefaultSettings();\n\n\t\t// Construct a new settings object\n\t\tlet tmpSettings = this.merge(pFableSettings, this.buildDefaultSettings());\n\n\t\t// The base settings object (what they were on initialization, before other actors have altered them)\n\t\tthis.base = JSON.parse(JSON.stringify(tmpSettings));\n\n\t\tif (tmpSettings.DefaultConfigFile)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// If there is a DEFAULT configuration file, try to load and merge it.\n\t\t\t\ttmpSettings = this.merge(require(tmpSettings.DefaultConfigFile), tmpSettings);\n\t\t\t}\n\t\t\tcatch (pException)\n\t\t\t{\n\t\t\t\t// Why this?  Often for an app we want settings to work out of the box, but\n\t\t\t\t// would potentially want to have a config file for complex settings.\n\t\t\t\tconsole.log('Fable-Settings Warning: Default configuration file specified but there was a problem loading it.  Falling back to base.');\n\t\t\t\tconsole.log('     Loading Exception: '+pException);\n\t\t\t}\n\t\t}\n\n\t\tif (tmpSettings.ConfigFile)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// If there is a configuration file, try to load and merge it.\n\t\t\t\ttmpSettings = this.merge(require(tmpSettings.ConfigFile), tmpSettings);\n\t\t\t}\n\t\t\tcatch (pException)\n\t\t\t{\n\t\t\t\t// Why this?  Often for an app we want settings to work out of the box, but\n\t\t\t\t// would potentially want to have a config file for complex settings.\n\t\t\t\tconsole.log('Fable-Settings Warning: Configuration file specified but there was a problem loading it.  Falling back to base.');\n\t\t\t\tconsole.log('     Loading Exception: '+pException);\n\t\t\t}\n\t\t}\n\n\t\tthis.settings = tmpSettings;\n\t}\n\n\t// Build a default settings object.  Use the JSON jimmy to ensure it is always a new object.\n\tbuildDefaultSettings()\n\t{\n\t\treturn JSON.parse(JSON.stringify(require('./Fable-Settings-Default')));\n\t}\n\n\t// Update the configuration for environment variable templating based on the current settings object\n\t_configureEnvTemplating(pSettings)\n\t{\n\t\t// default environment variable templating to on\n\t\tthis._PerformEnvTemplating = !pSettings || pSettings.NoEnvReplacement !== true;\n\t}\n\n\t// Resolve (recursive) any environment variables found in settings object.\n\t_resolveEnv(pSettings)\n\t{\n\t\tfor (const tmpKey in pSettings)\n\t\t{\n\t\t\tif (typeof(pSettings[tmpKey]) === 'object')\n\t\t\t{\n\t\t\t\tthis._resolveEnv(pSettings[tmpKey]);\n\t\t\t}\n\t\t\telse if (typeof(pSettings[tmpKey]) === 'string')\n\t\t\t{\n\t\t\t\tpSettings[tmpKey] = this.settingsTemplateProcessor.parseSetting(pSettings[tmpKey]);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Check to see if a value is an object (but not an array).\n\t */\n\t_isObject(value)\n\t{\n\t\treturn typeof(value) === 'object' && !Array.isArray(value);\n\t}\n\n\t/**\n\t * Merge two plain objects. Keys that are objects in both will be merged property-wise.\n\t */\n\t_deepMergeObjects(toObject, fromObject)\n\t{\n\t\tif (!fromObject || !this._isObject(fromObject))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tObject.keys(fromObject).forEach((key) =>\n\t\t{\n\t\t\tconst fromValue = fromObject[key];\n\t\t\tif (this._isObject(fromValue))\n\t\t\t{\n\t\t\t\tconst toValue = toObject[key];\n\t\t\t\tif (toValue && this._isObject(toValue))\n\t\t\t\t{\n\t\t\t\t\t// both are objects, so do a recursive merge\n\t\t\t\t\tthis._deepMergeObjects(toValue, fromValue);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttoObject[key] = fromValue;\n\t\t});\n\t\treturn toObject;\n\t}\n\n\t// Merge some new object into the existing settings.\n\tmerge(pSettingsFrom, pSettingsTo)\n\t{\n\t\t// If an invalid settings from object is passed in (e.g. object constructor without passing in anything) this should still work\n\t\tlet tmpSettingsFrom = (typeof(pSettingsFrom) === 'object') ? pSettingsFrom : {};\n\t\t// Default to the settings object if none is passed in for the merge.\n\t\tlet tmpSettingsTo = (typeof(pSettingsTo) === 'object') ? pSettingsTo : this.settings;\n\n\t\t// do not mutate the From object property values\n\t\tlet tmpSettingsFromCopy = JSON.parse(JSON.stringify(tmpSettingsFrom));\n\t\ttmpSettingsTo = this._deepMergeObjects(tmpSettingsTo, tmpSettingsFromCopy);\n\n\t\tif (this._PerformEnvTemplating)\n\t\t{\n\t\t\tthis._resolveEnv(tmpSettingsTo);\n\t\t}\n\t\t// Update env tempating config, since we just updated the config object, and it may have changed\n\t\tthis._configureEnvTemplating(tmpSettingsTo);\n\n\t\treturn tmpSettingsTo;\n\t}\n\n\t// Fill in settings gaps without overwriting settings that are already there\n\tfill(pSettingsFrom)\n\t{\n\t\t// If an invalid settings from object is passed in (e.g. object constructor without passing in anything) this should still work\n\t\tlet tmpSettingsFrom = (typeof(pSettingsFrom) === 'object') ? pSettingsFrom : {};\n\n\t\t// do not mutate the From object property values\n\t\tlet tmpSettingsFromCopy = JSON.parse(JSON.stringify(tmpSettingsFrom));\n\n\t\tthis.settings = this._deepMergeObjects(tmpSettingsFromCopy, this.settings);\n\n\t\treturn this.settings;\n\t}\n};\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new FableSettings(pSettings);\n}\n\nmodule.exports = FableSettings;\nmodule.exports.new = autoConstruct;\nmodule.exports.precedent = libPrecedent;\n},{\"./Fable-Settings-Default\":24,\"./Fable-Settings-TemplateProcessor.js\":25,\"precedent\":30}],27:[function(require,module,exports){\n/**\n* Random Byte Generator - Browser version\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\n// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\nclass RandomBytes\n{\n\tconstructor()\n\t{\n\n\t\t// getRandomValues needs to be invoked in a context where \"this\" is a Crypto\n\t\t// implementation. Also, find the complete implementation of crypto on IE11.\n\t\tthis.getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||\n                      \t\t(typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));\n\t}\n\n\t// WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n\tgenerateWhatWGBytes()\n\t{\n\t\tlet tmpBuffer = new Uint8Array(16); // eslint-disable-line no-undef\n\n\t\tthis.getRandomValues(tmpBuffer);\n\t\treturn tmpBuffer;\n\t}\n\n\t// Math.random()-based (RNG)\n\tgenerateRandomBytes()\n\t{\n\t\t// If all else fails, use Math.random().  It's fast, but is of unspecified\n\t\t// quality.\n\t\tlet tmpBuffer = new Uint8Array(16); // eslint-disable-line no-undef\n\n\t\tfor (let i = 0, tmpValue; i < 16; i++)\n\t\t{\n\t\t\tif ((i & 0x03) === 0)\n\t\t\t{\n\t\t\t\ttmpValue = Math.random() * 0x100000000;\n\t\t\t}\n\n\t\t\ttmpBuffer[i] = tmpValue >>> ((i & 0x03) << 3) & 0xff;\n\t\t}\n\n\t\treturn tmpBuffer;\n\t}\n\n\tgenerate()\n\t{\n\t\tif (this.getRandomValues)\n\t\t{\n\t\t\treturn this.generateWhatWGBytes();\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.generateRandomBytes();\n\t\t}\n\t}\n}\n\nmodule.exports = RandomBytes;\n\n},{}],28:[function(require,module,exports){\n/**\n* Fable UUID Generator\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable UUID\n*/\n\n/**\n* Fable Solution UUID Generation Main Class\n*\n* @class FableUUID\n* @constructor\n*/\n\nvar libRandomByteGenerator = require('./Fable-UUID-Random.js')\n\nclass FableUUID\n{\n\tconstructor(pSettings)\n\t{\n\t\t// Determine if the module is in \"Random UUID Mode\" which means just use the random character function rather than the v4 random UUID spec.\n\t\t// Note this allows UUIDs of various lengths (including very short ones) although guaranteed uniqueness goes downhill fast.\n\t\tthis._UUIDModeRandom = (typeof(pSettings) === 'object') && (pSettings.hasOwnProperty('UUIDModeRandom')) ? (pSettings.UUIDModeRandom == true) : false;\n\t\t// These two properties are only useful if we are in Random mode.  Otherwise it generates a v4 spec\n\t\t// Length for \"Random UUID Mode\" is set -- if not set it to 8\n\t\tthis._UUIDLength = (typeof(pSettings) === 'object') && (pSettings.hasOwnProperty('UUIDLength')) ? (pSettings.UUIDLength + 0) : 8;\n\t\t// Dictionary for \"Random UUID Mode\"\n\t\tthis._UUIDRandomDictionary = (typeof(pSettings) === 'object') && (pSettings.hasOwnProperty('UUIDDictionary')) ? (pSettings.UUIDDictionary + 0) : '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n\n\t\tthis.randomByteGenerator = new libRandomByteGenerator();\n\n\t\t// Lookup table for hex codes\n\t\tthis._HexLookup = [];\n\t\tfor (let i = 0; i < 256; ++i)\n\t\t{\n\t\t\tthis._HexLookup[i] = (i + 0x100).toString(16).substr(1);\n\t\t}\n\t}\n\n\t// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n\tbytesToUUID(pBuffer)\n\t{\n\t\tlet i = 0;\n\t\t// join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n\t\treturn ([\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], \n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]]\n\t\t\t\t]).join('');\n\t}\n\n\t// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n\tgenerateUUIDv4()\n\t{\n\t\tlet tmpBuffer = new Array(16);\n\t\tvar tmpRandomBytes = this.randomByteGenerator.generate();\n\n\t\t// Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\t\ttmpRandomBytes[6] = (tmpRandomBytes[6] & 0x0f) | 0x40;\n\t\ttmpRandomBytes[8] = (tmpRandomBytes[8] & 0x3f) | 0x80;\n\n\t\treturn this.bytesToUUID(tmpRandomBytes);\n\t}\n\n\t// Simple random UUID generation\n\tgenerateRandom()\n\t{\n\t\tlet tmpUUID = '';\n\n\t\tfor (let i = 0; i < this._UUIDLength; i++)\n\t\t{\n\t\t\ttmpUUID += this._UUIDRandomDictionary.charAt(Math.floor(Math.random() * (this._UUIDRandomDictionary.length-1)));\n\t\t}\n\n\t\treturn tmpUUID;\n\t}\n\n\t// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n\tgetUUID()\n\t{\n\t\tif (this._UUIDModeRandom)\n\t\t{\n\t\t\treturn this.generateRandom();\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.generateUUIDv4();\n\t\t}\n\t}\n}\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new FableUUID(pSettings);\n}\n\n\nmodule.exports = FableUUID;\nmodule.exports.new = autoConstruct;\n\n},{\"./Fable-UUID-Random.js\":27}],29:[function(require,module,exports){\n(function (process){(function (){\n// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n\n}).call(this)}).call(this,require('_process'))\n\n},{\"_process\":33}],30:[function(require,module,exports){\n/**\n* Precedent Meta-Templating\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Process text streams, parsing out meta-template expressions.\n*/\nvar libWordTree = require(`./WordTree.js`);\nvar libStringParser = require(`./StringParser.js`);\n\nclass Precedent\n{\n\t/**\n\t * Precedent Constructor\n\t */\n\tconstructor()\n\t{\n\t\tthis.WordTree = new libWordTree();\n\n\t\tthis.StringParser = new libStringParser();\n\n\t\tthis.ParseTree = this.WordTree.ParseTree;\n\t}\n\n\t/**\n\t * Add a Pattern to the Parse Tree\n\t * @method addPattern\n\t * @param {Object} pTree - A node on the parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @param {number} pIndex - callback function\n\t * @return {bool} True if adding the pattern was successful\n\t */\n\taddPattern(pPatternStart, pPatternEnd, pParser)\n\t{\n\t\treturn this.WordTree.addPattern(pPatternStart, pPatternEnd, pParser);\n\t}\n\n\t/**\n\t * Parse a string with the existing parse tree\n\t * @method parseString\n\t * @param {string} pString - The string to parse\n\t * @param {object} pData - Data to pass in as the second argument\n\t * @return {string} The result from the parser\n\t */\n\tparseString(pString, pData)\n\t{\n\t\treturn this.StringParser.parseString(pString, this.ParseTree, pData);\n\t}\n}\n\nmodule.exports = Precedent;\n\n},{\"./StringParser.js\":31,\"./WordTree.js\":32}],31:[function(require,module,exports){\n/**\n* String Parser\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Parse a string, properly processing each matched token in the word tree.\n*/\n\nclass StringParser\n{\n\t/**\n\t * StringParser Constructor\n\t */\n\tconstructor()\n\t{\n\t}\n\n\t/**\n\t * Create a fresh parsing state object to work with.\n\t * @method newParserState\n\t * @param {Object} pParseTree - A node on the parse tree to begin parsing from (usually root)\n\t * @return {Object} A new parser state object for running a character parser on\n\t * @private\n\t */\n\tnewParserState (pParseTree)\n\t{\n\t\treturn (\n\t\t{\n\t\t\tParseTree: pParseTree,\n\n\t\t\tOutput: '',\n\t\t\tOutputBuffer: '',\n\n\t\t\tPattern: false,\n\n\t\t\tPatternMatch: false,\n\t\t\tPatternMatchOutputBuffer: ''\n\t\t});\n\t}\n\n\t/**\n\t * Assign a node of the parser tree to be the next potential match.\n\t * If the node has a PatternEnd property, it is a valid match and supercedes the last valid match (or becomes the initial match).\n\t * @method assignNode\n\t * @param {Object} pNode - A node on the parse tree to assign\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tassignNode (pNode, pParserState)\n\t{\n\t\tpParserState.PatternMatch = pNode;\n\n\t\t// If the pattern has a END we can assume it has a parse function...\n\t\tif (pParserState.PatternMatch.hasOwnProperty('PatternEnd'))\n\t\t{\n\t\t\t// ... this is the legitimate start of a pattern.\n\t\t\tpParserState.Pattern = pParserState.PatternMatch;\n\t\t}\n\t}\n\n\t/**\n\t * Append a character to the output buffer in the parser state.\n\t * This output buffer is used when a potential match is being explored, or a match is being explored.\n\t * @method appendOutputBuffer\n\t * @param {string} pCharacter - The character to append\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tappendOutputBuffer (pCharacter, pParserState)\n\t{\n\t\tpParserState.OutputBuffer += pCharacter;\n\t}\n\n\t/**\n\t * Flush the output buffer to the output and clear it.\n\t * @method flushOutputBuffer\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tflushOutputBuffer (pParserState)\n\t{\n\t\tpParserState.Output += pParserState.OutputBuffer;\n\t\tpParserState.OutputBuffer = '';\n\t}\n\n\n\t/**\n\t * Check if the pattern has ended.  If it has, properly flush the buffer and start looking for new patterns.\n\t * @method checkPatternEnd\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tcheckPatternEnd (pParserState, pData)\n\t{\n\t\tif ((pParserState.OutputBuffer.length >= pParserState.Pattern.PatternEnd.length+pParserState.Pattern.PatternStart.length) &&\n\t\t\t(pParserState.OutputBuffer.substr(-pParserState.Pattern.PatternEnd.length) === pParserState.Pattern.PatternEnd))\n\t\t{\n\t\t\t// ... this is the end of a pattern, cut off the end tag and parse it.\n\t\t\t// Trim the start and end tags off the output buffer now\n\t\t\tpParserState.OutputBuffer = pParserState.Pattern.Parse(pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStart.length, pParserState.OutputBuffer.length - (pParserState.Pattern.PatternStart.length+pParserState.Pattern.PatternEnd.length)), pData);\n\t\t\t// Flush the output buffer.\n\t\t\tthis.flushOutputBuffer(pParserState);\n\t\t\t// End pattern mode\n\t\t\tpParserState.Pattern = false;\n\t\t\tpParserState.PatternMatch = false;\n\t\t}\n\t}\n\n\t/**\n\t * Parse a character in the buffer.\n\t * @method parseCharacter\n\t * @param {string} pCharacter - The character to append\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tparseCharacter (pCharacter, pParserState, pData)\n\t{\n\t\t// (1) If we aren't in a pattern match, and we aren't potentially matching, and this may be the start of a new pattern....\n\t\tif (!pParserState.PatternMatch && pParserState.ParseTree.hasOwnProperty(pCharacter))\n\t\t{\n\t\t\t// ... assign the node as the matched node.\n\t\t\tthis.assignNode(pParserState.ParseTree[pCharacter], pParserState);\n\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t}\n\t\t// (2) If we are in a pattern match (actively seeing if this is part of a new pattern token)\n\t\telse if (pParserState.PatternMatch)\n\t\t{\n\t\t\t// If the pattern has a subpattern with this key\n\t\t\tif (pParserState.PatternMatch.hasOwnProperty(pCharacter))\n\t\t\t{\n\t\t\t\t// Continue matching patterns.\n\t\t\t\tthis.assignNode(pParserState.PatternMatch[pCharacter], pParserState);\n\t\t\t}\n\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\tif (pParserState.Pattern)\n\t\t\t{\n\t\t\t\t// ... Check if this is the end of the pattern (if we are matching a valid pattern)...\n\t\t\t\tthis.checkPatternEnd(pParserState, pData);\n\t\t\t}\n\t\t}\n\t\t// (3) If we aren't in a pattern match or pattern, and this isn't the start of a new pattern (RAW mode)....\n\t\telse\n\t\t{\n\t\t\tpParserState.Output += pCharacter;\n\t\t}\n\t}\n\n\t/**\n\t * Parse a string for matches, and process any template segments that occur.\n\t * @method parseString\n\t * @param {string} pString - The string to parse.\n\t * @param {Object} pParseTree - The parse tree to begin parsing from (usually root)\n\t * @param {Object} pData - The data to pass to the function as a second paramter\n\t */\n\tparseString (pString, pParseTree, pData)\n\t{\n\t\tlet tmpParserState = this.newParserState(pParseTree);\n\n\t\tfor (var i = 0; i < pString.length; i++)\n\t\t{\n\t\t\t// TODO: This is not fast.\n\t\t\tthis.parseCharacter(pString[i], tmpParserState, pData);\n\t\t}\n\n\t\tthis.flushOutputBuffer(tmpParserState);\n\n\t\treturn tmpParserState.Output;\n\t}\n}\n\nmodule.exports = StringParser;\n\n},{}],32:[function(require,module,exports){\n/**\n* Word Tree\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Create a tree (directed graph) of Javascript objects, one character per object.\n*/\n\nclass WordTree\n{\n\t/**\n\t * WordTree Constructor\n\t */\n\tconstructor()\n\t{\n\t\tthis.ParseTree = {};\n\t}\n\t\n\t/** \n\t * Add a child character to a Parse Tree node\n\t * @method addChild\n\t * @param {Object} pTree - A parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @param {number} pIndex - The index of the character in the pattern\n\t * @returns {Object} The resulting leaf node that was added (or found)\n\t * @private\n\t */\n\taddChild (pTree, pPattern, pIndex)\n\t{\n\t\tif (!pTree.hasOwnProperty(pPattern[pIndex]))\n\t\t\tpTree[pPattern[pIndex]] = {};\n\t\t\n\t\treturn pTree[pPattern[pIndex]];\n\t}\n\t\n\t/** Add a Pattern to the Parse Tree\n\t * @method addPattern\n\t * @param {Object} pPatternStart - The starting string for the pattern (e.g. \"${\")\n\t * @param {string} pPatternEnd - The ending string for the pattern (e.g. \"}\")\n\t * @param {number} pParser - The function to parse if this is the matched pattern, once the Pattern End is met.  If this is a string, a simple replacement occurs.\n\t * @return {bool} True if adding the pattern was successful\n\t */\n\taddPattern (pPatternStart, pPatternEnd, pParser)\n\t{\n\t\tif (pPatternStart.length < 1)\n\t\t\treturn false;\n\n\t\tif ((typeof(pPatternEnd) === 'string') && (pPatternEnd.length < 1))\n\t\t\treturn false;\n\n\t\tlet tmpLeaf = this.ParseTree;\n\n\t\t// Add the tree of leaves iteratively\n\t\tfor (var i = 0; i < pPatternStart.length; i++)\n\t\t\ttmpLeaf = this.addChild(tmpLeaf, pPatternStart, i);\n\n\t\ttmpLeaf.PatternStart = pPatternStart;\n\t\ttmpLeaf.PatternEnd = ((typeof(pPatternEnd) === 'string') && (pPatternEnd.length > 0)) ? pPatternEnd : pPatternStart;\n\t\ttmpLeaf.Parse = (typeof(pParser) === 'function') ? pParser : \n\t\t\t\t\t\t(typeof(pParser) === 'string') ? () => { return pParser; } :\n\t\t\t\t\t\t(pData) => { return pData; };\n\n\t\treturn true;\n\t}\n}\n\nmodule.exports = WordTree;\n\n},{}],33:[function(require,module,exports){\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],34:[function(require,module,exports){\n(function (setImmediate,clearImmediate){(function (){\nvar nextTick = require('process/browser.js').nextTick;\nvar apply = Function.prototype.apply;\nvar slice = Array.prototype.slice;\nvar immediateIds = {};\nvar nextImmediateId = 0;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) { timeout.close(); };\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// That's not how node.js implements it but the exposed api is the same.\nexports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n  var id = nextImmediateId++;\n  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n  immediateIds[id] = true;\n\n  nextTick(function onNextTick() {\n    if (immediateIds[id]) {\n      // fn.call() is faster so we optimize for the common use-case\n      // @see http://jsperf.com/call-apply-segu\n      if (args) {\n        fn.apply(null, args);\n      } else {\n        fn.call(null);\n      }\n      // Prevent ids from leaking\n      exports.clearImmediate(id);\n    }\n  });\n\n  return id;\n};\n\nexports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n  delete immediateIds[id];\n};\n}).call(this)}).call(this,require(\"timers\").setImmediate,require(\"timers\").clearImmediate)\n\n},{\"process/browser.js\":33,\"timers\":34}],35:[function(require,module,exports){\nvar libNPMModuleWrapper = require('./Fable.js');\n\nif ((typeof(window) === 'object') && !window.hasOwnProperty('Fable'))\n{\n\twindow.Fable = libNPMModuleWrapper;\n}\n\nmodule.exports = libNPMModuleWrapper;\n},{\"./Fable.js\":43}],36:[function(require,module,exports){\nconst _OperationStatePrototype = JSON.stringify(\n{\n\t\"Metadata\": {\n\t\t\"GUID\": false,\n\t\t\"Hash\": false,\n\n\t\t\"Title\": \"\",\n\t\t\"Summary\": \"\",\n\n\t\t\"Version\": 0\n\t},\n\t\"Status\": {\n        \"Completed\": false,\n\n        \"CompletionProgress\": 0,\n        \"CompletionTimeElapsed\": 0,\n\n        \"Steps\": 1,\n        \"StepsCompleted\": 0,\n\n        \"StartTime\": 0,\n        \"EndTime\": 0\n\t},\n\t\"Errors\": [],\n\t\"Log\": []\n});\n\nclass FableOperation\n{\n\tconstructor(pFable, pOperationName, pOperationHash)\n\t{\n\t\tthis.fable = pFable;\n\n\t\tthis.name = pOperationName;\n\n\t\tthis.state = JSON.parse(_OperationStatePrototype);\n\n\t\tthis.state.Metadata.GUID = this.fable.getUUID();\n\t\tthis.state.Metadata.Hash = this.state.GUID;\n\n\t\tif (typeof(pOperationHash) == 'string')\n\t\t{\n\t\t\tthis.state.Metadata.Hash = pOperationHash;\n\t\t}\n\t}\n\n\tget GUID()\n\t{\n\t\treturn this.state.Metadata.GUID;\n\t}\n\n\tget Hash()\n\t{\n\t\treturn this.state.Metadata.Hash;\n\t}\n\n\tget log()\n\t{\n\t\treturn this;\n\t}\n\n\twriteOperationLog(pLogLevel, pLogText, pLogObject)\n\t{\n\t\tthis.state.Log.push(`${new Date().toUTCString()} [${pLogLevel}]: ${pLogText}`);\n\n\t\tif (typeof(pLogObject) == 'object')\n\t\t{\n\t\t\tthis.state.Log.push(JSON.stringify(pLogObject));\n\t\t}\n\t}\n\n\twriteOperationErrors(pLogText, pLogObject)\n\t{\n\t\tthis.state.Errors.push(`${pLogText}`);\n\n\t\tif (typeof(pLogObject) == 'object')\n\t\t{\n\t\t\tthis.state.Errors.push(JSON.stringify(pLogObject));\n\t\t}\n\t}\n\n\ttrace(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('TRACE', pLogText, pLogObject);\n\t\tthis.fable.log.trace(pLogText, pLogObject);\n\t}\n\n\tdebug(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('DEBUG', pLogText, pLogObject);\n\t\tthis.fable.log.debug(pLogText, pLogObject);\n\t}\n\n\tinfo(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('INFO', pLogText, pLogObject);\n\t\tthis.fable.log.info(pLogText, pLogObject);\n\t}\n\n\twarn(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('WARN', pLogText, pLogObject);\n\t\tthis.fable.log.warn(pLogText, pLogObject);\n\t}\n\n\terror(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('ERROR', pLogText, pLogObject);\n\t\tthis.writeOperationErrors(pLogText, pLogObject);\n\t\tthis.fable.log.error(pLogText, pLogObject);\n\t}\n\n\tfatal(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('FATAL', pLogText, pLogObject);\n\t\tthis.writeOperationErrors(pLogText, pLogObject);\n\t\tthis.fable.log.fatal(pLogText, pLogObject);\n\t}\n}\n\nmodule.exports = FableOperation;\n},{}],37:[function(require,module,exports){\nconst libFableServiceBase = require('./Fable-ServiceProviderBase.js');\nconst libDataArithmatic = require('data-arithmatic');\n\nclass FableServiceDataArithmatic extends libFableServiceBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n        super(pFable, pOptions, pServiceHash);\n\n        this.serviceType = 'DataArithmatic';\n\n        this._DataArithmaticLibrary = new libDataArithmatic();\n\t}\n}\n\nmodule.exports = FableServiceDataArithmatic;\n},{\"./Fable-ServiceProviderBase.js\":42,\"data-arithmatic\":17}],38:[function(require,module,exports){\nconst libFableServiceBase = require('./Fable-ServiceProviderBase.js');\n\nconst libPrecedent = require('precedent');\n\nclass FableServiceMetaTemplate extends libFableServiceBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n        super(pFable, pOptions, pServiceHash);\n\n        this.serviceType = 'MetaTemplate';\n\n        this._MetaTemplateLibrary = new libPrecedent(this.options);\n\t}\n\n\t/**\n\t * Add a Pattern to the Parse Tree\n\t * @method addPattern\n\t * @param {Object} pTree - A node on the parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @param {number} pIndex - callback function\n\t * @return {bool} True if adding the pattern was successful\n\t */\n\taddPattern(pPatternStart, pPatternEnd, pParser)\n\t{\n\t\treturn this._MetaTemplateLibrary.addPattern(pPatternStart, pPatternEnd, pParser);\n\t}\n\n\t/**\n\t * Parse a string with the existing parse tree\n\t * @method parseString\n\t * @param {string} pString - The string to parse\n\t * @return {string} The result from the parser\n\t */\n\tparseString(pString, pData)\n\t{\n\t\treturn this._MetaTemplateLibrary.parseString(pString, pData);\n\t}\n}\n\nmodule.exports = FableServiceMetaTemplate;\n},{\"./Fable-ServiceProviderBase.js\":42,\"precedent\":30}],39:[function(require,module,exports){\nconst libFableServiceBase = require('./Fable-ServiceProviderBase.js');\n\nclass FableServiceTemplate extends libFableServiceBase\n{\n\t// Underscore and lodash have a behavior, _.template, which compiles a\n\t// string-based template with code snippets into simple executable pieces,\n\t// with the added twist of returning a precompiled function ready to go.\n\t//\n\t// NOTE: This does not implement underscore escape expressions\n\t// NOTE: This does not implement underscore magic browser variable assignment\n\t//\n\t// This is an implementation of that.\n\t// TODO: Make this use precedent, add configuration, add debugging.\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n        super(pFable, pOptions, pServiceHash);\n\n        this.serviceType = 'Template';\n\n\t\t// These are the exact regex's used in lodash/underscore\n\t\t// TODO: Switch this to precedent\n\t\tthis.Matchers = (\n\t\t\t{\n\t\t\t\tEvaluate: /<%([\\s\\S]+?)%>/g,\n\t\t\t\tInterpolate: /<%=([\\s\\S]+?)%>/g,\n\t\t\t\tEscaper: /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g,\n\t\t\t\tUnescaper: /\\\\(\\\\|'|r|n|t|u2028|u2029)/g,\n\t\t\t\t// This is how underscore does it, so we are keeping it for now.\n\t\t\t\tGuaranteedNonMatch: /.^/\n\t\t\t});\n\n\t\t// This is a helper for the escaper and unescaper functions.\n\t\t// Right now we are going to keep what underscore is doing, but, not forever.\n\t\tthis.templateEscapes = {\n\t\t\t'\\\\': '\\\\',\n\t\t\t\"'\": \"'\",\n\t\t\t'r': '\\r',\n\t\t\t'\\r': 'r',\n\t\t\t'n': '\\n',\n\t\t\t'\\n': 'n',\n\t\t\t't': '\\t',\n\t\t\t'\\t': 't',\n\t\t\t'u2028': '\\u2028',\n\t\t\t'\\u2028': 'u2028',\n\t\t\t'u2029': '\\u2029',\n\t\t\t'\\u2029': 'u2029'\n\t\t};\n\n\t\t// This is defined as such to underscore that it is a dynamic programming\n\t\t// function on this class.\n\t\tthis.renderFunction = false;\n        this.templateString = false;\n\t}\n\n\trenderTemplate(pData)\n\t{\n\t\treturn this.renderFunction(pData);\n\t}\n\n\ttemplateFunction(pData)\n\t{\n\t\tlet fRenderTemplateBound = this.renderTemplate.bind(this);\n\t\treturn fRenderTemplateBound;\n\t}\n\n\tbuildTemplateFunction(pTemplateText, pData)\n\t{\n\t\t// For now this is being kept in a weird form ... this is to mimic the old\n\t\t// underscore code until this is rewritten using precedent.\n\t\tthis.TemplateSource = \"__p+='\" + pTemplateText\n\t\t\t.replace(this.Matchers.Escaper,\n\t\t\t\t(pMatch)=>\n\t\t\t\t{\n\t\t\t\t\treturn `\\\\${this.templateEscapes[pMatch]}`;\n\t\t\t\t})\n\t\t\t.replace(this.Matchers.Interpolate || this.Matchers.GuaranteedNonMatch,\n\t\t\t\t(pMatch, pCode) =>\n\t\t\t\t{\n\t\t\t\t\treturn `'+\\n(${decodeURIComponent(pCode)})+\\n'`;\n\t\t\t\t})\n\t\t\t.replace(this.Matchers.Evaluate || this.Matchers.GuaranteedNonMatch,\n\t\t\t\t(pMatch, pCode) =>\n\t\t\t\t{\n\t\t\t\t\treturn `';\\n${decodeURIComponent(pCode)}\\n;__p+='`;\n\t\t\t\t}) + `';\\n`;\n\n\n\t\tthis.TemplateSource = `with(pTemplateDataObject||{}){\\n${this.TemplateSource}}\\n`;\n\t\tthis.TemplateSource = `var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};\\n${this.TemplateSource}return __p;\\n`;\n\n\t\tthis.renderFunction = new Function('pTemplateDataObject', this.TemplateSource);\n\n\t\tif (typeof(pData) != 'undefined')\n\t\t{\n\t\t\treturn this.renderFunction(pData);\n\t\t}\n\n\t\t// Provide the compiled function source as a convenience for build time\n\t\t// precompilation.\n\t\tthis.TemplateSourceCompiled = 'function(obj){\\n' + this.TemplateSource + '}';\n\n\t\treturn this.templateFunction();\n\t}\n}\n\nmodule.exports = FableServiceTemplate;\n},{\"./Fable-ServiceProviderBase.js\":42}],40:[function(require,module,exports){\nconst libFableServiceBase = require('./Fable-ServiceProviderBase.js');\n\n\n// TODO: These are still pretty big -- consider the smaller polyfills\nconst libAsyncWaterfall = require('async.waterfall');\nconst libAsyncEachLimit = require('async.eachlimit');\n\nclass FableServiceUtility extends libFableServiceBase\n{\n\t// Underscore and lodash have a behavior, _.template, which compiles a\n\t// string-based template with code snippets into simple executable pieces,\n\t// with the added twist of returning a precompiled function ready to go.\n\t//\n\t// NOTE: This does not implement underscore escape expressions\n\t// NOTE: This does not implement underscore magic browser variable assignment\n\t//\n\t// This is an implementation of that.\n\t// TODO: Make this use precedent, add configuration, add debugging.\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n        super(pFable, pOptions, pServiceHash);\n\n\t\tthis.templates = {};\n\n\t\t// These two functions are used extensively throughout\n\t\tthis.waterfall = libAsyncWaterfall;\n\t\tthis.eachLimit = libAsyncEachLimit;\n\t}\n\n\t// Underscore and lodash have a behavior, _.extend, which merges objects.\n\t// Now that es6 gives us this, use the native thingy.\n\textend(pDestinationObject, ...pSourceObjects)\n\t{\n\t\treturn Object.assign(pDestinationObject, ...pSourceObjects);\n\t}\n\n\t// Underscore and lodash have a behavior, _.template, which compiles a\n\t// string-based template with code snippets into simple executable pieces,\n\t// with the added twist of returning a precompiled function ready to go.\n\ttemplate(pTemplateText, pData)\n\t{\n\t\tlet tmpTemplate = this.fable.serviceManager.instantiateServiceProviderWithoutRegistration('Template');\n\n\t\treturn tmpTemplate.buildTemplateFunction(pTemplateText, pData);\n\t}\n\n\t// Build a template function from a template hash, and, register it with the service provider\n\tbuildHashedTemplate(pTemplateHash, pTemplateText, pData)\n\t{\n\t\tlet tmpTemplate = this.fable.serviceManager.instantiateServiceProvider('Template', {}, pTemplateHash);\n\n\t\tthis.templates[pTemplateHash] = tmpTemplate.buildTemplateFunction(pTemplateText, pData);\n\n\t\treturn this.templates[pTemplateHash];\n\t}\n\n\t// This is a safe, modern version of chunk from underscore\n\t// Algorithm pulled from a mix of these two polyfills:\n\t// https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_chunk\n\t// https://youmightnotneed.com/lodash\n\t// This implementation was most tolerant in browsers.  Uglify can fix the rest.\n\tchunk (pInput, pChunkSize, pChunkCache)\n\t{\n\t\tlet tmpInputArray = [...pInput];\n\t\t// Note lodash defaults to 1, underscore defaults to 0\n\t\tlet tmpChunkSize = (typeof(pChunkSize) == 'number') ? pChunkSize : 0;\n\t\tlet tmpChunkCache = (typeof(pChunkCache) != 'undefined') ? pChunkCache : [];\n\n\t\tif (tmpChunkSize <= 0)\n\t\t{\n\t\t\treturn tmpChunkCache;\n\t\t}\n\n\t\twhile (tmpInputArray.length)\n\t\t{\n\t\t\ttmpChunkCache.push(tmpInputArray.splice(0, tmpChunkSize));\n\t\t}\n\n\t\treturn tmpChunkCache;\n\t}\n}\n\nmodule.exports = FableServiceUtility;\n},{\"./Fable-ServiceProviderBase.js\":42,\"async.eachlimit\":1,\"async.waterfall\":15}],41:[function(require,module,exports){\n/**\n* Fable Application Services Management\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\nconst libFableServiceBase = require('./Fable-ServiceProviderBase.js');\n\nclass FableService\n{\n\tconstructor(pFable)\n\t{\n\t\tthis.fable = pFable;\n\n\t\tthis.serviceTypes = [];\n\n\t\t// A map of instantiated services\n\t\tthis.services = {};\n\n\t\t// A map of the default instantiated service by type\n\t\tthis.defaultServices = {};\n\n\t\t// A map of class constructors for services\n\t\tthis.serviceClasses = {};\n\t}\n\n\taddServiceType(pServiceType, pServiceClass)\n\t{\n\t\t// Add the type to the list of types\n\t\tthis.serviceTypes.push(pServiceType);\n\n\t\t// Add the container for instantiated services to go in\n\t\tthis.services[pServiceType] = {};\n\n\t\tif ((typeof(pServiceClass) == 'function') && (pServiceClass.prototype instanceof libFableServiceBase))\n\t\t{\n\t\t\t// Add the class to the list of classes\n\t\t\tthis.serviceClasses[pServiceType] = pServiceClass;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Add the base class to the list of classes\n\t\t\tthis.serviceClasses[pServiceType] = libFableServiceBase;\n\t\t}\n\t}\n\n\tinstantiateServiceProvider(pServiceType, pOptions, pCustomServiceHash)\n\t{\n\t\t// Instantiate the service\n\t\tlet tmpService = this.instantiateServiceProviderWithoutRegistration(pServiceType, pOptions, pCustomServiceHash);\n\n\t\t// Add the service to the service map\n\t\tthis.services[pServiceType][tmpService.Hash] = tmpService;\n\n\t\t// If this is the first service of this type, make it the default\n\t\tif (!this.defaultServices.hasOwnProperty(pServiceType))\n\t\t{\n\t\t\tthis.defaultServices[pServiceType] = tmpService;\n\t\t}\n\n\t\treturn tmpService;\n\t}\n\n\t// Create a service provider but don't register it to live forever in fable.services\n\tinstantiateServiceProviderWithoutRegistration(pServiceType, pOptions, pCustomServiceHash)\n\t{\n\t\t// Instantiate the service\n\t\tlet tmpService = new this.serviceClasses[pServiceType](this.fable, pOptions, pCustomServiceHash);\n\t\treturn tmpService;\n\t}\n\n\tsetDefaultServiceInstantiation(pServiceType, pServiceHash)\n\t{\n\t\tif (this.services[pServiceType].hasOwnProperty(pServiceHash))\n\t\t{\n\t\t\tthis.defaultServices[pServiceType] = this.services[pServiceType][pServiceHash];\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n}\n\nmodule.exports = FableService;\n\nmodule.exports.ServiceProviderBase = libFableServiceBase;\n},{\"./Fable-ServiceProviderBase.js\":42}],42:[function(require,module,exports){\n/**\n* Fable Service Base\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\nclass FableServiceProviderBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tthis.fable = pFable;\n\n\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions : {};\n\n        this.serviceType = 'Unknown';\n\n        this.UUID = pFable.getUUID();\n\n        this.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash : `${this.UUID}`;\n\t}\n}\n\nmodule.exports = FableServiceProviderBase;\n\n},{}],43:[function(require,module,exports){\n/**\n* Fable Application Services Support Library\n* @license MIT\n* @author <steven@velozo.com>\n*/\nconst libFableSettings = require('fable-settings');\nconst libFableUUID = require('fable-uuid');\nconst libFableLog = require('fable-log');\n\nconst libFableServiceManager = require('./Fable-ServiceManager.js');\n\nconst libFableServiceDataArithmatic = require('./Fable-Service-DataArithmatic.js');\nconst libFableServiceTemplate = require('./Fable-Service-Template.js');\nconst libFableServiceMetaTemplate = require('./Fable-Service-MetaTemplate.js');\nconst libFableServiceUtility = require('./Fable-Service-Utility.js');\n\nconst libFableOperation = require('./Fable-Operation.js');\n\nclass Fable\n{\n\tconstructor(pSettings)\n\t{\n\t\tlet tmpSettings = new libFableSettings(pSettings);\n\n\t\tthis.settingsManager = tmpSettings;\n\n\t\t// Instantiate the UUID generator\n\t\tthis.libUUID = new libFableUUID(this.settingsManager.settings);\n\n\t\tthis.log = new libFableLog(this.settingsManager.settings);\n\t\tthis.log.initialize();\n\n\t\t// Built-in dependencies\n\t\tthis.Dependencies = (\n\t\t\t{\n\t\t\t\tprecedent: libFableSettings.precedent\n\t\t\t});\n\n\t\t// Location for Operation state\n\t\tthis.Operations = {};\n\n\t\tthis.serviceManager = new libFableServiceManager(this);\n\n\t\t// Initialize and instantiate the default baked-in Data Arithmatic service\n\t\tthis.serviceManager.addServiceType('DataArithmatic', libFableServiceDataArithmatic);\n\t\tthis.fable.serviceManager.instantiateServiceProvider('DataArithmatic', {}, 'Default-Service-DataArithmatic');\n\t\t// This service is passing through the data arithmatic library\n\t\tthis.DataArithmatic = this.serviceManager.defaultServices.DataArithmatic._DataArithmaticLibrary;\n\n\t\t// Initialize the template service\n\t\tthis.serviceManager.addServiceType('Template', libFableServiceTemplate);\n\n\t\t// Initialize the metatemplate service\n\t\tthis.serviceManager.addServiceType('MetaTemplate', libFableServiceMetaTemplate);\n\n\t\t// Initialize and instantiate the default baked-in Utility service\n\t\tthis.serviceManager.addServiceType('Utility', libFableServiceUtility)\n\t\tthis.fable.serviceManager.instantiateServiceProvider('Utility', {}, 'Default-Service-Utility');\n\t\tthis.Utility = this.serviceManager.defaultServices.Utility;\n\n\t\tthis.services = this.serviceManager.services;\n\t\tthis.defaultServices = this.serviceManager.defaultServices;\n\t}\n\n\tget settings()\n\t{\n\t\treturn this.settingsManager.settings;\n\t}\n\n\tget fable()\n\t{\n\t\treturn this;\n\t}\n\n\tgetUUID()\n\t{\n\t\treturn this.libUUID.getUUID();\n\t}\n\n\tcreateOperation(pOperationName, pOperationHash)\n\t{\n\t\tlet tmpOperation = new libFableOperation(this, pOperationName, pOperationHash);\n\n\t\tif (this.Operations.hasOwnProperty(tmpOperation.Hash))\n\t\t{\n\t\t\t// Uh Oh ...... Operation Hash Collision!\n\t\t\t// TODO: What to do?!\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.Operations[tmpOperation.Hash] = tmpOperation;\n\t\t}\n\n\t\treturn tmpOperation;\n\t}\n\n\tgetOperation(pOperationHash)\n\t{\n\t\tif (!this.Operations.hasOwnProperty(pOperationHash))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.Operations[pOperationHash];\n\t\t}\n\t}\n}\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new Fable(pSettings);\n}\n\nmodule.exports = Fable;\nmodule.exports.new = autoConstruct;\n\nmodule.exports.LogProviderBase = libFableLog.LogProviderBase;\nmodule.exports.ServiceProviderBase = libFableServiceManager.ServiceProviderBase;\n\nmodule.exports.precedent = libFableSettings.precedent;\n},{\"./Fable-Operation.js\":36,\"./Fable-Service-DataArithmatic.js\":37,\"./Fable-Service-MetaTemplate.js\":38,\"./Fable-Service-Template.js\":39,\"./Fable-Service-Utility.js\":40,\"./Fable-ServiceManager.js\":41,\"fable-log\":23,\"fable-settings\":26,\"fable-uuid\":28}]},{},[35])(35)\n});\n\n","(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","'use strict';\n\nvar eachOfLimit = require('async.util.eachoflimit');\nvar withoutIndex = require('async.util.withoutindex');\n\nmodule.exports = function eachLimit(arr, limit, iterator, cb) {\n    return eachOfLimit(limit)(arr, withoutIndex(iterator), cb);\n};\n","'use strict';\n\nmodule.exports = function(tasks) {\n    function makeCallback(index) {\n        function fn() {\n            if (tasks.length) {\n                tasks[index].apply(null, arguments);\n            }\n            return fn.next();\n        }\n        fn.next = function() {\n            return (index < tasks.length - 1) ? makeCallback(index + 1) : null;\n        };\n        return fn;\n    }\n    return makeCallback(0);\n};\n","var once = require('async.util.once');\nvar noop = require('async.util.noop');\nvar onlyOnce = require('async.util.onlyonce');\nvar keyIterator = require('async.util.keyiterator');\n\nmodule.exports = function eachOfLimit(limit) {\n    return function(obj, iterator, cb) {\n        cb = once(cb || noop);\n        obj = obj || [];\n        var nextKey = keyIterator(obj);\n        if (limit <= 0) {\n            return cb(null);\n        }\n        var done = false;\n        var running = 0;\n        var errored = false;\n\n        (function replenish() {\n            if (done && running <= 0) {\n                return cb(null);\n            }\n\n            while (running < limit && !errored) {\n                var key = nextKey();\n                if (key === null) {\n                    done = true;\n                    if (running <= 0) {\n                        cb(null);\n                    }\n                    return;\n                }\n                running += 1;\n                iterator(obj[key], key, onlyOnce(function(err) {\n                    running -= 1;\n                    if (err) {\n                        cb(err);\n                        errored = true;\n                    } else {\n                        replenish();\n                    }\n                }));\n            }\n        })();\n    };\n};\n","'use strict';\nvar setImmediate = require('async.util.setimmediate');\nvar restParam = require('async.util.restparam');\n\nmodule.exports = function(fn) {\n    return restParam(function(args) {\n        var callback = args.pop();\n        args.push(function() {\n            var innerArgs = arguments;\n            if (sync) {\n                setImmediate(function() {\n                    callback.apply(null, innerArgs);\n                });\n            } else {\n                callback.apply(null, innerArgs);\n            }\n        });\n        var sync = true;\n        fn.apply(this, args);\n        sync = false;\n    });\n};\n","'use strict';\n\nmodule.exports = Array.isArray || function isArray(obj) {\n    return Object.prototype.toString.call(obj) === '[object Array]';\n};\n","'use strict';\n\nvar isArray = require('async.util.isarray');\n\nmodule.exports = function isArrayLike(arr) {\n    return isArray(arr) || (\n        // has a positive integer length property\n        typeof arr.length === 'number' &&\n        arr.length >= 0 &&\n        arr.length % 1 === 0\n    );\n};\n","'use strict';\n\nvar _keys = require('async.util.keys');\nvar isArrayLike = require('async.util.isarraylike');\n\nmodule.exports = function keyIterator(coll) {\n    var i = -1;\n    var len;\n    var keys;\n    if (isArrayLike(coll)) {\n        len = coll.length;\n        return function next() {\n            i++;\n            return i < len ? i : null;\n        };\n    } else {\n        keys = _keys(coll);\n        len = keys.length;\n        return function next() {\n            i++;\n            return i < len ? keys[i] : null;\n        };\n    }\n};\n","'use strict';\n\nmodule.exports = Object.keys || function keys(obj) {\n    var _keys = [];\n    for (var k in obj) {\n        if (obj.hasOwnProperty(k)) {\n            _keys.push(k);\n        }\n    }\n    return _keys;\n};\n","'use strict';\n\nmodule.exports = function noop () {};\n","'use strict';\n\nmodule.exports = function once(fn) {\n    return function() {\n        if (fn === null) return;\n        fn.apply(this, arguments);\n        fn = null;\n    };\n};\n","'use strict';\n\nmodule.exports = function only_once(fn) {\n    return function() {\n        if (fn === null) throw new Error('Callback was already called.');\n        fn.apply(this, arguments);\n        fn = null;\n    };\n};\n","'use strict';\nmodule.exports = function restParam(func, startIndex) {\n    startIndex = startIndex == null ? func.length - 1 : +startIndex;\n    return function() {\n        var length = Math.max(arguments.length - startIndex, 0);\n        var rest = new Array(length);\n        for (var index = 0; index < length; index++) {\n            rest[index] = arguments[index + startIndex];\n        }\n        switch (startIndex) {\n            case 0:\n                return func.call(this, rest);\n            case 1:\n                return func.call(this, arguments[0], rest);\n        }\n    };\n};\n","'use strict';\n\nvar _setImmediate = typeof setImmediate === 'function' && setImmediate;\nvar fallback = function(fn) {\n    setTimeout(fn, 0);\n};\n\nmodule.exports = function setImmediate(fn) {\n    // not a direct alias for IE10 compatibility\n    return (_setImmediate || fallback)(fn);\n};\n","'use strict';\n\nmodule.exports = function withoutIndex(iterator) {\n    return function(value, index, callback) {\n        return iterator(value, callback);\n    };\n};\n","'use strict';\n\nvar once = require('async.util.once');\nvar noop = require('async.util.noop');\nvar isArray = require('async.util.isarray');\nvar restParam = require('async.util.restparam');\nvar ensureAsync = require('async.util.ensureasync');\nvar iterator = require('async.iterator');\n\nmodule.exports = function(tasks, cb) {\n    cb = once(cb || noop);\n    if (!isArray(tasks)) return cb(new Error('First argument to waterfall must be an array of functions'));\n    if (!tasks.length) return cb();\n\n    function wrapIterator(iterator) {\n        return restParam(function(err, args) {\n            if (err) {\n                cb.apply(null, [err].concat(args));\n            } else {\n                var next = iterator.next();\n                if (next) {\n                    args.push(wrapIterator(next));\n                } else {\n                    args.push(cb);\n                }\n                ensureAsync(iterator).apply(null, args);\n            }\n        });\n    }\n    wrapIterator(iterator(tasks))();\n};\n","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\n/**\n* Data Arithmatic\n*\n* @class DataArithmatic\n*/\nclass DataArithmatic\n{\n\tconstructor()\n\t{\n\t\t// Regular Expressions (so they don't have to be recompiled every time)\n\t\t// These could be defined as static, but I'm not sure if that will work with browserify ... and specifically the QT browser.\n\t\tthis._Regex_formatterInsertCommas = /.{1,3}/g;\n\t\t// Match Function:\n\t\t// function(pMatch, pSign, pZeros, pBefore, pDecimal, pAfter)\n\t\t// Thoughts about below:   /^([+-]?)(0*)(\\d+)(\\.(\\d+))?$/;\n\t\tthis._Regex_formatterAddCommasToNumber = /^([-+]?)(0?)(\\d+)(.?)(\\d+)$/g;\n\t\tthis._Regex_formatterDollarsRemoveCommas = /,/gi;\n\t\tthis._Regex_formatterCleanNonAlpha = /[^a-z0-9]/gi;\n\n\t\t// TODO: Potentially pull these in from a configuration.\n\t\t// TODO: Use locale data for this if it's defaults all the way down.\n\t\tthis._Value_MoneySign_Currency = '$';\n\t\tthis._Value_NaN_Currency = '--';\n\t\tthis._Value_GroupSeparator_Number = ',';\n\n\t\tthis._Value_Prefix_StringHash = 'HSH';\n\t\tthis._Value_Clean_formatterCleanNonAlpha = '_';\n\n\t\tthis._UseEngineStringStartsWith = (typeof(String.prototype.startsWith) === 'function');\n\t\tthis._UseEngineStringEndsWith = (typeof(String.prototype.endsWith) === 'function');\n\t}\n\n\n\t/*************************************************************************\n\t * String Manipulation and Comparison Functions\n\t *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/\n\n\t/**\n\t * Reverse a string\n\t *\n\t * @param {string} pString - The string to reverse\n\t * @returns {string}\n\t */\n\tstringReverse (pString)\n\t{\n\t\t// TODO: Benchmark if there are faster ways we want to do this with all the newer JS stuff\n\t\t//       ... and if it will work with browserify in a clean way.\n\t    return pString.split('').reverse().join('');\n\t}\n\n\t/**\n\t * Test if a string starts with a given substring.\n\t *\n\t * @param {*} pString\n\t * @param {*} pSearchString\n\t * @param {*} pStartIndex\n\t * @returns {*}\n\t */\n\tstringStartsWith (pString, pSearchString, pStartIndex)\n\t{\n\t\tif (this._UseEngineStringStartsWith)\n\t\t{\n\t\t\treturn pString.startsWith(pSearchString, pStartIndex);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.stringStartsWith_Polyfill.call(pString, pSearchString, pStartIndex);\n\t\t}\n\t}\n\n\t/**\n\t * Check if a string starts with a given substring.  This is a safe polyfill for the ES6 string.startsWith() function.\n\t *\n\t * @param {*} pSearchString - The string to search for\n\t * @param {*} pStartIndex - The index to start the search at\n\t * @returns {boolean}\n\t */\n\tstringStartsWith_Polyfill (pSearchString, pStartIndex)\n\t{\n\t\treturn this.slice(pStartIndex || 0, pSearchString.length) === pSearchString;\n\t}\n\n\t/**\n\t * Test if a string starts with a given substring.\n\t *\n\t * @param {*} pString\n\t * @param {*} pSearchString\n\t * @param {*} pEndIndex\n\t * @returns {*}\n\t */\n\tstringEndsWith (pString, pSearchString, pEndIndex)\n\t{\n\t\tif (this._UseEngineStringEndsWith)\n\t\t{\n\t\t\treturn pString.endsWith(pSearchString, pEndIndex);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.stringEndsWith_Polyfill.call(pString, pSearchString, pEndIndex);\n\t\t}\n\t}\n\n\t/**\n\t * Check if a string starts with a given substring.  This is a safe polyfill for the ES6 string.startsWith() function.\n\t *\n\t * @param {*} pSearchString - The string to search for\n\t * @param {*} pEndIndex - The index to end the search at\n\t * @returns {boolean}\n\t */\n\tstringEndsWith_Polyfill (pSearchString, pEndIndex)\n\t{\n\t\t// This works much better than >= because\n\t\t// it compensates for NaN:\n\t\tif (!(pEndIndex < this.length))\n\t\t{\n\t\t\tpEndIndex = this.length;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpEndIndex |= 0; // round position\n\t\t}\n\t\treturn this.substr(pEndIndex - pSearchString.length, pSearchString.length) === pSearchString;\n\t}\n\n\t/**\n\t * Generate an insecure string hash.  Not meant to be secure, just a quick way to generate a hash for a string.  This is not a cryptographic hash.  Additional warranty and disclaimer ... this is not for passwords!\n\t *\n\t * @param {string} pString\n\t * @returns {string}\n\t */\n\tinsecureStringHash (pString)\n\t{\n\t    let tmpHash = 0;\n\t    let tmpStringLength = pString.length;\n\t    let tmpCharacterIndex = 0;\n\n\t    while (tmpCharacterIndex < tmpStringLength)\n\t    {\n\t        tmpHash = (tmpHash << 5) - tmpHash + pString.charCodeAt(tmpCharacterIndex++) | 0;\n\t    }\n\n\t    return `${this._Value_Prefix_StringHash}${tmpHash}`;\n\t}\n\n\t/**\n\t * Clean wrapping characters if they exist consistently around the string.  If they do not, the string is returned unchanged.\n\t *\n\t * @param {string} pWrapCharacter - The character expected as the wrapping character\n\t * @param {string} pString - the string to clean\n\t * @returns {string}\n\t */\n\tcleanEnclosureWrapCharacters (pWrapCharacter, pString)\n\t{\n\t\t// # Use case from ManyFest DSL:\n\t\t//\n\t\t// When a boxed property is passed in, it should have quotes of some\n\t\t// kind around it.\n\t\t//\n\t\t// For instance:\n\t\t// \t\tMyValues['Name']\n\t\t// \t\tMyValues[\"Age\"]\n\t\t// \t\tMyValues[`Cost`]\n\t\t//\n\t\t// This function is necessary to remove the wrapping quotes before object\n\t\t// resolution can occur.\n\t\tif (pString.startsWith(pWrapCharacter) && pString.endsWith(pWrapCharacter))\n\t\t{\n\t\t\treturn pString.substring(1, pString.length - 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn pString;\n\t\t}\n\t}\n\n\t/**\n\t *\n\t * @param {*} pString\n\t * @returns\n\t */\n\tcleanNonAlphaCharacters (pString)\n\t{\n\t    if ((typeof(pString) == 'string') && (pString != ''))\n\t    {\n\t        return pString.replace(this._Regex_formatterCleanNonAlpha, this._Value_Clean_formatterCleanNonAlpha);\n\t    }\n\t}\n\n\n\t/*************************************************************************\n\t * Number Formatting Functions\n\t *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/\n\n\t/**\n\t * Insert commas every 3 characters from the right.  Used by formatterAddCommasToNumber().\n\t *\n\t * @param {*} pString\n\t * @returns {*}\n\t */\n\tformatterInsertCommas (pString)\n\t{\n\t    // Reverse, because it's easier to do things from the left, given arbitrary digit counts\n\t    let tmpReversed = this.stringReverse(pString);\n\t    // Add commas every three characters\n\t    let tmpReversedWithCommas = tmpReversed.match(this._Regex_formatterInsertCommas).join(',');\n\t    // Reverse again (back to normal direction)\n\t    return this.stringReverse(tmpReversedWithCommas);\n\t}\n\n\tprocessAddCommasToNumberRegex(pMatch, pSign, pZeros, pBefore, pDecimal, pAfter)\n\t{\n\t\t// If there was no decimal, the last capture grabs the final digit, so\n\t\t// we have to put it back together with the 'before' substring\n\t\treturn pSign + (pDecimal ? this.formatterInsertCommas(pBefore) + pDecimal + pAfter : this.formatterInsertCommas(pBefore + pAfter));\n\t}\n\n\t/**\n\t * Add Commas to a Number for readability.\n\t *\n\t * @param {*} pNumber\n\t * @returns {string}\n\t */\n\tformatterAddCommasToNumber (pNumber)\n\t{\n\t    // If the regex doesn't match, `replace` returns the string unmodified\n\t    return (pNumber.toString()).replace\n\t    (\n\t\t\tthis._Regex_formatterAddCommasToNumber,\n\t        this.processAddCommasToNumberRegex.bind(this)\n\t    );\n\t}\n\n\t/**\n\t * This will take a number and format it as a dollar string.  It will also add commas to the number.  If the number is not a number, it will return '--'.\n\t *\n\t * @param {*} pValue\n\t * @returns {string}\n\t */\n\tformatterDollars (pValue)\n\t{\n\t    let tmpDollarAmount = parseFloat(pValue).toFixed(2);\n\n\t    if (isNaN(tmpDollarAmount))\n\t    {\n\t        // Try again and see if what was passed in was a dollars string.\n\t        if (typeof(pValue) == 'string')\n\t        {\n\t\t\t\t// TODO: Better rounding function?  This is a hack to get rid of the currency symbol and commas.\n\t            tmpDollarAmount = parseFloat(pValue.replace(this._Value_MoneySign_Currency,'').replace(this._Regex_formatterDollarsRemoveCommas,'')).toFixed(2);\n\t        }\n\t\t\t// If we didn't get a number, return the \"not a number\" string.\n\t        if (isNaN(tmpDollarAmount))\n\t        {\n\t            return this._Value_NaN_Currency;\n\t        }\n\t    }\n\n\t    // TODO: Get locale data and use that for this stuff.\n\t    return `$${this.formatterAddCommasToNumber(tmpDollarAmount)}`;\n\t}\n\n\t/**\n\t * Round a number to a certain number of digits.  If the number is not a number, it will return 0.  If no digits are specified, it will default to 2 significant digits.\n\t *\n\t * @param {*} pValue\n\t * @param {number} pDigits\n\t * @returns {string}\n\t */\n\tformatterRoundNumber (pValue, pDigits)\n\t{\n\t    let tmpDigits = (typeof(pDigits) == 'undefined') ? 2 : pDigits;\n\n\t    let tmpValue = parseFloat(pValue).toFixed(tmpDigits);\n\t    if (isNaN(tmpValue))\n\t    {\n\t        let tmpZed = 0;\n\t        return tmpZed.toFixed(tmpDigits);\n\t    }\n\t    else\n\t    {\n\t        return tmpValue;\n\t    }\n\t}\n\n\n\t/*************************************************************************\n\t * String Tokenization Functions\n\t *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/\n\n\t/**\n\t * Return the string before the matched substring.\n\t *\n\t * If the substring is not found, the entire string is returned.  This only deals with the *first* match.\n\t *\n\t * @param {string} pString\n\t * @param {string} pMatch\n\t * @returns {string}\n\t */\n\tstringBeforeMatch (pString, pMatch)\n\t{\n\t\treturn pString.split(pMatch)[0];\n\t}\n\n\t/**\n\t * Return the string after the matched substring.\n\t *\n\t * If the substring is not found, an empty string is returned.  This only deals with the *first* match.\n\t *\n\t * @param {string} pString\n\t * @param {string} pMatch\n\t * @returns {string}\n\t */\n\tstringAfterMatch (pString, pMatch)\n\t{\n\t    let tmpStringSplitLocation = pString.indexOf(pMatch);\n\n\t\tif ((tmpStringSplitLocation < 0) || ((tmpStringSplitLocation + pMatch.length) >= pString.length))\n\t    {\n\t        return '';\n\t    }\n\n\t    return pString.substring(tmpStringSplitLocation + pMatch.length);\n\t}\n\n\t/**\n\t * Count the number of enclosures in a string based on the start and end characters.\n\t *\n\t * If no start or end characters are specified, it will default to parentheses.  If the string is not a string, it will return 0.\n\t *\n\t * @param {string} pString\n\t * @param {string} pEnclosureStart\n\t * @param {string} pEnclosureEnd\n\t * @returns the count of full in the string\n\t */\n\tstringCountEnclosures (pString, pEnclosureStart, pEnclosureEnd)\n\t{\n\t    let tmpString = (typeof(pString) == 'string') ? pString : '';\n\t    let tmpEnclosureStart = (typeof(pEnclosureStart) == 'string') ? pEnclosureStart : '(';\n\t    let tmpEnclosureEnd = (typeof(pEnclosureEnd) == 'string') ? pEnclosureEnd : ')';\n\n\t    let tmpEnclosureCount = 0;\n\t    let tmpEnclosureDepth = 0;\n\t    for (let i = 0; i < tmpString.length; i++)\n\t    {\n\t        // This is the start of an enclosure\n\t        if (tmpString[i] == tmpEnclosureStart)\n\t        {\n\t            if (tmpEnclosureDepth == 0)\n\t            {\n\t                tmpEnclosureCount++;\n\t            }\n\t            tmpEnclosureDepth++;\n\t        }\n\t        else if (tmpString[i] == tmpEnclosureEnd)\n\t        {\n\t            tmpEnclosureDepth--;\n\t        }\n\t    }\n\n\t    return tmpEnclosureCount;\n\t}\n\n\n\t/**\n\t * Get the value of the enclosure at the specified index.\n\t *\n\t * If the index is not a number, it will default to 0.  If the string is not a string, it will return an empty string.  If the enclosure is not found, it will return an empty string.  If the enclosure\n\t *\n\t * @param {string} pString\n\t * @param {number} pEnclosureIndexToGet\n\t * @param {string} pEnclosureStart\n\t * @param {string}} pEnclosureEnd\n\t * @returns {string}\n\t */\n\tstringGetEnclosureValueByIndex (pString, pEnclosureIndexToGet, pEnclosureStart, pEnclosureEnd)\n\t{\n\t    let tmpString = (typeof(pString) == 'string') ? pString : '';\n\t    let tmpEnclosureIndexToGet = (typeof(pEnclosureIndexToGet) == 'number') ? pEnclosureIndexToGet : 0;\n\t    let tmpEnclosureStart = (typeof(pEnclosureStart) == 'string') ? pEnclosureStart : '(';\n\t    let tmpEnclosureEnd = (typeof(pEnclosureEnd) == 'string') ? pEnclosureEnd : ')';\n\n\t    let tmpEnclosureCount = 0;\n\t    let tmpEnclosureDepth = 0;\n\n\t\tlet tmpMatchedEnclosureIndex = false;\n\t    let tmpEnclosedValueStartIndex = 0;\n\t    let tmpEnclosedValueEndIndex = 0;\n\n\t    for (let i = 0; i < tmpString.length; i++)\n\t    {\n\t        // This is the start of an enclosure\n\t        if (tmpString[i] == tmpEnclosureStart)\n\t        {\n\t            tmpEnclosureDepth++;\n\n\t\t\t\t// Only count enclosures at depth 1, but still this parses both pairs of all of them.\n\t\t\t\tif (tmpEnclosureDepth == 1)\n\t\t\t\t{\n\t\t\t\t\ttmpEnclosureCount++;\n\t\t\t\t\tif (tmpEnclosureIndexToGet == (tmpEnclosureCount - 1))\n\t\t\t\t\t{\n\t\t\t\t\t\t// This is the start of *the* enclosure\n\t\t\t\t\t\ttmpMatchedEnclosureIndex = true;\n\t\t\t\t\t\ttmpEnclosedValueStartIndex = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t        }\n\t\t\t// This is the end of an enclosure\n\t        else if (tmpString[i] == tmpEnclosureEnd)\n\t        {\n\t            tmpEnclosureDepth--;\n\n\t\t\t\t// Again, only count enclosures at depth 1, but still this parses both pairs of all of them.\n\t\t\t\tif ((tmpEnclosureDepth == 0) &&\n\t\t\t\t\ttmpMatchedEnclosureIndex &&\n\t\t\t\t\t(tmpEnclosedValueEndIndex <= tmpEnclosedValueStartIndex))\n\t\t\t\t{\n\t\t\t\t\ttmpEnclosedValueEndIndex = i;\n\t\t\t\t\ttmpMatchedEnclosureIndex = false;\n\t\t\t\t}\n\t        }\n\t    }\n\n\t    if (tmpEnclosureCount <= tmpEnclosureIndexToGet)\n\t    {\n\t\t\t// Return an empty string if the enclosure is not found\n\t        return '';\n\t    }\n\n\t    if ((tmpEnclosedValueEndIndex > 0) && (tmpEnclosedValueEndIndex > tmpEnclosedValueStartIndex))\n\t    {\n\t        return tmpString.substring(tmpEnclosedValueStartIndex+1, tmpEnclosedValueEndIndex);\n\t    }\n\t    else\n\t    {\n\t        return tmpString.substring(tmpEnclosedValueStartIndex+1);\n\t    }\n\t}\n\n\n\t/**\n\t * Remove an enclosure from a string based on the index of the enclosure.\n\t *\n\t * @param {string} pString\n\t * @param {number} pEnclosureIndexToRemove\n\t * @param {number} pEnclosureStart\n\t * @param {number} pEnclosureEnd\n\t * @returns {string}\n\t */\n\tstringRemoveEnclosureByIndex (pString, pEnclosureIndexToRemove, pEnclosureStart, pEnclosureEnd)\n\t{\n\t    let tmpString = (typeof(pString) == 'string') ? pString : '';\n\t    let tmpEnclosureIndexToRemove = (typeof(pEnclosureIndexToRemove) == 'number') ? pEnclosureIndexToRemove : 0;\n\t    let tmpEnclosureStart = (typeof(pEnclosureStart) == 'string') ? pEnclosureStart : '(';\n\t    let tmpEnclosureEnd = (typeof(pEnclosureEnd) == 'string') ? pEnclosureEnd : ')';\n\n\t    let tmpEnclosureCount = 0;\n\t    let tmpEnclosureDepth = 0;\n\n\t\tlet tmpMatchedEnclosureIndex = false;\n\t    let tmpEnclosureStartIndex = 0;\n\t    let tmpEnclosureEndIndex = 0;\n\n\t    for (let i = 0; i < tmpString.length; i++)\n\t    {\n\t        // This is the start of an enclosure\n\t        if (tmpString[i] == tmpEnclosureStart)\n\t        {\n\t            tmpEnclosureDepth++;\n\n\t            if (tmpEnclosureDepth == 1)\n\t            {\n\t                tmpEnclosureCount++;\n\t\t\t\t\tif (tmpEnclosureIndexToRemove == (tmpEnclosureCount - 1))\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpMatchedEnclosureIndex = true;\n\t\t\t\t\t\ttmpEnclosureStartIndex = i;\n\t\t\t\t\t}\n\t            }\n\t        }\n\t        else if (tmpString[i] == tmpEnclosureEnd)\n\t        {\n\t            tmpEnclosureDepth--;\n\n\t\t\t\tif ((tmpEnclosureDepth == 0) &&\n\t\t\t\t\ttmpMatchedEnclosureIndex &&\n\t\t\t\t\t(tmpEnclosureEndIndex <= tmpEnclosureStartIndex))\n\t\t\t\t{\n\t\t\t\t\ttmpEnclosureEndIndex = i;\n\t\t\t\t\ttmpMatchedEnclosureIndex = false;\n\t\t\t\t}\n\t        }\n\t    }\n\n\t    if (tmpEnclosureCount <= tmpEnclosureIndexToRemove)\n\t    {\n\t        return tmpString;\n\t    }\n\n\t    let tmpReturnString = '';\n\n\t    if (tmpEnclosureStartIndex > 1)\n\t    {\n\t        tmpReturnString = tmpString.substring(0, tmpEnclosureStartIndex);\n\t    }\n\n\t    if ((tmpString.length > (tmpEnclosureEndIndex + 1)) && (tmpEnclosureEndIndex > tmpEnclosureStartIndex))\n\t    {\n\t        tmpReturnString += tmpString.substring(tmpEnclosureEndIndex+1);\n\t    }\n\n\t    return tmpReturnString;\n\t}\n}\n\nmodule.exports = DataArithmatic;","/**\n* Base Logger Class\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\nclass BaseLogger\n{\n\tconstructor(pLogStreamSettings, pFableLog)\n\t{\n\t\t// This should not possibly be able to be instantiated without a settings object\n\t\tthis._Settings = (typeof(pLogStreamSettings) == 'object') ? pLogStreamSettings : {};\n\n\t\t// The base logger does nothing but associate a UUID with itself\n\t\t// We added this as the mechanism for tracking loggers to allow multiple simultaneous streams\n\t\t// to the same provider.\n\t\tthis.loggerUUID = this.generateInsecureUUID();\n\n\t\t// Eventually we can use this array to ompute which levels the provider allows.\n\t\t// For now it's just used to precompute some string concatenations.\n\t\tthis.levels = (\n\t\t\t[\n\t\t\t\t\"trace\",\n\t\t\t\t\"debug\",\n\t\t\t\t\"info\",\n\t\t\t\t\"warn\",\n\t\t\t\t\"error\",\n\t\t\t\t\"fatal\"\n\t\t\t]);\n\t}\n\n\t// This is meant to generate programmatically insecure UUIDs to identify loggers\n\tgenerateInsecureUUID()\n\t{\n\t\tlet tmpDate = new Date().getTime();\n\t\tlet tmpUUID = 'LOGSTREAM-xxxxxx-yxxxxx'.replace(/[xy]/g,\n\t\t\t\t(pCharacter) =>\n\t\t\t\t{\n\t\t\t\t\t// Funny algorithm from w3resource that is twister-ish without the deep math and security\n\t\t\t\t\t// ..but good enough for unique log stream identifiers\n\t\t\t\t\tlet tmpRandomData = (tmpDate + Math.random()*16)%16 | 0;\n\t\t\t\t\ttmpDate = Math.floor(tmpDate/16);\n\n\t\t\t\t\treturn (pCharacter =='x' ? tmpRandomData : (tmpRandomData&0x3|0x8)).toString(16);\n\t\t\t\t});\n\t\treturn tmpUUID;\n\t}\n\n\tinitialize()\n\t{\n\t\t// No operation.\n\t}\n\n\ttrace(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"trace\", pLogText, pLogObject);\n\t}\n\n\tdebug(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"debug\", pLogText, pLogObject);\n\t}\n\n\tinfo(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"info\", pLogText, pLogObject);\n\t}\n\n\twarn(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"warn\", pLogText, pLogObject);\n\t}\n\n\terror(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"error\", pLogText, pLogObject);\n\t}\n\n\tfatal(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"fatal\", pLogText, pLogObject);\n\t}\n\n\twrite(pLogLevel, pLogText, pLogObject)\n\t{\n\t\t// The base logger does nothing.\n\t\treturn true;\n\t}\n}\n\nmodule.exports = BaseLogger;\n","/**\n* Default Logger Provider Function\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\n// Return the providers that are available without extensions loaded\nvar getDefaultProviders = () =>\n{\n\tlet tmpDefaultProviders = {};\n\n\ttmpDefaultProviders.console = require('./Fable-Log-Logger-Console.js');\n\n\ttmpDefaultProviders.default = tmpDefaultProviders.console;\n\n\treturn tmpDefaultProviders;\n}\n\nmodule.exports = getDefaultProviders();","module.exports=[\n    {\n        \"loggertype\": \"console\",\n        \"streamtype\": \"console\",\n        \"level\": \"trace\"\n    }\n]","let libBaseLogger = require('./Fable-Log-BaseLogger.js');\n\nclass ConsoleLogger extends libBaseLogger\n{\n\tconstructor(pLogStreamSettings, pFableLog)\n\t{\n\t\tsuper(pLogStreamSettings);\n\n\t\tthis._ShowTimeStamps = this._Settings.hasOwnProperty('showtimestamps') ? (this._Settings.showtimestamps == true) : true;\n\t\tthis._FormattedTimeStamps = this._Settings.hasOwnProperty('formattedtimestamps') ? (this._Settings.formattedtimestamps == true) : true;\n\n\t\tthis._ContextMessage = this._Settings.hasOwnProperty('Context') ? `(${this._Settings.Context})` : \n\t\t\t\t\t\t\t\tpFableLog._Settings.hasOwnProperty('Product') ? `(${pFableLog._Settings.Product})` :\n\t\t\t\t\t\t\t\t'Unnamed_Log_Context';\n\n\t\t// Allow the user to decide what gets output to the console\n\t\tthis._OutputLogLinesToConsole = this._Settings.hasOwnProperty('outputloglinestoconsole') ? this._Settings.outputloglinestoconsole : true;\n\t\tthis._OutputObjectsToConsole = this._Settings.hasOwnProperty('outputobjectstoconsole') ? this._Settings.outputobjectstoconsole : true;\n\n\t\t// Precompute the prefix for each level\n\t\tthis.prefixCache = {};\n\t\tfor (let i = 0; i <= this.levels.length; i++)\n\t\t{\n\t\t\tthis.prefixCache[this.levels[i]] = `[${this.levels[i]}] ${this._ContextMessage}: `;\n\n\t\t\tif (this._ShowTimeStamps)\n\t\t\t{\n\t\t\t\t// If there is a timestamp we need a to prepend space before the prefixcache string, since the timestamp comes first\n\t\t\t\tthis.prefixCache[this.levels[i]] = ' '+this.prefixCache[this.levels[i]];\n\t\t\t}\n\t\t}\n\t}\n\n\twrite(pLevel, pLogText, pObject)\n\t{\n\t\tlet tmpTimeStamp = '';\n\t\tif (this._ShowTimeStamps && this._FormattedTimeStamps)\n\t\t{\n\t\t\ttmpTimeStamp = (new Date()).toISOString();\n\t\t}\n\t\telse if (this._ShowTimeStamps)\n\t\t{\n\t\t\ttmpTimeStamp = +new Date();\n\t\t}\n\n\t\tlet tmpLogLine = `${tmpTimeStamp}${this.prefixCache[pLevel]}${pLogText}`;\n\n\t\tif (this._OutputLogLinesToConsole)\n\t\t{\n\t\t\tconsole.log(tmpLogLine);\n\t\t}\n\n\t\t// Write out the object on a separate line if it is passed in\n\t\tif (this._OutputObjectsToConsole && (typeof(pObject) !== 'undefined'))\n\t\t{\n\t\t\tconsole.log(JSON.stringify(pObject, null, 2));\n\t\t}\n\n\t\t// Provide an easy way to be overridden and be consistent\n\t\treturn tmpLogLine;\n\t}\n}\n\nmodule.exports = ConsoleLogger;","const libConsoleLog = require('./Fable-Log-Logger-Console.js');\nconst libFS = require('fs');\nconst libPath = require('path');\n\nclass SimpleFlatFileLogger extends libConsoleLog\n{\n\tconstructor(pLogStreamSettings, pFableLog)\n\t{\n\t\tsuper(pLogStreamSettings, pFableLog);\n\n\t\t// If a path isn't provided for the logfile, it tries to use the ProductName or Context\n\t\tthis.logFileRawPath = (this._Settings.hasOwnProperty('path')) ? this._Settings.path : `./${this._ContextMessage}.log`;\n\t\tthis.logFilePath = libPath.normalize(this.logFileRawPath);\n\n\t\tthis.logFileStreamOptions = (this._Settings.hasOwnProperty('fileStreamoptions')) ? this._Settings.fileStreamOptions : (\n\t\t\t{\n\t\t\t\t\"flags\": \"a\",\n\t\t\t\t\"encoding\": \"utf8\"\n\t\t\t})\n\n\t\tthis.fileWriter = libFS.createWriteStream(this.logFilePath, this.logFileStreamOptions);\n\n\t\tthis.activelyWriting = false;\n\n\t\tthis.logLineStrings = [];\n\t\tthis.logObjectStrings = [];\n\n\t\tthis.defaultWriteCompleteCallback = ()=>{};\n\t\tthis.defaultBufferFlushCallback = ()=>{};\n\t}\n\n\tcloseWriter(fCloseComplete)\n\t{\n\t\tlet tmpCloseComplete = (typeof(fCloseComplete) == 'function') ? fCloseComplete : ()=>{};\n\t\tif (this.fileWriter)\n\t\t{\n\t\t\tthis.fileWriter.end('\\n');\n\t\t\treturn this.fileWriter.once('finish', tmpCloseComplete.bind(this));\n\t\t}\n\t};\n\n\tcompleteBufferFlushToLogFile(fFlushComplete)\n\t{\n\t\tthis.activelyWriting = false;\n\t\tlet tmpFlushComplete = (typeof(fFlushComplete) == 'function') ? fFlushComplete : this.defaultBufferFlushCallback;\n\n\t\tif (this.logLineStrings.length > 0)\n\t\t{\n\t\t\tthis.flushBufferToLogFile(tmpFlushComplete);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn tmpFlushComplete();\n\t\t}\n\t}\n\n\tflushBufferToLogFile(fFlushComplete)\n\t{\n\t\tif (!this.activelyWriting)\n\t\t{\n\t\t\t// Only want to be writing one thing at a time....\n\t\t\tthis.activelyWriting = true;\n\n\t\t\tlet tmpFlushComplete = (typeof(fFlushComplete) == 'function') ? fFlushComplete : this.defaultBufferFlushCallback;\n\n\t\t\t// Get the current buffer arrays.  These should always have matching number of elements.\n\t\t\tlet tmpLineStrings = this.logLineStrings;\n\t\t\tlet tmpObjectStrings = this.logObjectStrings;\n\n\t\t\t// Reset these to be filled while we process this queue...\n\t\t\tthis.logLineStrings = [];\n\t\t\tthis.logObjectStrings = [];\n\n\t\t\t// This is where we will put each line before writing it to the file...\n\t\t\tlet tmpConstructedBufferOutputString = '';\n\n\t\t\tfor (let i = 0; i < tmpLineStrings.length; i++)\n\t\t\t{\n\t\t\t\t// TODO: Windows Newline?   ....... yo no se!\n\t\t\t\ttmpConstructedBufferOutputString += `${tmpLineStrings[i]}\\n`;\n\t\t\t\tif (tmpObjectStrings[i] !== false)\n\t\t\t\t{\n\t\t\t\t\ttmpConstructedBufferOutputString += `${tmpObjectStrings[i]}\\n`;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!this.fileWriter.write(tmpConstructedBufferOutputString, 'utf8'))\n\t\t\t{\n\t\t\t\t// If the streamwriter returns false, we need to wait for it to drain.\n\t\t\t\tthis.fileWriter.once('drain', this.completeBufferFlushToLogFile.bind(this, tmpFlushComplete));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn this.completeBufferFlushToLogFile(tmpFlushComplete);\n\t\t\t}\n\t\t}\n\t}\n\n\twrite(pLevel, pLogText, pObject)\n\t{\n\t\tlet tmpLogLine = super.write(pLevel, pLogText, pObject);\n\n\t\t// Use a very simple array as the write buffer\n\t\tthis.logLineStrings.push(tmpLogLine);\n\n\t\t// Write out the object on a separate line if it is passed in\n\t\tif (typeof(pObject) !== 'undefined')\n\t\t{\n\t\t\tthis.logObjectStrings.push(JSON.stringify(pObject, null, 4));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logObjectStrings.push(false);\n\t\t}\n\n\t\tthis.flushBufferToLogFile();\n\t}\n}\n\nmodule.exports = SimpleFlatFileLogger;","/**\n* Fable Logging Add-on\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable Logger\n*/\n\n/**\n* Fable Solution Log Wrapper Main Class\n*\n* @class FableLog\n* @constructor\n*/\nclass FableLog\n{\n\tconstructor(pFableSettings, pFable)\n\t{\n\t\tlet tmpSettings = (typeof(pFableSettings) === 'object') ? pFableSettings : {}\n\t\tthis._Settings = tmpSettings;\n\n\t\tthis._Providers = require('./Fable-Log-DefaultProviders-Node.js');\n\n\t\tthis._StreamDefinitions = (tmpSettings.hasOwnProperty('LogStreams')) ? tmpSettings.LogStreams : require('./Fable-Log-DefaultStreams.json');\n\n\t\tthis.logStreams = [];\n\n\t\t// This object gets decorated for one-time instantiated providers that\n\t\t//  have multiple outputs, such as bunyan.\n\t\tthis.logProviders = {};\n\n\t\t// A hash list of the GUIDs for each log stream, so they can't be added to the set more than one time\n\t\tthis.activeLogStreams = {};\n\n\t\tthis.logStreamsTrace = [];\n\t\tthis.logStreamsDebug = [];\n\t\tthis.logStreamsInfo = [];\n\t\tthis.logStreamsWarn = [];\n\t\tthis.logStreamsError = [];\n\t\tthis.logStreamsFatal = [];\n\n\t\tthis.datumDecorator = (pDatum) => pDatum;\n\n\t\tthis.uuid = (typeof(tmpSettings.Product) === 'string') ? tmpSettings.Product : 'Default';\n\t}\n\n\taddLogger(pLogger, pLevel)\n\t{\n\t\t// Bail out if we've already created one.\n\t\tif (this.activeLogStreams.hasOwnProperty(pLogger.loggerUUID))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// Add it to the streams and to the mutex\n\t\tthis.logStreams.push(pLogger);\n\t\tthis.activeLogStreams[pLogger.loggerUUID] = true;\n\n\t\t// Make sure a kosher level was passed in\n\t\tswitch (pLevel)\n\t\t{\n\t\t\tcase 'trace':\n\t\t\t\tthis.logStreamsTrace.push(pLogger);\n\t\t\tcase 'debug':\n\t\t\t\tthis.logStreamsDebug.push(pLogger);\n\t\t\tcase 'info':\n\t\t\t\tthis.logStreamsInfo.push(pLogger);\n\t\t\tcase 'warn':\n\t\t\t\tthis.logStreamsWarn.push(pLogger);\n\t\t\tcase 'error':\n\t\t\t\tthis.logStreamsError.push(pLogger);\n\t\t\tcase 'fatal':\n\t\t\t\tthis.logStreamsFatal.push(pLogger);\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tsetDatumDecorator(fDatumDecorator)\n\t{\n\t\tif (typeof(fDatumDecorator) === 'function')\n\t\t{\n\t\t\tthis.datumDecorator = fDatumDecorator;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.datumDecorator = (pDatum) => pDatum;\n\t\t}\n\t}\n\n\ttrace(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsTrace.length; i++)\n\t\t{\n\t\t\tthis.logStreamsTrace[i].trace(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tdebug(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsDebug.length; i++)\n\t\t{\n\t\t\tthis.logStreamsDebug[i].debug(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tinfo(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsInfo.length; i++)\n\t\t{\n\t\t\tthis.logStreamsInfo[i].info(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\twarn(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsWarn.length; i++)\n\t\t{\n\t\t\tthis.logStreamsWarn[i].warn(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\terror(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsError.length; i++)\n\t\t{\n\t\t\tthis.logStreamsError[i].error(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tfatal(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsFatal.length; i++)\n\t\t{\n\t\t\tthis.logStreamsFatal[i].fatal(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tinitialize()\n\t{\n\t\t// \"initialize\" each logger as defined in the logging parameters\n\t\tfor (let i = 0; i < this._StreamDefinitions.length; i++)\n\t\t{\n\t\t\tlet tmpStreamDefinition = Object.assign({loggertype:'default',streamtype:'console',level:'info'},this._StreamDefinitions[i]);\n\n\t\t\tif (!this._Providers.hasOwnProperty(tmpStreamDefinition.loggertype))\n\t\t\t{\n\t\t\t\tconsole.log(`Error initializing log stream: bad loggertype in stream definition ${JSON.stringify(tmpStreamDefinition)}`);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.addLogger(new this._Providers[tmpStreamDefinition.loggertype](tmpStreamDefinition, this), tmpStreamDefinition.level);\n\t\t\t}\n\t\t}\n\n\t\t// Now initialize each one.\n\t\tfor (let i = 0; i < this.logStreams.length; i++)\n\t\t{\n\t\t\tthis.logStreams[i].initialize();\n\t\t}\n\t}\n\n\tlogTime(pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time';\n\t\tlet tmpTime = new Date();\n\t\tthis.info(`${tmpMessage} ${tmpTime} (epoch ${+tmpTime})`, pDatum);\n\t}\n\n\t// Get a timestamp\n\tgetTimeStamp()\n\t{\n\t\treturn +new Date();\n\t}\n\n\tgetTimeDelta(pTimeStamp)\n\t{\n\t\tlet tmpEndTime = +new Date();\n\t\treturn tmpEndTime-pTimeStamp;\n\t}\n\n\t// Log the delta between a timestamp, and now with a message\n\tlogTimeDelta(pTimeDelta, pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time Measurement';\n\t\tlet tmpDatum = (typeof(pDatum) === 'object') ? pDatum : {};\n\n\t\tlet tmpEndTime = +new Date();\n\n\t\tthis.info(`${tmpMessage} logged at (epoch ${+tmpEndTime}) took (${pTimeDelta}ms)`, pDatum);\n\t}\n\n\tlogTimeDeltaHuman(pTimeDelta, pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time Measurement';\n\n\t\tlet tmpEndTime = +new Date();\n\n\t\tlet tmpMs = parseInt(pTimeDelta%1000);\n\t\tlet tmpSeconds = parseInt((pTimeDelta/1000)%60);\n\t\tlet tmpMinutes = parseInt((pTimeDelta/(1000*60))%60);\n\t\tlet tmpHours = parseInt(pTimeDelta/(1000*60*60));\n\n\t\ttmpMs = (tmpMs < 10) ? \"00\"+tmpMs : (tmpMs < 100) ? \"0\"+tmpMs : tmpMs;\n\t\ttmpSeconds = (tmpSeconds < 10) ? \"0\"+tmpSeconds : tmpSeconds;\n\t\ttmpMinutes = (tmpMinutes < 10) ? \"0\"+tmpMinutes : tmpMinutes;\n\t\ttmpHours = (tmpHours < 10) ? \"0\"+tmpHours : tmpHours;\n\n\t\tthis.info(`${tmpMessage} logged at (epoch ${+tmpEndTime}) took (${pTimeDelta}ms) or (${tmpHours}:${tmpMinutes}:${tmpSeconds}.${tmpMs})`, pDatum);\n\t}\n\n\tlogTimeDeltaRelative(pStartTime, pMessage, pDatum)\n\t{\n\t\tthis.logTimeDelta(this.getTimeDelta(pStartTime), pMessage, pDatum);\n\t}\n\n\tlogTimeDeltaRelativeHuman(pStartTime, pMessage, pDatum)\n\t{\n\t\tthis.logTimeDeltaHuman(this.getTimeDelta(pStartTime), pMessage, pDatum);\n\t}\n}\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new FableLog(pSettings);\n}\n\n\nmodule.exports = FableLog;\nmodule.exports.new = autoConstruct;\nmodule.exports.LogProviderBase = require('./Fable-Log-BaseLogger.js');\nmodule.exports.LogProviderConsole = require('./Fable-Log-Logger-Console.js');\nmodule.exports.LogProviderConsole = require('./Fable-Log-Logger-SimpleFlatFile.js');\n","module.exports={\n\t\"Product\": \"ApplicationNameHere\",\n\t\"ProductVersion\": \"0.0.0\",\n\n\t\"ConfigFile\": false,\n\n\t\"LogStreams\":\n\t[\n\t\t{\n\t\t\t\"level\": \"trace\"\n\t\t}\n\t]\n}\n","/**\n* Fable Settings Template Processor\n*\n* This class allows environment variables to come in via templated expressions, and defaults to be set.\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable Settings\n*/\n\nclass FableSettingsTemplateProcessor\n{\n\tconstructor(pDependencies)\n\t{\n        // Use a no-dependencies templating engine to parse out environment variables\n\t\tthis.templateProcessor = new pDependencies.precedent();\n\n        // TODO: Make the environment variable wrap expression demarcation characters configurable?\n\t\tthis.templateProcessor.addPattern('${', '}',\n\t\t\t(pTemplateValue)=>\n\t\t\t{\n\t\t\t\tlet tmpTemplateValue = pTemplateValue.trim();\n\n\t\t\t\tlet tmpSeparatorIndex = tmpTemplateValue.indexOf('|');\n\n\t\t\t\t// If there is no pipe, the default value will end up being whatever the variable name is.\n\t\t\t\tlet tmpDefaultValue = tmpTemplateValue.substring(tmpSeparatorIndex+1);\n\n\t\t\t\tlet tmpEnvironmentVariableName = (tmpSeparatorIndex > -1) ? tmpTemplateValue.substring(0, tmpSeparatorIndex) : tmpTemplateValue;\n\n\t\t\t\tif (process.env.hasOwnProperty(tmpEnvironmentVariableName))\n\t\t\t\t{\n\t\t\t\t\treturn process.env[tmpEnvironmentVariableName];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn tmpDefaultValue;\n\t\t\t\t}\n\t\t\t});\n    }\n\n    parseSetting(pString)\n    {\n        return this.templateProcessor.parseString(pString);\n    }\n}\n\nmodule.exports = FableSettingsTemplateProcessor;","/**\n* Fable Settings Add-on\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable Settings\n*/\n\nconst libPrecedent = require('precedent');\nconst libFableSettingsTemplateProcessor = require('./Fable-Settings-TemplateProcessor.js');\n\nclass FableSettings\n{\n\tconstructor(pFableSettings)\n\t{\n\t\t// Expose the dependencies for downstream re-use\n\t\tthis.dependencies = (\n\t\t\t{\n\t\t\t\tprecedent: libPrecedent\n\t\t\t});\n\n\t\t// Initialize the settings value template processor\n\t\tthis.settingsTemplateProcessor = new libFableSettingsTemplateProcessor(this.dependencies);\n\n\t\t// set straight away so anything that uses it respects the initial setting\n\t\tthis._configureEnvTemplating(pFableSettings);\n\n\t\tthis.default = this.buildDefaultSettings();\n\n\t\t// Construct a new settings object\n\t\tlet tmpSettings = this.merge(pFableSettings, this.buildDefaultSettings());\n\n\t\t// The base settings object (what they were on initialization, before other actors have altered them)\n\t\tthis.base = JSON.parse(JSON.stringify(tmpSettings));\n\n\t\tif (tmpSettings.DefaultConfigFile)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// If there is a DEFAULT configuration file, try to load and merge it.\n\t\t\t\ttmpSettings = this.merge(require(tmpSettings.DefaultConfigFile), tmpSettings);\n\t\t\t}\n\t\t\tcatch (pException)\n\t\t\t{\n\t\t\t\t// Why this?  Often for an app we want settings to work out of the box, but\n\t\t\t\t// would potentially want to have a config file for complex settings.\n\t\t\t\tconsole.log('Fable-Settings Warning: Default configuration file specified but there was a problem loading it.  Falling back to base.');\n\t\t\t\tconsole.log('     Loading Exception: '+pException);\n\t\t\t}\n\t\t}\n\n\t\tif (tmpSettings.ConfigFile)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// If there is a configuration file, try to load and merge it.\n\t\t\t\ttmpSettings = this.merge(require(tmpSettings.ConfigFile), tmpSettings);\n\t\t\t}\n\t\t\tcatch (pException)\n\t\t\t{\n\t\t\t\t// Why this?  Often for an app we want settings to work out of the box, but\n\t\t\t\t// would potentially want to have a config file for complex settings.\n\t\t\t\tconsole.log('Fable-Settings Warning: Configuration file specified but there was a problem loading it.  Falling back to base.');\n\t\t\t\tconsole.log('     Loading Exception: '+pException);\n\t\t\t}\n\t\t}\n\n\t\tthis.settings = tmpSettings;\n\t}\n\n\t// Build a default settings object.  Use the JSON jimmy to ensure it is always a new object.\n\tbuildDefaultSettings()\n\t{\n\t\treturn JSON.parse(JSON.stringify(require('./Fable-Settings-Default')));\n\t}\n\n\t// Update the configuration for environment variable templating based on the current settings object\n\t_configureEnvTemplating(pSettings)\n\t{\n\t\t// default environment variable templating to on\n\t\tthis._PerformEnvTemplating = !pSettings || pSettings.NoEnvReplacement !== true;\n\t}\n\n\t// Resolve (recursive) any environment variables found in settings object.\n\t_resolveEnv(pSettings)\n\t{\n\t\tfor (const tmpKey in pSettings)\n\t\t{\n\t\t\tif (typeof(pSettings[tmpKey]) === 'object')\n\t\t\t{\n\t\t\t\tthis._resolveEnv(pSettings[tmpKey]);\n\t\t\t}\n\t\t\telse if (typeof(pSettings[tmpKey]) === 'string')\n\t\t\t{\n\t\t\t\tpSettings[tmpKey] = this.settingsTemplateProcessor.parseSetting(pSettings[tmpKey]);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Check to see if a value is an object (but not an array).\n\t */\n\t_isObject(value)\n\t{\n\t\treturn typeof(value) === 'object' && !Array.isArray(value);\n\t}\n\n\t/**\n\t * Merge two plain objects. Keys that are objects in both will be merged property-wise.\n\t */\n\t_deepMergeObjects(toObject, fromObject)\n\t{\n\t\tif (!fromObject || !this._isObject(fromObject))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tObject.keys(fromObject).forEach((key) =>\n\t\t{\n\t\t\tconst fromValue = fromObject[key];\n\t\t\tif (this._isObject(fromValue))\n\t\t\t{\n\t\t\t\tconst toValue = toObject[key];\n\t\t\t\tif (toValue && this._isObject(toValue))\n\t\t\t\t{\n\t\t\t\t\t// both are objects, so do a recursive merge\n\t\t\t\t\tthis._deepMergeObjects(toValue, fromValue);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttoObject[key] = fromValue;\n\t\t});\n\t\treturn toObject;\n\t}\n\n\t// Merge some new object into the existing settings.\n\tmerge(pSettingsFrom, pSettingsTo)\n\t{\n\t\t// If an invalid settings from object is passed in (e.g. object constructor without passing in anything) this should still work\n\t\tlet tmpSettingsFrom = (typeof(pSettingsFrom) === 'object') ? pSettingsFrom : {};\n\t\t// Default to the settings object if none is passed in for the merge.\n\t\tlet tmpSettingsTo = (typeof(pSettingsTo) === 'object') ? pSettingsTo : this.settings;\n\n\t\t// do not mutate the From object property values\n\t\tlet tmpSettingsFromCopy = JSON.parse(JSON.stringify(tmpSettingsFrom));\n\t\ttmpSettingsTo = this._deepMergeObjects(tmpSettingsTo, tmpSettingsFromCopy);\n\n\t\tif (this._PerformEnvTemplating)\n\t\t{\n\t\t\tthis._resolveEnv(tmpSettingsTo);\n\t\t}\n\t\t// Update env tempating config, since we just updated the config object, and it may have changed\n\t\tthis._configureEnvTemplating(tmpSettingsTo);\n\n\t\treturn tmpSettingsTo;\n\t}\n\n\t// Fill in settings gaps without overwriting settings that are already there\n\tfill(pSettingsFrom)\n\t{\n\t\t// If an invalid settings from object is passed in (e.g. object constructor without passing in anything) this should still work\n\t\tlet tmpSettingsFrom = (typeof(pSettingsFrom) === 'object') ? pSettingsFrom : {};\n\n\t\t// do not mutate the From object property values\n\t\tlet tmpSettingsFromCopy = JSON.parse(JSON.stringify(tmpSettingsFrom));\n\n\t\tthis.settings = this._deepMergeObjects(tmpSettingsFromCopy, this.settings);\n\n\t\treturn this.settings;\n\t}\n};\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new FableSettings(pSettings);\n}\n\nmodule.exports = FableSettings;\nmodule.exports.new = autoConstruct;\nmodule.exports.precedent = libPrecedent;","/**\n* Random Byte Generator - Browser version\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\n// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\nclass RandomBytes\n{\n\tconstructor()\n\t{\n\n\t\t// getRandomValues needs to be invoked in a context where \"this\" is a Crypto\n\t\t// implementation. Also, find the complete implementation of crypto on IE11.\n\t\tthis.getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||\n                      \t\t(typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));\n\t}\n\n\t// WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n\tgenerateWhatWGBytes()\n\t{\n\t\tlet tmpBuffer = new Uint8Array(16); // eslint-disable-line no-undef\n\n\t\tthis.getRandomValues(tmpBuffer);\n\t\treturn tmpBuffer;\n\t}\n\n\t// Math.random()-based (RNG)\n\tgenerateRandomBytes()\n\t{\n\t\t// If all else fails, use Math.random().  It's fast, but is of unspecified\n\t\t// quality.\n\t\tlet tmpBuffer = new Uint8Array(16); // eslint-disable-line no-undef\n\n\t\tfor (let i = 0, tmpValue; i < 16; i++)\n\t\t{\n\t\t\tif ((i & 0x03) === 0)\n\t\t\t{\n\t\t\t\ttmpValue = Math.random() * 0x100000000;\n\t\t\t}\n\n\t\t\ttmpBuffer[i] = tmpValue >>> ((i & 0x03) << 3) & 0xff;\n\t\t}\n\n\t\treturn tmpBuffer;\n\t}\n\n\tgenerate()\n\t{\n\t\tif (this.getRandomValues)\n\t\t{\n\t\t\treturn this.generateWhatWGBytes();\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.generateRandomBytes();\n\t\t}\n\t}\n}\n\nmodule.exports = RandomBytes;\n","/**\n* Fable UUID Generator\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable UUID\n*/\n\n/**\n* Fable Solution UUID Generation Main Class\n*\n* @class FableUUID\n* @constructor\n*/\n\nvar libRandomByteGenerator = require('./Fable-UUID-Random.js')\n\nclass FableUUID\n{\n\tconstructor(pSettings)\n\t{\n\t\t// Determine if the module is in \"Random UUID Mode\" which means just use the random character function rather than the v4 random UUID spec.\n\t\t// Note this allows UUIDs of various lengths (including very short ones) although guaranteed uniqueness goes downhill fast.\n\t\tthis._UUIDModeRandom = (typeof(pSettings) === 'object') && (pSettings.hasOwnProperty('UUIDModeRandom')) ? (pSettings.UUIDModeRandom == true) : false;\n\t\t// These two properties are only useful if we are in Random mode.  Otherwise it generates a v4 spec\n\t\t// Length for \"Random UUID Mode\" is set -- if not set it to 8\n\t\tthis._UUIDLength = (typeof(pSettings) === 'object') && (pSettings.hasOwnProperty('UUIDLength')) ? (pSettings.UUIDLength + 0) : 8;\n\t\t// Dictionary for \"Random UUID Mode\"\n\t\tthis._UUIDRandomDictionary = (typeof(pSettings) === 'object') && (pSettings.hasOwnProperty('UUIDDictionary')) ? (pSettings.UUIDDictionary + 0) : '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n\n\t\tthis.randomByteGenerator = new libRandomByteGenerator();\n\n\t\t// Lookup table for hex codes\n\t\tthis._HexLookup = [];\n\t\tfor (let i = 0; i < 256; ++i)\n\t\t{\n\t\t\tthis._HexLookup[i] = (i + 0x100).toString(16).substr(1);\n\t\t}\n\t}\n\n\t// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n\tbytesToUUID(pBuffer)\n\t{\n\t\tlet i = 0;\n\t\t// join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n\t\treturn ([\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], \n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]]\n\t\t\t\t]).join('');\n\t}\n\n\t// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n\tgenerateUUIDv4()\n\t{\n\t\tlet tmpBuffer = new Array(16);\n\t\tvar tmpRandomBytes = this.randomByteGenerator.generate();\n\n\t\t// Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\t\ttmpRandomBytes[6] = (tmpRandomBytes[6] & 0x0f) | 0x40;\n\t\ttmpRandomBytes[8] = (tmpRandomBytes[8] & 0x3f) | 0x80;\n\n\t\treturn this.bytesToUUID(tmpRandomBytes);\n\t}\n\n\t// Simple random UUID generation\n\tgenerateRandom()\n\t{\n\t\tlet tmpUUID = '';\n\n\t\tfor (let i = 0; i < this._UUIDLength; i++)\n\t\t{\n\t\t\ttmpUUID += this._UUIDRandomDictionary.charAt(Math.floor(Math.random() * (this._UUIDRandomDictionary.length-1)));\n\t\t}\n\n\t\treturn tmpUUID;\n\t}\n\n\t// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n\tgetUUID()\n\t{\n\t\tif (this._UUIDModeRandom)\n\t\t{\n\t\t\treturn this.generateRandom();\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.generateUUIDv4();\n\t\t}\n\t}\n}\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new FableUUID(pSettings);\n}\n\n\nmodule.exports = FableUUID;\nmodule.exports.new = autoConstruct;\n","// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n","/**\n* Precedent Meta-Templating\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Process text streams, parsing out meta-template expressions.\n*/\nvar libWordTree = require(`./WordTree.js`);\nvar libStringParser = require(`./StringParser.js`);\n\nclass Precedent\n{\n\t/**\n\t * Precedent Constructor\n\t */\n\tconstructor()\n\t{\n\t\tthis.WordTree = new libWordTree();\n\n\t\tthis.StringParser = new libStringParser();\n\n\t\tthis.ParseTree = this.WordTree.ParseTree;\n\t}\n\n\t/**\n\t * Add a Pattern to the Parse Tree\n\t * @method addPattern\n\t * @param {Object} pTree - A node on the parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @param {number} pIndex - callback function\n\t * @return {bool} True if adding the pattern was successful\n\t */\n\taddPattern(pPatternStart, pPatternEnd, pParser)\n\t{\n\t\treturn this.WordTree.addPattern(pPatternStart, pPatternEnd, pParser);\n\t}\n\n\t/**\n\t * Parse a string with the existing parse tree\n\t * @method parseString\n\t * @param {string} pString - The string to parse\n\t * @param {object} pData - Data to pass in as the second argument\n\t * @return {string} The result from the parser\n\t */\n\tparseString(pString, pData)\n\t{\n\t\treturn this.StringParser.parseString(pString, this.ParseTree, pData);\n\t}\n}\n\nmodule.exports = Precedent;\n","/**\n* String Parser\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Parse a string, properly processing each matched token in the word tree.\n*/\n\nclass StringParser\n{\n\t/**\n\t * StringParser Constructor\n\t */\n\tconstructor()\n\t{\n\t}\n\n\t/**\n\t * Create a fresh parsing state object to work with.\n\t * @method newParserState\n\t * @param {Object} pParseTree - A node on the parse tree to begin parsing from (usually root)\n\t * @return {Object} A new parser state object for running a character parser on\n\t * @private\n\t */\n\tnewParserState (pParseTree)\n\t{\n\t\treturn (\n\t\t{\n\t\t\tParseTree: pParseTree,\n\n\t\t\tOutput: '',\n\t\t\tOutputBuffer: '',\n\n\t\t\tPattern: false,\n\n\t\t\tPatternMatch: false,\n\t\t\tPatternMatchOutputBuffer: ''\n\t\t});\n\t}\n\n\t/**\n\t * Assign a node of the parser tree to be the next potential match.\n\t * If the node has a PatternEnd property, it is a valid match and supercedes the last valid match (or becomes the initial match).\n\t * @method assignNode\n\t * @param {Object} pNode - A node on the parse tree to assign\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tassignNode (pNode, pParserState)\n\t{\n\t\tpParserState.PatternMatch = pNode;\n\n\t\t// If the pattern has a END we can assume it has a parse function...\n\t\tif (pParserState.PatternMatch.hasOwnProperty('PatternEnd'))\n\t\t{\n\t\t\t// ... this is the legitimate start of a pattern.\n\t\t\tpParserState.Pattern = pParserState.PatternMatch;\n\t\t}\n\t}\n\n\t/**\n\t * Append a character to the output buffer in the parser state.\n\t * This output buffer is used when a potential match is being explored, or a match is being explored.\n\t * @method appendOutputBuffer\n\t * @param {string} pCharacter - The character to append\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tappendOutputBuffer (pCharacter, pParserState)\n\t{\n\t\tpParserState.OutputBuffer += pCharacter;\n\t}\n\n\t/**\n\t * Flush the output buffer to the output and clear it.\n\t * @method flushOutputBuffer\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tflushOutputBuffer (pParserState)\n\t{\n\t\tpParserState.Output += pParserState.OutputBuffer;\n\t\tpParserState.OutputBuffer = '';\n\t}\n\n\n\t/**\n\t * Check if the pattern has ended.  If it has, properly flush the buffer and start looking for new patterns.\n\t * @method checkPatternEnd\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tcheckPatternEnd (pParserState, pData)\n\t{\n\t\tif ((pParserState.OutputBuffer.length >= pParserState.Pattern.PatternEnd.length+pParserState.Pattern.PatternStart.length) &&\n\t\t\t(pParserState.OutputBuffer.substr(-pParserState.Pattern.PatternEnd.length) === pParserState.Pattern.PatternEnd))\n\t\t{\n\t\t\t// ... this is the end of a pattern, cut off the end tag and parse it.\n\t\t\t// Trim the start and end tags off the output buffer now\n\t\t\tpParserState.OutputBuffer = pParserState.Pattern.Parse(pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStart.length, pParserState.OutputBuffer.length - (pParserState.Pattern.PatternStart.length+pParserState.Pattern.PatternEnd.length)), pData);\n\t\t\t// Flush the output buffer.\n\t\t\tthis.flushOutputBuffer(pParserState);\n\t\t\t// End pattern mode\n\t\t\tpParserState.Pattern = false;\n\t\t\tpParserState.PatternMatch = false;\n\t\t}\n\t}\n\n\t/**\n\t * Parse a character in the buffer.\n\t * @method parseCharacter\n\t * @param {string} pCharacter - The character to append\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tparseCharacter (pCharacter, pParserState, pData)\n\t{\n\t\t// (1) If we aren't in a pattern match, and we aren't potentially matching, and this may be the start of a new pattern....\n\t\tif (!pParserState.PatternMatch && pParserState.ParseTree.hasOwnProperty(pCharacter))\n\t\t{\n\t\t\t// ... assign the node as the matched node.\n\t\t\tthis.assignNode(pParserState.ParseTree[pCharacter], pParserState);\n\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t}\n\t\t// (2) If we are in a pattern match (actively seeing if this is part of a new pattern token)\n\t\telse if (pParserState.PatternMatch)\n\t\t{\n\t\t\t// If the pattern has a subpattern with this key\n\t\t\tif (pParserState.PatternMatch.hasOwnProperty(pCharacter))\n\t\t\t{\n\t\t\t\t// Continue matching patterns.\n\t\t\t\tthis.assignNode(pParserState.PatternMatch[pCharacter], pParserState);\n\t\t\t}\n\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\tif (pParserState.Pattern)\n\t\t\t{\n\t\t\t\t// ... Check if this is the end of the pattern (if we are matching a valid pattern)...\n\t\t\t\tthis.checkPatternEnd(pParserState, pData);\n\t\t\t}\n\t\t}\n\t\t// (3) If we aren't in a pattern match or pattern, and this isn't the start of a new pattern (RAW mode)....\n\t\telse\n\t\t{\n\t\t\tpParserState.Output += pCharacter;\n\t\t}\n\t}\n\n\t/**\n\t * Parse a string for matches, and process any template segments that occur.\n\t * @method parseString\n\t * @param {string} pString - The string to parse.\n\t * @param {Object} pParseTree - The parse tree to begin parsing from (usually root)\n\t * @param {Object} pData - The data to pass to the function as a second paramter\n\t */\n\tparseString (pString, pParseTree, pData)\n\t{\n\t\tlet tmpParserState = this.newParserState(pParseTree);\n\n\t\tfor (var i = 0; i < pString.length; i++)\n\t\t{\n\t\t\t// TODO: This is not fast.\n\t\t\tthis.parseCharacter(pString[i], tmpParserState, pData);\n\t\t}\n\n\t\tthis.flushOutputBuffer(tmpParserState);\n\n\t\treturn tmpParserState.Output;\n\t}\n}\n\nmodule.exports = StringParser;\n","/**\n* Word Tree\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Create a tree (directed graph) of Javascript objects, one character per object.\n*/\n\nclass WordTree\n{\n\t/**\n\t * WordTree Constructor\n\t */\n\tconstructor()\n\t{\n\t\tthis.ParseTree = {};\n\t}\n\t\n\t/** \n\t * Add a child character to a Parse Tree node\n\t * @method addChild\n\t * @param {Object} pTree - A parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @param {number} pIndex - The index of the character in the pattern\n\t * @returns {Object} The resulting leaf node that was added (or found)\n\t * @private\n\t */\n\taddChild (pTree, pPattern, pIndex)\n\t{\n\t\tif (!pTree.hasOwnProperty(pPattern[pIndex]))\n\t\t\tpTree[pPattern[pIndex]] = {};\n\t\t\n\t\treturn pTree[pPattern[pIndex]];\n\t}\n\t\n\t/** Add a Pattern to the Parse Tree\n\t * @method addPattern\n\t * @param {Object} pPatternStart - The starting string for the pattern (e.g. \"${\")\n\t * @param {string} pPatternEnd - The ending string for the pattern (e.g. \"}\")\n\t * @param {number} pParser - The function to parse if this is the matched pattern, once the Pattern End is met.  If this is a string, a simple replacement occurs.\n\t * @return {bool} True if adding the pattern was successful\n\t */\n\taddPattern (pPatternStart, pPatternEnd, pParser)\n\t{\n\t\tif (pPatternStart.length < 1)\n\t\t\treturn false;\n\n\t\tif ((typeof(pPatternEnd) === 'string') && (pPatternEnd.length < 1))\n\t\t\treturn false;\n\n\t\tlet tmpLeaf = this.ParseTree;\n\n\t\t// Add the tree of leaves iteratively\n\t\tfor (var i = 0; i < pPatternStart.length; i++)\n\t\t\ttmpLeaf = this.addChild(tmpLeaf, pPatternStart, i);\n\n\t\ttmpLeaf.PatternStart = pPatternStart;\n\t\ttmpLeaf.PatternEnd = ((typeof(pPatternEnd) === 'string') && (pPatternEnd.length > 0)) ? pPatternEnd : pPatternStart;\n\t\ttmpLeaf.Parse = (typeof(pParser) === 'function') ? pParser : \n\t\t\t\t\t\t(typeof(pParser) === 'string') ? () => { return pParser; } :\n\t\t\t\t\t\t(pData) => { return pData; };\n\n\t\treturn true;\n\t}\n}\n\nmodule.exports = WordTree;\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","var nextTick = require('process/browser.js').nextTick;\nvar apply = Function.prototype.apply;\nvar slice = Array.prototype.slice;\nvar immediateIds = {};\nvar nextImmediateId = 0;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) { timeout.close(); };\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// That's not how node.js implements it but the exposed api is the same.\nexports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n  var id = nextImmediateId++;\n  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n  immediateIds[id] = true;\n\n  nextTick(function onNextTick() {\n    if (immediateIds[id]) {\n      // fn.call() is faster so we optimize for the common use-case\n      // @see http://jsperf.com/call-apply-segu\n      if (args) {\n        fn.apply(null, args);\n      } else {\n        fn.call(null);\n      }\n      // Prevent ids from leaking\n      exports.clearImmediate(id);\n    }\n  });\n\n  return id;\n};\n\nexports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n  delete immediateIds[id];\n};","var libNPMModuleWrapper = require('./Fable.js');\n\nif ((typeof(window) === 'object') && !window.hasOwnProperty('Fable'))\n{\n\twindow.Fable = libNPMModuleWrapper;\n}\n\nmodule.exports = libNPMModuleWrapper;","const _OperationStatePrototype = JSON.stringify(\n{\n\t\"Metadata\": {\n\t\t\"GUID\": false,\n\t\t\"Hash\": false,\n\n\t\t\"Title\": \"\",\n\t\t\"Summary\": \"\",\n\n\t\t\"Version\": 0\n\t},\n\t\"Status\": {\n        \"Completed\": false,\n\n        \"CompletionProgress\": 0,\n        \"CompletionTimeElapsed\": 0,\n\n        \"Steps\": 1,\n        \"StepsCompleted\": 0,\n\n        \"StartTime\": 0,\n        \"EndTime\": 0\n\t},\n\t\"Errors\": [],\n\t\"Log\": []\n});\n\nclass FableOperation\n{\n\tconstructor(pFable, pOperationName, pOperationHash)\n\t{\n\t\tthis.fable = pFable;\n\n\t\tthis.name = pOperationName;\n\n\t\tthis.state = JSON.parse(_OperationStatePrototype);\n\n\t\tthis.state.Metadata.GUID = this.fable.getUUID();\n\t\tthis.state.Metadata.Hash = this.state.GUID;\n\n\t\tif (typeof(pOperationHash) == 'string')\n\t\t{\n\t\t\tthis.state.Metadata.Hash = pOperationHash;\n\t\t}\n\t}\n\n\tget GUID()\n\t{\n\t\treturn this.state.Metadata.GUID;\n\t}\n\n\tget Hash()\n\t{\n\t\treturn this.state.Metadata.Hash;\n\t}\n\n\tget log()\n\t{\n\t\treturn this;\n\t}\n\n\twriteOperationLog(pLogLevel, pLogText, pLogObject)\n\t{\n\t\tthis.state.Log.push(`${new Date().toUTCString()} [${pLogLevel}]: ${pLogText}`);\n\n\t\tif (typeof(pLogObject) == 'object')\n\t\t{\n\t\t\tthis.state.Log.push(JSON.stringify(pLogObject));\n\t\t}\n\t}\n\n\twriteOperationErrors(pLogText, pLogObject)\n\t{\n\t\tthis.state.Errors.push(`${pLogText}`);\n\n\t\tif (typeof(pLogObject) == 'object')\n\t\t{\n\t\t\tthis.state.Errors.push(JSON.stringify(pLogObject));\n\t\t}\n\t}\n\n\ttrace(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('TRACE', pLogText, pLogObject);\n\t\tthis.fable.log.trace(pLogText, pLogObject);\n\t}\n\n\tdebug(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('DEBUG', pLogText, pLogObject);\n\t\tthis.fable.log.debug(pLogText, pLogObject);\n\t}\n\n\tinfo(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('INFO', pLogText, pLogObject);\n\t\tthis.fable.log.info(pLogText, pLogObject);\n\t}\n\n\twarn(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('WARN', pLogText, pLogObject);\n\t\tthis.fable.log.warn(pLogText, pLogObject);\n\t}\n\n\terror(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('ERROR', pLogText, pLogObject);\n\t\tthis.writeOperationErrors(pLogText, pLogObject);\n\t\tthis.fable.log.error(pLogText, pLogObject);\n\t}\n\n\tfatal(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('FATAL', pLogText, pLogObject);\n\t\tthis.writeOperationErrors(pLogText, pLogObject);\n\t\tthis.fable.log.fatal(pLogText, pLogObject);\n\t}\n}\n\nmodule.exports = FableOperation;","const libFableServiceBase = require('./Fable-ServiceProviderBase.js');\nconst libDataArithmatic = require('data-arithmatic');\n\nclass FableServiceDataArithmatic extends libFableServiceBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n        super(pFable, pOptions, pServiceHash);\n\n        this.serviceType = 'DataArithmatic';\n\n        this._DataArithmaticLibrary = new libDataArithmatic();\n\t}\n}\n\nmodule.exports = FableServiceDataArithmatic;","const libFableServiceBase = require('./Fable-ServiceProviderBase.js');\n\nconst libPrecedent = require('precedent');\n\nclass FableServiceMetaTemplate extends libFableServiceBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n        super(pFable, pOptions, pServiceHash);\n\n        this.serviceType = 'MetaTemplate';\n\n        this._MetaTemplateLibrary = new libPrecedent(this.options);\n\t}\n\n\t/**\n\t * Add a Pattern to the Parse Tree\n\t * @method addPattern\n\t * @param {Object} pTree - A node on the parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @param {number} pIndex - callback function\n\t * @return {bool} True if adding the pattern was successful\n\t */\n\taddPattern(pPatternStart, pPatternEnd, pParser)\n\t{\n\t\treturn this._MetaTemplateLibrary.addPattern(pPatternStart, pPatternEnd, pParser);\n\t}\n\n\t/**\n\t * Parse a string with the existing parse tree\n\t * @method parseString\n\t * @param {string} pString - The string to parse\n\t * @return {string} The result from the parser\n\t */\n\tparseString(pString, pData)\n\t{\n\t\treturn this._MetaTemplateLibrary.parseString(pString, pData);\n\t}\n}\n\nmodule.exports = FableServiceMetaTemplate;","const libFableServiceBase = require('./Fable-ServiceProviderBase.js');\n\nclass FableServiceTemplate extends libFableServiceBase\n{\n\t// Underscore and lodash have a behavior, _.template, which compiles a\n\t// string-based template with code snippets into simple executable pieces,\n\t// with the added twist of returning a precompiled function ready to go.\n\t//\n\t// NOTE: This does not implement underscore escape expressions\n\t// NOTE: This does not implement underscore magic browser variable assignment\n\t//\n\t// This is an implementation of that.\n\t// TODO: Make this use precedent, add configuration, add debugging.\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n        super(pFable, pOptions, pServiceHash);\n\n        this.serviceType = 'Template';\n\n\t\t// These are the exact regex's used in lodash/underscore\n\t\t// TODO: Switch this to precedent\n\t\tthis.Matchers = (\n\t\t\t{\n\t\t\t\tEvaluate: /<%([\\s\\S]+?)%>/g,\n\t\t\t\tInterpolate: /<%=([\\s\\S]+?)%>/g,\n\t\t\t\tEscaper: /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g,\n\t\t\t\tUnescaper: /\\\\(\\\\|'|r|n|t|u2028|u2029)/g,\n\t\t\t\t// This is how underscore does it, so we are keeping it for now.\n\t\t\t\tGuaranteedNonMatch: /.^/\n\t\t\t});\n\n\t\t// This is a helper for the escaper and unescaper functions.\n\t\t// Right now we are going to keep what underscore is doing, but, not forever.\n\t\tthis.templateEscapes = {\n\t\t\t'\\\\': '\\\\',\n\t\t\t\"'\": \"'\",\n\t\t\t'r': '\\r',\n\t\t\t'\\r': 'r',\n\t\t\t'n': '\\n',\n\t\t\t'\\n': 'n',\n\t\t\t't': '\\t',\n\t\t\t'\\t': 't',\n\t\t\t'u2028': '\\u2028',\n\t\t\t'\\u2028': 'u2028',\n\t\t\t'u2029': '\\u2029',\n\t\t\t'\\u2029': 'u2029'\n\t\t};\n\n\t\t// This is defined as such to underscore that it is a dynamic programming\n\t\t// function on this class.\n\t\tthis.renderFunction = false;\n        this.templateString = false;\n\t}\n\n\trenderTemplate(pData)\n\t{\n\t\treturn this.renderFunction(pData);\n\t}\n\n\ttemplateFunction(pData)\n\t{\n\t\tlet fRenderTemplateBound = this.renderTemplate.bind(this);\n\t\treturn fRenderTemplateBound;\n\t}\n\n\tbuildTemplateFunction(pTemplateText, pData)\n\t{\n\t\t// For now this is being kept in a weird form ... this is to mimic the old\n\t\t// underscore code until this is rewritten using precedent.\n\t\tthis.TemplateSource = \"__p+='\" + pTemplateText\n\t\t\t.replace(this.Matchers.Escaper,\n\t\t\t\t(pMatch)=>\n\t\t\t\t{\n\t\t\t\t\treturn `\\\\${this.templateEscapes[pMatch]}`;\n\t\t\t\t})\n\t\t\t.replace(this.Matchers.Interpolate || this.Matchers.GuaranteedNonMatch,\n\t\t\t\t(pMatch, pCode) =>\n\t\t\t\t{\n\t\t\t\t\treturn `'+\\n(${decodeURIComponent(pCode)})+\\n'`;\n\t\t\t\t})\n\t\t\t.replace(this.Matchers.Evaluate || this.Matchers.GuaranteedNonMatch,\n\t\t\t\t(pMatch, pCode) =>\n\t\t\t\t{\n\t\t\t\t\treturn `';\\n${decodeURIComponent(pCode)}\\n;__p+='`;\n\t\t\t\t}) + `';\\n`;\n\n\n\t\tthis.TemplateSource = `with(pTemplateDataObject||{}){\\n${this.TemplateSource}}\\n`;\n\t\tthis.TemplateSource = `var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};\\n${this.TemplateSource}return __p;\\n`;\n\n\t\tthis.renderFunction = new Function('pTemplateDataObject', this.TemplateSource);\n\n\t\tif (typeof(pData) != 'undefined')\n\t\t{\n\t\t\treturn this.renderFunction(pData);\n\t\t}\n\n\t\t// Provide the compiled function source as a convenience for build time\n\t\t// precompilation.\n\t\tthis.TemplateSourceCompiled = 'function(obj){\\n' + this.TemplateSource + '}';\n\n\t\treturn this.templateFunction();\n\t}\n}\n\nmodule.exports = FableServiceTemplate;","const libFableServiceBase = require('./Fable-ServiceProviderBase.js');\n\n\n// TODO: These are still pretty big -- consider the smaller polyfills\nconst libAsyncWaterfall = require('async.waterfall');\nconst libAsyncEachLimit = require('async.eachlimit');\n\nclass FableServiceUtility extends libFableServiceBase\n{\n\t// Underscore and lodash have a behavior, _.template, which compiles a\n\t// string-based template with code snippets into simple executable pieces,\n\t// with the added twist of returning a precompiled function ready to go.\n\t//\n\t// NOTE: This does not implement underscore escape expressions\n\t// NOTE: This does not implement underscore magic browser variable assignment\n\t//\n\t// This is an implementation of that.\n\t// TODO: Make this use precedent, add configuration, add debugging.\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n        super(pFable, pOptions, pServiceHash);\n\n\t\tthis.templates = {};\n\n\t\t// These two functions are used extensively throughout\n\t\tthis.waterfall = libAsyncWaterfall;\n\t\tthis.eachLimit = libAsyncEachLimit;\n\t}\n\n\t// Underscore and lodash have a behavior, _.extend, which merges objects.\n\t// Now that es6 gives us this, use the native thingy.\n\textend(pDestinationObject, ...pSourceObjects)\n\t{\n\t\treturn Object.assign(pDestinationObject, ...pSourceObjects);\n\t}\n\n\t// Underscore and lodash have a behavior, _.template, which compiles a\n\t// string-based template with code snippets into simple executable pieces,\n\t// with the added twist of returning a precompiled function ready to go.\n\ttemplate(pTemplateText, pData)\n\t{\n\t\tlet tmpTemplate = this.fable.serviceManager.instantiateServiceProviderWithoutRegistration('Template');\n\n\t\treturn tmpTemplate.buildTemplateFunction(pTemplateText, pData);\n\t}\n\n\t// Build a template function from a template hash, and, register it with the service provider\n\tbuildHashedTemplate(pTemplateHash, pTemplateText, pData)\n\t{\n\t\tlet tmpTemplate = this.fable.serviceManager.instantiateServiceProvider('Template', {}, pTemplateHash);\n\n\t\tthis.templates[pTemplateHash] = tmpTemplate.buildTemplateFunction(pTemplateText, pData);\n\n\t\treturn this.templates[pTemplateHash];\n\t}\n\n\t// This is a safe, modern version of chunk from underscore\n\t// Algorithm pulled from a mix of these two polyfills:\n\t// https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_chunk\n\t// https://youmightnotneed.com/lodash\n\t// This implementation was most tolerant in browsers.  Uglify can fix the rest.\n\tchunk (pInput, pChunkSize, pChunkCache)\n\t{\n\t\tlet tmpInputArray = [...pInput];\n\t\t// Note lodash defaults to 1, underscore defaults to 0\n\t\tlet tmpChunkSize = (typeof(pChunkSize) == 'number') ? pChunkSize : 0;\n\t\tlet tmpChunkCache = (typeof(pChunkCache) != 'undefined') ? pChunkCache : [];\n\n\t\tif (tmpChunkSize <= 0)\n\t\t{\n\t\t\treturn tmpChunkCache;\n\t\t}\n\n\t\twhile (tmpInputArray.length)\n\t\t{\n\t\t\ttmpChunkCache.push(tmpInputArray.splice(0, tmpChunkSize));\n\t\t}\n\n\t\treturn tmpChunkCache;\n\t}\n}\n\nmodule.exports = FableServiceUtility;","/**\n* Fable Application Services Management\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\nconst libFableServiceBase = require('./Fable-ServiceProviderBase.js');\n\nclass FableService\n{\n\tconstructor(pFable)\n\t{\n\t\tthis.fable = pFable;\n\n\t\tthis.serviceTypes = [];\n\n\t\t// A map of instantiated services\n\t\tthis.services = {};\n\n\t\t// A map of the default instantiated service by type\n\t\tthis.defaultServices = {};\n\n\t\t// A map of class constructors for services\n\t\tthis.serviceClasses = {};\n\t}\n\n\taddServiceType(pServiceType, pServiceClass)\n\t{\n\t\t// Add the type to the list of types\n\t\tthis.serviceTypes.push(pServiceType);\n\n\t\t// Add the container for instantiated services to go in\n\t\tthis.services[pServiceType] = {};\n\n\t\tif ((typeof(pServiceClass) == 'function') && (pServiceClass.prototype instanceof libFableServiceBase))\n\t\t{\n\t\t\t// Add the class to the list of classes\n\t\t\tthis.serviceClasses[pServiceType] = pServiceClass;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Add the base class to the list of classes\n\t\t\tthis.serviceClasses[pServiceType] = libFableServiceBase;\n\t\t}\n\t}\n\n\tinstantiateServiceProvider(pServiceType, pOptions, pCustomServiceHash)\n\t{\n\t\t// Instantiate the service\n\t\tlet tmpService = this.instantiateServiceProviderWithoutRegistration(pServiceType, pOptions, pCustomServiceHash);\n\n\t\t// Add the service to the service map\n\t\tthis.services[pServiceType][tmpService.Hash] = tmpService;\n\n\t\t// If this is the first service of this type, make it the default\n\t\tif (!this.defaultServices.hasOwnProperty(pServiceType))\n\t\t{\n\t\t\tthis.defaultServices[pServiceType] = tmpService;\n\t\t}\n\n\t\treturn tmpService;\n\t}\n\n\t// Create a service provider but don't register it to live forever in fable.services\n\tinstantiateServiceProviderWithoutRegistration(pServiceType, pOptions, pCustomServiceHash)\n\t{\n\t\t// Instantiate the service\n\t\tlet tmpService = new this.serviceClasses[pServiceType](this.fable, pOptions, pCustomServiceHash);\n\t\treturn tmpService;\n\t}\n\n\tsetDefaultServiceInstantiation(pServiceType, pServiceHash)\n\t{\n\t\tif (this.services[pServiceType].hasOwnProperty(pServiceHash))\n\t\t{\n\t\t\tthis.defaultServices[pServiceType] = this.services[pServiceType][pServiceHash];\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n}\n\nmodule.exports = FableService;\n\nmodule.exports.ServiceProviderBase = libFableServiceBase;","/**\n* Fable Service Base\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\nclass FableServiceProviderBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tthis.fable = pFable;\n\n\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions : {};\n\n        this.serviceType = 'Unknown';\n\n        this.UUID = pFable.getUUID();\n\n        this.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash : `${this.UUID}`;\n\t}\n}\n\nmodule.exports = FableServiceProviderBase;\n","/**\n* Fable Application Services Support Library\n* @license MIT\n* @author <steven@velozo.com>\n*/\nconst libFableSettings = require('fable-settings');\nconst libFableUUID = require('fable-uuid');\nconst libFableLog = require('fable-log');\n\nconst libFableServiceManager = require('./Fable-ServiceManager.js');\n\nconst libFableServiceDataArithmatic = require('./Fable-Service-DataArithmatic.js');\nconst libFableServiceTemplate = require('./Fable-Service-Template.js');\nconst libFableServiceMetaTemplate = require('./Fable-Service-MetaTemplate.js');\nconst libFableServiceUtility = require('./Fable-Service-Utility.js');\n\nconst libFableOperation = require('./Fable-Operation.js');\n\nclass Fable\n{\n\tconstructor(pSettings)\n\t{\n\t\tlet tmpSettings = new libFableSettings(pSettings);\n\n\t\tthis.settingsManager = tmpSettings;\n\n\t\t// Instantiate the UUID generator\n\t\tthis.libUUID = new libFableUUID(this.settingsManager.settings);\n\n\t\tthis.log = new libFableLog(this.settingsManager.settings);\n\t\tthis.log.initialize();\n\n\t\t// Built-in dependencies\n\t\tthis.Dependencies = (\n\t\t\t{\n\t\t\t\tprecedent: libFableSettings.precedent\n\t\t\t});\n\n\t\t// Location for Operation state\n\t\tthis.Operations = {};\n\n\t\tthis.serviceManager = new libFableServiceManager(this);\n\n\t\t// Initialize and instantiate the default baked-in Data Arithmatic service\n\t\tthis.serviceManager.addServiceType('DataArithmatic', libFableServiceDataArithmatic);\n\t\tthis.fable.serviceManager.instantiateServiceProvider('DataArithmatic', {}, 'Default-Service-DataArithmatic');\n\t\t// This service is passing through the data arithmatic library\n\t\tthis.DataArithmatic = this.serviceManager.defaultServices.DataArithmatic._DataArithmaticLibrary;\n\n\t\t// Initialize the template service\n\t\tthis.serviceManager.addServiceType('Template', libFableServiceTemplate);\n\n\t\t// Initialize the metatemplate service\n\t\tthis.serviceManager.addServiceType('MetaTemplate', libFableServiceMetaTemplate);\n\n\t\t// Initialize and instantiate the default baked-in Utility service\n\t\tthis.serviceManager.addServiceType('Utility', libFableServiceUtility)\n\t\tthis.fable.serviceManager.instantiateServiceProvider('Utility', {}, 'Default-Service-Utility');\n\t\tthis.Utility = this.serviceManager.defaultServices.Utility;\n\n\t\tthis.services = this.serviceManager.services;\n\t\tthis.defaultServices = this.serviceManager.defaultServices;\n\t}\n\n\tget settings()\n\t{\n\t\treturn this.settingsManager.settings;\n\t}\n\n\tget fable()\n\t{\n\t\treturn this;\n\t}\n\n\tgetUUID()\n\t{\n\t\treturn this.libUUID.getUUID();\n\t}\n\n\tcreateOperation(pOperationName, pOperationHash)\n\t{\n\t\tlet tmpOperation = new libFableOperation(this, pOperationName, pOperationHash);\n\n\t\tif (this.Operations.hasOwnProperty(tmpOperation.Hash))\n\t\t{\n\t\t\t// Uh Oh ...... Operation Hash Collision!\n\t\t\t// TODO: What to do?!\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.Operations[tmpOperation.Hash] = tmpOperation;\n\t\t}\n\n\t\treturn tmpOperation;\n\t}\n\n\tgetOperation(pOperationHash)\n\t{\n\t\tif (!this.Operations.hasOwnProperty(pOperationHash))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.Operations[pOperationHash];\n\t\t}\n\t}\n}\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new Fable(pSettings);\n}\n\nmodule.exports = Fable;\nmodule.exports.new = autoConstruct;\n\nmodule.exports.LogProviderBase = libFableLog.LogProviderBase;\nmodule.exports.ServiceProviderBase = libFableServiceManager.ServiceProviderBase;\n\nmodule.exports.precedent = libFableSettings.precedent;"]}