{"version":3,"sources":["fable.compatible.min.js","node_modules/browser-pack/_prelude.js","node_modules/async.eachlimit/index.js","node_modules/async.iterator/index.js","node_modules/async.util.eachoflimit/index.js","node_modules/async.util.ensureasync/index.js","node_modules/async.util.isarray/index.js","node_modules/async.util.isarraylike/index.js","node_modules/async.util.keyiterator/index.js","node_modules/async.util.keys/index.js","node_modules/async.util.noop/index.js","node_modules/async.util.once/index.js","node_modules/async.util.onlyonce/index.js","node_modules/async.util.restparam/index.js","node_modules/async.util.setimmediate/index.js","node_modules/async.util.withoutindex/index.js","node_modules/async.waterfall/index.js","node_modules/data-arithmatic/source/DataArithmatic.js","node_modules/fable-log/source/Fable-Log-BaseLogger.js","node_modules/fable-log/source/Fable-Log-DefaultProviders-Web.js","node_modules/fable-log/source/Fable-Log-DefaultStreams.json","node_modules/fable-log/source/Fable-Log-Logger-Console.js","node_modules/fable-log/source/Fable-Log-Logger-SimpleFlatFile.js","node_modules/fable-log/source/Fable-Log.js","node_modules/fable-settings/source/Fable-Settings-Default.json","node_modules/fable-settings/source/Fable-Settings-TemplateProcessor.js","node_modules/fable-settings/source/Fable-Settings.js","node_modules/fable-uuid/source/Fable-UUID-Random-Browser.js","node_modules/fable-uuid/source/Fable-UUID.js","node_modules/path-browserify/index.js","node_modules/precedent/source/Precedent.js","node_modules/precedent/source/StringParser.js","node_modules/precedent/source/WordTree.js","node_modules/process/browser.js","node_modules/timers-browserify/main.js","source/Fable-Browser-Shim.js","source/Fable-Operation.js","source/Fable-Service-DataArithmatic.js","source/Fable-Service-Template.js","source/Fable-Service-Utility.js","source/Fable-ServiceManager.js","source/Fable-ServiceProviderBase.js","source/Fable.js"],"names":["_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","TypeError","o","minLen","_arrayLikeToArray","n","Object","prototype","toString","call","slice","constructor","name","Array","from","test","iter","Symbol","iterator","isArray","len","length","i","arr2","_get","Reflect","get","bind","target","property","receiver","base","_superPropBase","desc","getOwnPropertyDescriptor","arguments","value","apply","this","object","hasOwnProperty","_getPrototypeOf","_inherits","subClass","superClass","create","writable","configurable","defineProperty","_setPrototypeOf","p","setPrototypeOf","__proto__","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","result","Super","NewTarget","construct","_possibleConstructorReturn","self","_typeof","_assertThisInitialized","ReferenceError","sham","Proxy","Boolean","valueOf","e","getPrototypeOf","_classCallCheck","instance","Constructor","_defineProperties","props","descriptor","enumerable","_toPropertyKey","key","_createClass","protoProps","staticProps","arg","_toPrimitive","String","input","hint","prim","toPrimitive","undefined","res","Number","obj","f","exports","module","define","amd","window","global","Fable","r","t","c","require","u","a","Error","code","eachOfLimit","withoutIndex","limit","cb","tasks","makeCallback","index","fn","next","once","noop","onlyOnce","keyIterator","nextKey","done","running","errored","replenish","err","setImmediate","restParam","args","callback","pop","push","innerArgs","sync","_keys","isArrayLike","coll","keys","k","func","startIndex","Math","max","rest","_setImmediate","fallback","setTimeout","timers","ensureAsync","wrapIterator","concat","DataArithmatic","_Regex_formatterInsertCommas","_Regex_formatterAddCommasToNumber","_Regex_formatterDollarsRemoveCommas","_Regex_formatterCleanNonAlpha","_Value_MoneySign_Currency","_Value_NaN_Currency","_Value_GroupSeparator_Number","_Value_Prefix_StringHash","_Value_Clean_formatterCleanNonAlpha","_UseEngineStringStartsWith","startsWith","_UseEngineStringEndsWith","endsWith","pString","split","reverse","join","pSearchString","pStartIndex","stringStartsWith_Polyfill","pEndIndex","stringEndsWith_Polyfill","substr","tmpHash","tmpStringLength","tmpCharacterIndex","charCodeAt","pWrapCharacter","substring","replace","tmpReversedWithCommas","stringReverse","match","pMatch","pSign","pZeros","pBefore","pDecimal","pAfter","formatterInsertCommas","pNumber","processAddCommasToNumberRegex","pValue","tmpDollarAmount","parseFloat","toFixed","isNaN","formatterAddCommasToNumber","pDigits","tmpDigits","tmpValue","tmpStringSplitLocation","indexOf","pEnclosureStart","pEnclosureEnd","tmpString","tmpEnclosureStart","tmpEnclosureEnd","tmpEnclosureCount","tmpEnclosureDepth","pEnclosureIndexToGet","tmpEnclosureIndexToGet","tmpMatchedEnclosureIndex","tmpEnclosedValueStartIndex","tmpEnclosedValueEndIndex","pEnclosureIndexToRemove","tmpEnclosureIndexToRemove","tmpEnclosureStartIndex","tmpEnclosureEndIndex","tmpReturnString","BaseLogger","pLogStreamSettings","pFableLog","_Settings","loggerUUID","generateInsecureUUID","levels","tmpDate","Date","getTime","pCharacter","tmpRandomData","random","floor","pLogText","pLogObject","write","pLogLevel","getDefaultProviders","tmpDefaultProviders","console","loggertype","streamtype","level","ConsoleLogger","_libBaseLogger","_super","_this","_ShowTimeStamps","showtimestamps","_FormattedTimeStamps","formattedtimestamps","_ContextMessage","Context","Product","_OutputLogLinesToConsole","outputloglinestoconsole","_OutputObjectsToConsole","outputobjectstoconsole","prefixCache","pLevel","pObject","tmpTimeStamp","toISOString","tmpLogLine","log","JSON","stringify","libConsoleLog","libFS","libPath","SimpleFlatFileLogger","_libConsoleLog","_super2","_this2","logFileRawPath","path","logFilePath","normalize","logFileStreamOptions","fileStreamOptions","flags","encoding","fileWriter","createWriteStream","activelyWriting","logLineStrings","logObjectStrings","defaultWriteCompleteCallback","defaultBufferFlushCallback","fCloseComplete","tmpCloseComplete","end","fFlushComplete","tmpFlushComplete","flushBufferToLogFile","tmpLineStrings","tmpObjectStrings","tmpConstructedBufferOutputString","completeBufferFlushToLogFile","fs","FableLog","pFableSettings","pFable","tmpSettings","_Providers","_StreamDefinitions","LogStreams","logStreams","logProviders","activeLogStreams","logStreamsTrace","logStreamsDebug","logStreamsInfo","logStreamsWarn","logStreamsError","logStreamsFatal","datumDecorator","pDatum","uuid","pLogger","fDatumDecorator","pMessage","tmpDecoratedDatum","trace","debug","info","warn","error","fatal","tmpStreamDefinition","assign","addLogger","initialize","tmpMessage","tmpTime","pTimeStamp","pTimeDelta","tmpEndTime","tmpMs","parseInt","tmpSeconds","tmpMinutes","tmpHours","pStartTime","logTimeDelta","getTimeDelta","logTimeDeltaHuman","pSettings","LogProviderBase","LogProviderConsole","ProductVersion","ConfigFile","process","FableSettingsTemplateProcessor","pDependencies","templateProcessor","precedent","addPattern","pTemplateValue","tmpTemplateValue","trim","tmpSeparatorIndex","tmpDefaultValue","tmpEnvironmentVariableName","env","parseString","_process","libPrecedent","libFableSettingsTemplateProcessor","FableSettings","dependencies","settingsTemplateProcessor","_configureEnvTemplating","buildDefaultSettings","merge","parse","DefaultConfigFile","pException","settings","_PerformEnvTemplating","NoEnvReplacement","tmpKey","_resolveEnv","parseSetting","toObject","fromObject","_this3","_isObject","forEach","fromValue","toValue","_deepMergeObjects","pSettingsFrom","pSettingsTo","tmpSettingsFrom","tmpSettingsTo","tmpSettingsFromCopy","RandomBytes","getRandomValues","crypto","msCrypto","tmpBuffer","Uint8Array","generateWhatWGBytes","generateRandomBytes","libRandomByteGenerator","FableUUID","_UUIDModeRandom","UUIDModeRandom","_UUIDLength","UUIDLength","_UUIDRandomDictionary","UUIDDictionary","randomByteGenerator","_HexLookup","pBuffer","tmpRandomBytes","generate","bytesToUUID","tmpUUID","charAt","generateRandom","generateUUIDv4","assertPath","normalizeStringPosix","allowAboveRoot","lastSegmentLength","lastSlash","dots","lastSlashIndex","lastIndexOf","posix","resolve","cwd","resolvedPath","resolvedAbsolute","isAbsolute","trailingSeparator","joined","relative","to","fromStart","fromEnd","fromLen","toStart","toLen","lastCommonSep","fromCode","out","_makeLong","dirname","hasRoot","matchedSlash","basename","ext","start","extIdx","firstNonSlashEnd","extname","startDot","startPart","preDotState","format","pathObject","sep","dir","root","_format","ret","delimiter","win32","libWordTree","libStringParser","Precedent","WordTree","StringParser","ParseTree","pPatternStart","pPatternEnd","pParser","pParseTree","Output","OutputBuffer","Pattern","PatternMatch","PatternMatchOutputBuffer","pNode","pParserState","PatternEnd","PatternStart","Parse","flushOutputBuffer","assignNode","appendOutputBuffer","checkPatternEnd","tmpParserState","newParserState","parseCharacter","pTree","pPattern","pIndex","tmpLeaf","addChild","pData","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","fun","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","drainQueue","timeout","run","marker","runClearTimeout","Item","array","nextTick","title","browser","argv","version","versions","on","addListener","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","chdir","umask","clearImmediate","Function","immediateIds","nextImmediateId","Timeout","id","clearFn","_id","_clearFn","setInterval","clearInterval","close","unref","ref","enroll","item","msecs","_idleTimeoutId","_idleTimeout","unenroll","_unrefActive","active","_onTimeout","libNPMModuleWrapper","_OperationStatePrototype","Metadata","GUID","Hash","Title","Summary","Version","Status","Completed","CompletionProgress","CompletionTimeElapsed","Steps","StepsCompleted","StartTime","EndTime","Errors","Log","FableOperation","pOperationName","pOperationHash","fable","state","getUUID","toUTCString","writeOperationLog","writeOperationErrors","libFableServiceBase","libDataArithmatic","FableServiceDataArithmatic","_libFableServiceBase","_super3","pOptions","pServiceHash","_this4","serviceType","_DataArithmaticLibrary","FableServiceTemplate","_libFableServiceBase2","_super4","_this5","Matchers","Evaluate","Interpolate","Escaper","Unescaper","GuaranteedNonMatch","templateEscapes","u2028","u2029","renderFunction","templateString","renderTemplate","pTemplateText","_this6","TemplateSource","pCode","decodeURIComponent","TemplateSourceCompiled","templateFunction","libAsyncWaterfall","libAsyncEachLimit","FableServiceUtility","_libFableServiceBase3","_super5","_this7","templates","waterfall","eachLimit","pDestinationObject","_len","pSourceObjects","_key","serviceManager","instantiateServiceProviderWithoutRegistration","buildTemplateFunction","pTemplateHash","tmpTemplate","instantiateServiceProvider","pInput","pChunkSize","pChunkCache","tmpInputArray","tmpChunkSize","tmpChunkCache","splice","FableService","serviceTypes","services","defaultServices","serviceClasses","pServiceType","pServiceClass","pCustomServiceHash","tmpService","ServiceProviderBase","FableServiceProviderBase","options","UUID","libFableSettings","libFableUUID","libFableLog","libFableServiceManager","libFableServiceDataArithmatic","libFableServiceTemplate","libFableServiceUtility","libFableOperation","settingsManager","libUUID","Dependencies","Operations","addServiceType","Utility","tmpOperation"],"mappings":"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","file":"fable.compatible.min.js","sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.Fable = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n'use strict';\n\nvar eachOfLimit = require('async.util.eachoflimit');\nvar withoutIndex = require('async.util.withoutindex');\n\nmodule.exports = function eachLimit(arr, limit, iterator, cb) {\n    return eachOfLimit(limit)(arr, withoutIndex(iterator), cb);\n};\n\n},{\"async.util.eachoflimit\":3,\"async.util.withoutindex\":14}],2:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function(tasks) {\n    function makeCallback(index) {\n        function fn() {\n            if (tasks.length) {\n                tasks[index].apply(null, arguments);\n            }\n            return fn.next();\n        }\n        fn.next = function() {\n            return (index < tasks.length - 1) ? makeCallback(index + 1) : null;\n        };\n        return fn;\n    }\n    return makeCallback(0);\n};\n\n},{}],3:[function(require,module,exports){\nvar once = require('async.util.once');\nvar noop = require('async.util.noop');\nvar onlyOnce = require('async.util.onlyonce');\nvar keyIterator = require('async.util.keyiterator');\n\nmodule.exports = function eachOfLimit(limit) {\n    return function(obj, iterator, cb) {\n        cb = once(cb || noop);\n        obj = obj || [];\n        var nextKey = keyIterator(obj);\n        if (limit <= 0) {\n            return cb(null);\n        }\n        var done = false;\n        var running = 0;\n        var errored = false;\n\n        (function replenish() {\n            if (done && running <= 0) {\n                return cb(null);\n            }\n\n            while (running < limit && !errored) {\n                var key = nextKey();\n                if (key === null) {\n                    done = true;\n                    if (running <= 0) {\n                        cb(null);\n                    }\n                    return;\n                }\n                running += 1;\n                iterator(obj[key], key, onlyOnce(function(err) {\n                    running -= 1;\n                    if (err) {\n                        cb(err);\n                        errored = true;\n                    } else {\n                        replenish();\n                    }\n                }));\n            }\n        })();\n    };\n};\n\n},{\"async.util.keyiterator\":7,\"async.util.noop\":9,\"async.util.once\":10,\"async.util.onlyonce\":11}],4:[function(require,module,exports){\n'use strict';\nvar setImmediate = require('async.util.setimmediate');\nvar restParam = require('async.util.restparam');\n\nmodule.exports = function(fn) {\n    return restParam(function(args) {\n        var callback = args.pop();\n        args.push(function() {\n            var innerArgs = arguments;\n            if (sync) {\n                setImmediate(function() {\n                    callback.apply(null, innerArgs);\n                });\n            } else {\n                callback.apply(null, innerArgs);\n            }\n        });\n        var sync = true;\n        fn.apply(this, args);\n        sync = false;\n    });\n};\n\n},{\"async.util.restparam\":12,\"async.util.setimmediate\":13}],5:[function(require,module,exports){\n'use strict';\n\nmodule.exports = Array.isArray || function isArray(obj) {\n    return Object.prototype.toString.call(obj) === '[object Array]';\n};\n\n},{}],6:[function(require,module,exports){\n'use strict';\n\nvar isArray = require('async.util.isarray');\n\nmodule.exports = function isArrayLike(arr) {\n    return isArray(arr) || (\n        // has a positive integer length property\n        typeof arr.length === 'number' &&\n        arr.length >= 0 &&\n        arr.length % 1 === 0\n    );\n};\n\n},{\"async.util.isarray\":5}],7:[function(require,module,exports){\n'use strict';\n\nvar _keys = require('async.util.keys');\nvar isArrayLike = require('async.util.isarraylike');\n\nmodule.exports = function keyIterator(coll) {\n    var i = -1;\n    var len;\n    var keys;\n    if (isArrayLike(coll)) {\n        len = coll.length;\n        return function next() {\n            i++;\n            return i < len ? i : null;\n        };\n    } else {\n        keys = _keys(coll);\n        len = keys.length;\n        return function next() {\n            i++;\n            return i < len ? keys[i] : null;\n        };\n    }\n};\n\n},{\"async.util.isarraylike\":6,\"async.util.keys\":8}],8:[function(require,module,exports){\n'use strict';\n\nmodule.exports = Object.keys || function keys(obj) {\n    var _keys = [];\n    for (var k in obj) {\n        if (obj.hasOwnProperty(k)) {\n            _keys.push(k);\n        }\n    }\n    return _keys;\n};\n\n},{}],9:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function noop () {};\n\n},{}],10:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function once(fn) {\n    return function() {\n        if (fn === null) return;\n        fn.apply(this, arguments);\n        fn = null;\n    };\n};\n\n},{}],11:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function only_once(fn) {\n    return function() {\n        if (fn === null) throw new Error('Callback was already called.');\n        fn.apply(this, arguments);\n        fn = null;\n    };\n};\n\n},{}],12:[function(require,module,exports){\n'use strict';\nmodule.exports = function restParam(func, startIndex) {\n    startIndex = startIndex == null ? func.length - 1 : +startIndex;\n    return function() {\n        var length = Math.max(arguments.length - startIndex, 0);\n        var rest = new Array(length);\n        for (var index = 0; index < length; index++) {\n            rest[index] = arguments[index + startIndex];\n        }\n        switch (startIndex) {\n            case 0:\n                return func.call(this, rest);\n            case 1:\n                return func.call(this, arguments[0], rest);\n        }\n    };\n};\n\n},{}],13:[function(require,module,exports){\n(function (setImmediate){(function (){\n'use strict';\n\nvar _setImmediate = typeof setImmediate === 'function' && setImmediate;\nvar fallback = function(fn) {\n    setTimeout(fn, 0);\n};\n\nmodule.exports = function setImmediate(fn) {\n    // not a direct alias for IE10 compatibility\n    return (_setImmediate || fallback)(fn);\n};\n\n}).call(this)}).call(this,require(\"timers\").setImmediate)\n\n},{\"timers\":34}],14:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function withoutIndex(iterator) {\n    return function(value, index, callback) {\n        return iterator(value, callback);\n    };\n};\n\n},{}],15:[function(require,module,exports){\n'use strict';\n\nvar once = require('async.util.once');\nvar noop = require('async.util.noop');\nvar isArray = require('async.util.isarray');\nvar restParam = require('async.util.restparam');\nvar ensureAsync = require('async.util.ensureasync');\nvar iterator = require('async.iterator');\n\nmodule.exports = function(tasks, cb) {\n    cb = once(cb || noop);\n    if (!isArray(tasks)) return cb(new Error('First argument to waterfall must be an array of functions'));\n    if (!tasks.length) return cb();\n\n    function wrapIterator(iterator) {\n        return restParam(function(err, args) {\n            if (err) {\n                cb.apply(null, [err].concat(args));\n            } else {\n                var next = iterator.next();\n                if (next) {\n                    args.push(wrapIterator(next));\n                } else {\n                    args.push(cb);\n                }\n                ensureAsync(iterator).apply(null, args);\n            }\n        });\n    }\n    wrapIterator(iterator(tasks))();\n};\n\n},{\"async.iterator\":2,\"async.util.ensureasync\":4,\"async.util.isarray\":5,\"async.util.noop\":9,\"async.util.once\":10,\"async.util.restparam\":12}],16:[function(require,module,exports){\n\n},{}],17:[function(require,module,exports){\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\n/**\n* Data Arithmatic\n*\n* @class DataArithmatic\n*/\nclass DataArithmatic\n{\n\tconstructor()\n\t{\n\t\t// Regular Expressions (so they don't have to be recompiled every time)\n\t\t// These could be defined as static, but I'm not sure if that will work with browserify ... and specifically the QT browser.\n\t\tthis._Regex_formatterInsertCommas = /.{1,3}/g;\n\t\t// Match Function:\n\t\t// function(pMatch, pSign, pZeros, pBefore, pDecimal, pAfter)\n\t\t// Thoughts about below:   /^([+-]?)(0*)(\\d+)(\\.(\\d+))?$/;\n\t\tthis._Regex_formatterAddCommasToNumber = /^([-+]?)(0?)(\\d+)(.?)(\\d+)$/g;\n\t\tthis._Regex_formatterDollarsRemoveCommas = /,/gi;\n\t\tthis._Regex_formatterCleanNonAlpha = /[^a-z0-9]/gi;\n\n\t\t// TODO: Potentially pull these in from a configuration.\n\t\t// TODO: Use locale data for this if it's defaults all the way down.\n\t\tthis._Value_MoneySign_Currency = '$';\n\t\tthis._Value_NaN_Currency = '--';\n\t\tthis._Value_GroupSeparator_Number = ',';\n\n\t\tthis._Value_Prefix_StringHash = 'HSH';\n\t\tthis._Value_Clean_formatterCleanNonAlpha = '_';\n\n\t\tthis._UseEngineStringStartsWith = (typeof(String.prototype.startsWith) === 'function');\n\t\tthis._UseEngineStringEndsWith = (typeof(String.prototype.endsWith) === 'function');\n\t}\n\n\n\t/*************************************************************************\n\t * String Manipulation and Comparison Functions\n\t *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/\n\n\t/**\n\t * Reverse a string\n\t *\n\t * @param {string} pString - The string to reverse\n\t * @returns {string}\n\t */\n\tstringReverse (pString)\n\t{\n\t\t// TODO: Benchmark if there are faster ways we want to do this with all the newer JS stuff\n\t\t//       ... and if it will work with browserify in a clean way.\n\t    return pString.split('').reverse().join('');\n\t}\n\n\t/**\n\t * Test if a string starts with a given substring.\n\t *\n\t * @param {*} pString\n\t * @param {*} pSearchString\n\t * @param {*} pStartIndex\n\t * @returns {*}\n\t */\n\tstringStartsWith (pString, pSearchString, pStartIndex)\n\t{\n\t\tif (this._UseEngineStringStartsWith)\n\t\t{\n\t\t\treturn pString.startsWith(pSearchString, pStartIndex);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.stringStartsWith_Polyfill.call(pString, pSearchString, pStartIndex);\n\t\t}\n\t}\n\n\t/**\n\t * Check if a string starts with a given substring.  This is a safe polyfill for the ES6 string.startsWith() function.\n\t *\n\t * @param {*} pSearchString - The string to search for\n\t * @param {*} pStartIndex - The index to start the search at\n\t * @returns {boolean}\n\t */\n\tstringStartsWith_Polyfill (pSearchString, pStartIndex)\n\t{\n\t\treturn this.slice(pStartIndex || 0, pSearchString.length) === pSearchString;\n\t}\n\n\t/**\n\t * Test if a string starts with a given substring.\n\t *\n\t * @param {*} pString\n\t * @param {*} pSearchString\n\t * @param {*} pEndIndex\n\t * @returns {*}\n\t */\n\tstringEndsWith (pString, pSearchString, pEndIndex)\n\t{\n\t\tif (this._UseEngineStringEndsWith)\n\t\t{\n\t\t\treturn pString.endsWith(pSearchString, pEndIndex);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.stringEndsWith_Polyfill.call(pString, pSearchString, pEndIndex);\n\t\t}\n\t}\n\n\t/**\n\t * Check if a string starts with a given substring.  This is a safe polyfill for the ES6 string.startsWith() function.\n\t *\n\t * @param {*} pSearchString - The string to search for\n\t * @param {*} pEndIndex - The index to end the search at\n\t * @returns {boolean}\n\t */\n\tstringEndsWith_Polyfill (pSearchString, pEndIndex)\n\t{\n\t\t// This works much better than >= because\n\t\t// it compensates for NaN:\n\t\tif (!(pEndIndex < this.length))\n\t\t{\n\t\t\tpEndIndex = this.length;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpEndIndex |= 0; // round position\n\t\t}\n\t\treturn this.substr(pEndIndex - pSearchString.length, pSearchString.length) === pSearchString;\n\t}\n\n\t/**\n\t * Generate an insecure string hash.  Not meant to be secure, just a quick way to generate a hash for a string.  This is not a cryptographic hash.  Additional warranty and disclaimer ... this is not for passwords!\n\t *\n\t * @param {string} pString\n\t * @returns {string}\n\t */\n\tinsecureStringHash (pString)\n\t{\n\t    let tmpHash = 0;\n\t    let tmpStringLength = pString.length;\n\t    let tmpCharacterIndex = 0;\n\n\t    while (tmpCharacterIndex < tmpStringLength)\n\t    {\n\t        tmpHash = (tmpHash << 5) - tmpHash + pString.charCodeAt(tmpCharacterIndex++) | 0;\n\t    }\n\n\t    return `${this._Value_Prefix_StringHash}${tmpHash}`;\n\t}\n\n\t/**\n\t * Clean wrapping characters if they exist consistently around the string.  If they do not, the string is returned unchanged.\n\t *\n\t * @param {string} pWrapCharacter - The character expected as the wrapping character\n\t * @param {string} pString - the string to clean\n\t * @returns {string}\n\t */\n\tcleanEnclosureWrapCharacters (pWrapCharacter, pString)\n\t{\n\t\t// # Use case from ManyFest DSL:\n\t\t//\n\t\t// When a boxed property is passed in, it should have quotes of some\n\t\t// kind around it.\n\t\t//\n\t\t// For instance:\n\t\t// \t\tMyValues['Name']\n\t\t// \t\tMyValues[\"Age\"]\n\t\t// \t\tMyValues[`Cost`]\n\t\t//\n\t\t// This function is necessary to remove the wrapping quotes before object\n\t\t// resolution can occur.\n\t\tif (pString.startsWith(pWrapCharacter) && pString.endsWith(pWrapCharacter))\n\t\t{\n\t\t\treturn pString.substring(1, pString.length - 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn pString;\n\t\t}\n\t}\n\n\t/**\n\t *\n\t * @param {*} pString\n\t * @returns\n\t */\n\tcleanNonAlphaCharacters (pString)\n\t{\n\t    if ((typeof(pString) == 'string') && (pString != ''))\n\t    {\n\t        return pString.replace(this._Regex_formatterCleanNonAlpha, this._Value_Clean_formatterCleanNonAlpha);\n\t    }\n\t}\n\n\n\t/*************************************************************************\n\t * Number Formatting Functions\n\t *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/\n\n\t/**\n\t * Insert commas every 3 characters from the right.  Used by formatterAddCommasToNumber().\n\t *\n\t * @param {*} pString\n\t * @returns {*}\n\t */\n\tformatterInsertCommas (pString)\n\t{\n\t    // Reverse, because it's easier to do things from the left, given arbitrary digit counts\n\t    let tmpReversed = this.stringReverse(pString);\n\t    // Add commas every three characters\n\t    let tmpReversedWithCommas = tmpReversed.match(this._Regex_formatterInsertCommas).join(',');\n\t    // Reverse again (back to normal direction)\n\t    return this.stringReverse(tmpReversedWithCommas);\n\t}\n\n\tprocessAddCommasToNumberRegex(pMatch, pSign, pZeros, pBefore, pDecimal, pAfter)\n\t{\n\t\t// If there was no decimal, the last capture grabs the final digit, so\n\t\t// we have to put it back together with the 'before' substring\n\t\treturn pSign + (pDecimal ? this.formatterInsertCommas(pBefore) + pDecimal + pAfter : this.formatterInsertCommas(pBefore + pAfter));\n\t}\n\n\t/**\n\t * Add Commas to a Number for readability.\n\t *\n\t * @param {*} pNumber\n\t * @returns {string}\n\t */\n\tformatterAddCommasToNumber (pNumber)\n\t{\n\t    // If the regex doesn't match, `replace` returns the string unmodified\n\t    return (pNumber.toString()).replace\n\t    (\n\t\t\tthis._Regex_formatterAddCommasToNumber,\n\t        this.processAddCommasToNumberRegex.bind(this)\n\t    );\n\t}\n\n\t/**\n\t * This will take a number and format it as a dollar string.  It will also add commas to the number.  If the number is not a number, it will return '--'.\n\t *\n\t * @param {*} pValue\n\t * @returns {string}\n\t */\n\tformatterDollars (pValue)\n\t{\n\t    let tmpDollarAmount = parseFloat(pValue).toFixed(2);\n\n\t    if (isNaN(tmpDollarAmount))\n\t    {\n\t        // Try again and see if what was passed in was a dollars string.\n\t        if (typeof(pValue) == 'string')\n\t        {\n\t\t\t\t// TODO: Better rounding function?  This is a hack to get rid of the currency symbol and commas.\n\t            tmpDollarAmount = parseFloat(pValue.replace(this._Value_MoneySign_Currency,'').replace(this._Regex_formatterDollarsRemoveCommas,'')).toFixed(2);\n\t        }\n\t\t\t// If we didn't get a number, return the \"not a number\" string.\n\t        if (isNaN(tmpDollarAmount))\n\t        {\n\t            return this._Value_NaN_Currency;\n\t        }\n\t    }\n\n\t    // TODO: Get locale data and use that for this stuff.\n\t    return `$${this.formatterAddCommasToNumber(tmpDollarAmount)}`;\n\t}\n\n\t/**\n\t * Round a number to a certain number of digits.  If the number is not a number, it will return 0.  If no digits are specified, it will default to 2 significant digits.\n\t *\n\t * @param {*} pValue\n\t * @param {number} pDigits\n\t * @returns {string}\n\t */\n\tformatterRoundNumber (pValue, pDigits)\n\t{\n\t    let tmpDigits = (typeof(pDigits) == 'undefined') ? 2 : pDigits;\n\n\t    let tmpValue = Number.parseFloat(pValue).toFixed(tmpDigits);\n\t    if (isNaN(tmpValue))\n\t    {\n\t        let tmpZed = 0;\n\t        return tmpZed.toFixed(tmpDigits);\n\t    }\n\t    else\n\t    {\n\t        return tmpValue;\n\t    }\n\t}\n\n\n\t/*************************************************************************\n\t * String Tokenization Functions\n\t *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/\n\n\t/**\n\t * Return the string before the matched substring.\n\t *\n\t * If the substring is not found, the entire string is returned.  This only deals with the *first* match.\n\t *\n\t * @param {string} pString\n\t * @param {string} pMatch\n\t * @returns {string}\n\t */\n\tstringBeforeMatch (pString, pMatch)\n\t{\n\t\treturn pString.split(pMatch)[0];\n\t}\n\n\t/**\n\t * Return the string after the matched substring.\n\t *\n\t * If the substring is not found, an empty string is returned.  This only deals with the *first* match.\n\t *\n\t * @param {string} pString\n\t * @param {string} pMatch\n\t * @returns {string}\n\t */\n\tstringAfterMatch (pString, pMatch)\n\t{\n\t    let tmpStringSplitLocation = pString.indexOf(pMatch);\n\n\t\tif ((tmpStringSplitLocation < 0) || ((tmpStringSplitLocation + pMatch.length) >= pString.length))\n\t    {\n\t        return '';\n\t    }\n\n\t    return pString.substring(tmpStringSplitLocation + pMatch.length);\n\t}\n\n\t/**\n\t * Count the number of enclosures in a string based on the start and end characters.\n\t *\n\t * If no start or end characters are specified, it will default to parentheses.  If the string is not a string, it will return 0.\n\t *\n\t * @param {string} pString\n\t * @param {string} pEnclosureStart\n\t * @param {string} pEnclosureEnd\n\t * @returns the count of full in the string\n\t */\n\tstringCountEnclosures (pString, pEnclosureStart, pEnclosureEnd)\n\t{\n\t    let tmpString = (typeof(pString) == 'string') ? pString : '';\n\t    let tmpEnclosureStart = (typeof(pEnclosureStart) == 'string') ? pEnclosureStart : '(';\n\t    let tmpEnclosureEnd = (typeof(pEnclosureEnd) == 'string') ? pEnclosureEnd : ')';\n\n\t    let tmpEnclosureCount = 0;\n\t    let tmpEnclosureDepth = 0;\n\t    for (let i = 0; i < tmpString.length; i++)\n\t    {\n\t        // This is the start of an enclosure\n\t        if (tmpString[i] == tmpEnclosureStart)\n\t        {\n\t            if (tmpEnclosureDepth == 0)\n\t            {\n\t                tmpEnclosureCount++;\n\t            }\n\t            tmpEnclosureDepth++;\n\t        }\n\t        else if (tmpString[i] == tmpEnclosureEnd)\n\t        {\n\t            tmpEnclosureDepth--;\n\t        }\n\t    }\n\n\t    return tmpEnclosureCount;\n\t}\n\n\n\t/**\n\t * Get the value of the enclosure at the specified index.\n\t *\n\t * If the index is not a number, it will default to 0.  If the string is not a string, it will return an empty string.  If the enclosure is not found, it will return an empty string.  If the enclosure\n\t *\n\t * @param {string} pString\n\t * @param {number} pEnclosureIndexToGet\n\t * @param {string} pEnclosureStart\n\t * @param {string}} pEnclosureEnd\n\t * @returns {string}\n\t */\n\tstringGetEnclosureValueByIndex (pString, pEnclosureIndexToGet, pEnclosureStart, pEnclosureEnd)\n\t{\n\t    let tmpString = (typeof(pString) == 'string') ? pString : '';\n\t    let tmpEnclosureIndexToGet = (typeof(pEnclosureIndexToGet) == 'number') ? pEnclosureIndexToGet : 0;\n\t    let tmpEnclosureStart = (typeof(pEnclosureStart) == 'string') ? pEnclosureStart : '(';\n\t    let tmpEnclosureEnd = (typeof(pEnclosureEnd) == 'string') ? pEnclosureEnd : ')';\n\n\t    let tmpEnclosureCount = 0;\n\t    let tmpEnclosureDepth = 0;\n\n\t\tlet tmpMatchedEnclosureIndex = false;\n\t    let tmpEnclosedValueStartIndex = 0;\n\t    let tmpEnclosedValueEndIndex = 0;\n\n\t    for (let i = 0; i < tmpString.length; i++)\n\t    {\n\t        // This is the start of an enclosure\n\t        if (tmpString[i] == tmpEnclosureStart)\n\t        {\n\t            tmpEnclosureDepth++;\n\n\t\t\t\t// Only count enclosures at depth 1, but still this parses both pairs of all of them.\n\t\t\t\tif (tmpEnclosureDepth == 1)\n\t\t\t\t{\n\t\t\t\t\ttmpEnclosureCount++;\n\t\t\t\t\tif (tmpEnclosureIndexToGet == (tmpEnclosureCount - 1))\n\t\t\t\t\t{\n\t\t\t\t\t\t// This is the start of *the* enclosure\n\t\t\t\t\t\ttmpMatchedEnclosureIndex = true;\n\t\t\t\t\t\ttmpEnclosedValueStartIndex = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t        }\n\t\t\t// This is the end of an enclosure\n\t        else if (tmpString[i] == tmpEnclosureEnd)\n\t        {\n\t            tmpEnclosureDepth--;\n\n\t\t\t\t// Again, only count enclosures at depth 1, but still this parses both pairs of all of them.\n\t\t\t\tif ((tmpEnclosureDepth == 0) &&\n\t\t\t\t\ttmpMatchedEnclosureIndex &&\n\t\t\t\t\t(tmpEnclosedValueEndIndex <= tmpEnclosedValueStartIndex))\n\t\t\t\t{\n\t\t\t\t\ttmpEnclosedValueEndIndex = i;\n\t\t\t\t\ttmpMatchedEnclosureIndex = false;\n\t\t\t\t}\n\t        }\n\t    }\n\n\t    if (tmpEnclosureCount <= tmpEnclosureIndexToGet)\n\t    {\n\t\t\t// Return an empty string if the enclosure is not found\n\t        return '';\n\t    }\n\n\t    if ((tmpEnclosedValueEndIndex > 0) && (tmpEnclosedValueEndIndex > tmpEnclosedValueStartIndex))\n\t    {\n\t        return tmpString.substring(tmpEnclosedValueStartIndex+1, tmpEnclosedValueEndIndex);\n\t    }\n\t    else\n\t    {\n\t        return tmpString.substring(tmpEnclosedValueStartIndex+1);\n\t    }\n\t}\n\n\n\t/**\n\t * Remove an enclosure from a string based on the index of the enclosure.\n\t *\n\t * @param {string} pString\n\t * @param {number} pEnclosureIndexToRemove\n\t * @param {number} pEnclosureStart\n\t * @param {number} pEnclosureEnd\n\t * @returns {string}\n\t */\n\tstringRemoveEnclosureByIndex (pString, pEnclosureIndexToRemove, pEnclosureStart, pEnclosureEnd)\n\t{\n\t    let tmpString = (typeof(pString) == 'string') ? pString : '';\n\t    let tmpEnclosureIndexToRemove = (typeof(pEnclosureIndexToRemove) == 'number') ? pEnclosureIndexToRemove : 0;\n\t    let tmpEnclosureStart = (typeof(pEnclosureStart) == 'string') ? pEnclosureStart : '(';\n\t    let tmpEnclosureEnd = (typeof(pEnclosureEnd) == 'string') ? pEnclosureEnd : ')';\n\n\t    let tmpEnclosureCount = 0;\n\t    let tmpEnclosureDepth = 0;\n\n\t\tlet tmpMatchedEnclosureIndex = false;\n\t    let tmpEnclosureStartIndex = 0;\n\t    let tmpEnclosureEndIndex = 0;\n\n\t    for (let i = 0; i < tmpString.length; i++)\n\t    {\n\t        // This is the start of an enclosure\n\t        if (tmpString[i] == tmpEnclosureStart)\n\t        {\n\t            tmpEnclosureDepth++;\n\n\t            if (tmpEnclosureDepth == 1)\n\t            {\n\t                tmpEnclosureCount++;\n\t\t\t\t\tif (tmpEnclosureIndexToRemove == (tmpEnclosureCount - 1))\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpMatchedEnclosureIndex = true;\n\t\t\t\t\t\ttmpEnclosureStartIndex = i;\n\t\t\t\t\t}\n\t            }\n\t        }\n\t        else if (tmpString[i] == tmpEnclosureEnd)\n\t        {\n\t            tmpEnclosureDepth--;\n\n\t\t\t\tif ((tmpEnclosureDepth == 0) &&\n\t\t\t\t\ttmpMatchedEnclosureIndex &&\n\t\t\t\t\t(tmpEnclosureEndIndex <= tmpEnclosureStartIndex))\n\t\t\t\t{\n\t\t\t\t\ttmpEnclosureEndIndex = i;\n\t\t\t\t\ttmpMatchedEnclosureIndex = false;\n\t\t\t\t}\n\t        }\n\t    }\n\n\t    if (tmpEnclosureCount <= tmpEnclosureIndexToRemove)\n\t    {\n\t        return tmpString;\n\t    }\n\n\t    let tmpReturnString = '';\n\n\t    if (tmpEnclosureStartIndex > 1)\n\t    {\n\t        tmpReturnString = tmpString.substring(0, tmpEnclosureStartIndex);\n\t    }\n\n\t    if ((tmpString.length > (tmpEnclosureEndIndex + 1)) && (tmpEnclosureEndIndex > tmpEnclosureStartIndex))\n\t    {\n\t        tmpReturnString += tmpString.substring(tmpEnclosureEndIndex+1);\n\t    }\n\n\t    return tmpReturnString;\n\t}\n}\n\nmodule.exports = DataArithmatic;\n},{}],18:[function(require,module,exports){\n/**\n* Base Logger Class\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\nclass BaseLogger\n{\n\tconstructor(pLogStreamSettings, pFableLog)\n\t{\n\t\t// This should not possibly be able to be instantiated without a settings object\n\t\tthis._Settings = (typeof(pLogStreamSettings) == 'object') ? pLogStreamSettings : {};\n\n\t\t// The base logger does nothing but associate a UUID with itself\n\t\t// We added this as the mechanism for tracking loggers to allow multiple simultaneous streams\n\t\t// to the same provider.\n\t\tthis.loggerUUID = this.generateInsecureUUID();\n\n\t\t// Eventually we can use this array to ompute which levels the provider allows.\n\t\t// For now it's just used to precompute some string concatenations.\n\t\tthis.levels = (\n\t\t\t[\n\t\t\t\t\"trace\",\n\t\t\t\t\"debug\",\n\t\t\t\t\"info\",\n\t\t\t\t\"warn\",\n\t\t\t\t\"error\",\n\t\t\t\t\"fatal\"\n\t\t\t]);\n\t}\n\n\t// This is meant to generate programmatically insecure UUIDs to identify loggers\n\tgenerateInsecureUUID()\n\t{\n\t\tlet tmpDate = new Date().getTime();\n\t\tlet tmpUUID = 'LOGSTREAM-xxxxxx-yxxxxx'.replace(/[xy]/g,\n\t\t\t\t(pCharacter) =>\n\t\t\t\t{\n\t\t\t\t\t// Funny algorithm from w3resource that is twister-ish without the deep math and security\n\t\t\t\t\t// ..but good enough for unique log stream identifiers\n\t\t\t\t\tlet tmpRandomData = (tmpDate + Math.random()*16)%16 | 0;\n\t\t\t\t\ttmpDate = Math.floor(tmpDate/16);\n\n\t\t\t\t\treturn (pCharacter =='x' ? tmpRandomData : (tmpRandomData&0x3|0x8)).toString(16);\n\t\t\t\t});\n\t\treturn tmpUUID;\n\t}\n\n\tinitialize()\n\t{\n\t\t// No operation.\n\t}\n\n\ttrace(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"trace\", pLogText, pLogObject);\n\t}\n\n\tdebug(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"debug\", pLogText, pLogObject);\n\t}\n\n\tinfo(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"info\", pLogText, pLogObject);\n\t}\n\n\twarn(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"warn\", pLogText, pLogObject);\n\t}\n\n\terror(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"error\", pLogText, pLogObject);\n\t}\n\n\tfatal(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"fatal\", pLogText, pLogObject);\n\t}\n\n\twrite(pLogLevel, pLogText, pLogObject)\n\t{\n\t\t// The base logger does nothing.\n\t\treturn true;\n\t}\n}\n\nmodule.exports = BaseLogger;\n\n},{}],19:[function(require,module,exports){\n/**\n* Default Logger Provider Function\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\n// Return the providers that are available without extensions loaded\ngetDefaultProviders = () =>\n{\n\tlet tmpDefaultProviders = {};\n\n\ttmpDefaultProviders.console = require('./Fable-Log-Logger-Console.js');\n\n\ttmpDefaultProviders.default = tmpDefaultProviders.console;\n\n\treturn tmpDefaultProviders;\n}\n\nmodule.exports = getDefaultProviders();\n},{\"./Fable-Log-Logger-Console.js\":21}],20:[function(require,module,exports){\nmodule.exports=[\n    {\n        \"loggertype\": \"console\",\n        \"streamtype\": \"console\",\n        \"level\": \"trace\"\n    }\n]\n},{}],21:[function(require,module,exports){\nlet libBaseLogger = require('./Fable-Log-BaseLogger.js');\n\nclass ConsoleLogger extends libBaseLogger\n{\n\tconstructor(pLogStreamSettings, pFableLog)\n\t{\n\t\tsuper(pLogStreamSettings);\n\n\t\tthis._ShowTimeStamps = this._Settings.hasOwnProperty('showtimestamps') ? (this._Settings.showtimestamps == true) : true;\n\t\tthis._FormattedTimeStamps = this._Settings.hasOwnProperty('formattedtimestamps') ? (this._Settings.formattedtimestamps == true) : true;\n\n\t\tthis._ContextMessage = this._Settings.hasOwnProperty('Context') ? `(${this._Settings.Context})` : \n\t\t\t\t\t\t\t\tpFableLog._Settings.hasOwnProperty('Product') ? `(${pFableLog._Settings.Product})` :\n\t\t\t\t\t\t\t\t'Unnamed_Log_Context';\n\n\t\t// Allow the user to decide what gets output to the console\n\t\tthis._OutputLogLinesToConsole = this._Settings.hasOwnProperty('outputloglinestoconsole') ? this._Settings.outputloglinestoconsole : true;\n\t\tthis._OutputObjectsToConsole = this._Settings.hasOwnProperty('outputobjectstoconsole') ? this._Settings.outputobjectstoconsole : true;\n\n\t\t// Precompute the prefix for each level\n\t\tthis.prefixCache = {};\n\t\tfor (let i = 0; i <= this.levels.length; i++)\n\t\t{\n\t\t\tthis.prefixCache[this.levels[i]] = `[${this.levels[i]}] ${this._ContextMessage}: `;\n\n\t\t\tif (this._ShowTimeStamps)\n\t\t\t{\n\t\t\t\t// If there is a timestamp we need a to prepend space before the prefixcache string, since the timestamp comes first\n\t\t\t\tthis.prefixCache[this.levels[i]] = ' '+this.prefixCache[this.levels[i]];\n\t\t\t}\n\t\t}\n\t}\n\n\twrite(pLevel, pLogText, pObject)\n\t{\n\t\tlet tmpTimeStamp = '';\n\t\tif (this._ShowTimeStamps && this._FormattedTimeStamps)\n\t\t{\n\t\t\ttmpTimeStamp = (new Date()).toISOString();\n\t\t}\n\t\telse if (this._ShowTimeStamps)\n\t\t{\n\t\t\ttmpTimeStamp = +new Date();\n\t\t}\n\n\t\tlet tmpLogLine = `${tmpTimeStamp}${this.prefixCache[pLevel]}${pLogText}`;\n\n\t\tif (this._OutputLogLinesToConsole)\n\t\t{\n\t\t\tconsole.log(tmpLogLine);\n\t\t}\n\n\t\t// Write out the object on a separate line if it is passed in\n\t\tif (this._OutputObjectsToConsole && (typeof(pObject) !== 'undefined'))\n\t\t{\n\t\t\tconsole.log(JSON.stringify(pObject, null, 2));\n\t\t}\n\n\t\t// Provide an easy way to be overridden and be consistent\n\t\treturn tmpLogLine;\n\t}\n}\n\nmodule.exports = ConsoleLogger;\n},{\"./Fable-Log-BaseLogger.js\":18}],22:[function(require,module,exports){\nconst libConsoleLog = require('./Fable-Log-Logger-Console.js');\nconst libFS = require('fs');\nconst libPath = require('path');\n\nclass SimpleFlatFileLogger extends libConsoleLog\n{\n\tconstructor(pLogStreamSettings, pFableLog)\n\t{\n\t\tsuper(pLogStreamSettings, pFableLog);\n\n\t\t// If a path isn't provided for the logfile, it tries to use the ProductName or Context\n\t\tthis.logFileRawPath = (this._Settings.hasOwnProperty('path')) ? this._Settings.path : `./${this._ContextMessage}.log`;\n\t\tthis.logFilePath = libPath.normalize(this.logFileRawPath);\n\n\t\tthis.logFileStreamOptions = (this._Settings.hasOwnProperty('fileStreamoptions')) ? this._Settings.fileStreamOptions : (\n\t\t\t{\n\t\t\t\t\"flags\": \"a\",\n\t\t\t\t\"encoding\": \"utf8\"\n\t\t\t})\n\n\t\tthis.fileWriter = libFS.createWriteStream(this.logFilePath, this.logFileStreamOptions);\n\n\t\tthis.activelyWriting = false;\n\n\t\tthis.logLineStrings = [];\n\t\tthis.logObjectStrings = [];\n\n\t\tthis.defaultWriteCompleteCallback = ()=>{};\n\t\tthis.defaultBufferFlushCallback = ()=>{};\n\t}\n\n\tcloseWriter(fCloseComplete)\n\t{\n\t\tlet tmpCloseComplete = (typeof(fCloseComplete) == 'function') ? fCloseComplete : ()=>{};\n\t\tif (this.fileWriter)\n\t\t{\n\t\t\tthis.fileWriter.end('\\n');\n\t\t\treturn this.fileWriter.once('finish', tmpCloseComplete.bind(this));\n\t\t}\n\t};\n\n\tcompleteBufferFlushToLogFile(fFlushComplete)\n\t{\n\t\tthis.activelyWriting = false;\n\t\tlet tmpFlushComplete = (typeof(fFlushComplete) == 'function') ? fFlushComplete : this.defaultBufferFlushCallback;\n\n\t\tif (this.logLineStrings.length > 0)\n\t\t{\n\t\t\tthis.flushBufferToLogFile(tmpFlushComplete);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn tmpFlushComplete();\n\t\t}\n\t}\n\n\tflushBufferToLogFile(fFlushComplete)\n\t{\n\t\tif (!this.activelyWriting)\n\t\t{\n\t\t\t// Only want to be writing one thing at a time....\n\t\t\tthis.activelyWriting = true;\n\n\t\t\tlet tmpFlushComplete = (typeof(fFlushComplete) == 'function') ? fFlushComplete : this.defaultBufferFlushCallback;\n\n\t\t\t// Get the current buffer arrays.  These should always have matching number of elements.\n\t\t\tlet tmpLineStrings = this.logLineStrings;\n\t\t\tlet tmpObjectStrings = this.logObjectStrings;\n\n\t\t\t// Reset these to be filled while we process this queue...\n\t\t\tthis.logLineStrings = [];\n\t\t\tthis.logObjectStrings = [];\n\n\t\t\t// This is where we will put each line before writing it to the file...\n\t\t\tlet tmpConstructedBufferOutputString = '';\n\n\t\t\tfor (let i = 0; i < tmpLineStrings.length; i++)\n\t\t\t{\n\t\t\t\t// TODO: Windows Newline?   ....... yo no se!\n\t\t\t\ttmpConstructedBufferOutputString += `${tmpLineStrings[i]}\\n`;\n\t\t\t\tif (tmpObjectStrings[i] !== false)\n\t\t\t\t{\n\t\t\t\t\ttmpConstructedBufferOutputString += `${tmpObjectStrings[i]}\\n`;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!this.fileWriter.write(tmpConstructedBufferOutputString, 'utf8'))\n\t\t\t{\n\t\t\t\t// If the streamwriter returns false, we need to wait for it to drain.\n\t\t\t\tthis.fileWriter.once('drain', this.completeBufferFlushToLogFile.bind(this, tmpFlushComplete));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn this.completeBufferFlushToLogFile(tmpFlushComplete);\n\t\t\t}\n\t\t}\n\t}\n\n\twrite(pLevel, pLogText, pObject)\n\t{\n\t\tlet tmpLogLine = super.write(pLevel, pLogText, pObject);\n\n\t\t// Use a very simple array as the write buffer\n\t\tthis.logLineStrings.push(tmpLogLine);\n\n\t\t// Write out the object on a separate line if it is passed in\n\t\tif (typeof(pObject) !== 'undefined')\n\t\t{\n\t\t\tthis.logObjectStrings.push(JSON.stringify(pObject, null, 4));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logObjectStrings.push(false);\n\t\t}\n\n\t\tthis.flushBufferToLogFile();\n\t}\n}\n\nmodule.exports = SimpleFlatFileLogger;\n},{\"./Fable-Log-Logger-Console.js\":21,\"fs\":16,\"path\":29}],23:[function(require,module,exports){\n/**\n* Fable Logging Add-on\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable Logger\n*/\n\n/**\n* Fable Solution Log Wrapper Main Class\n*\n* @class FableLog\n* @constructor\n*/\nclass FableLog\n{\n\tconstructor(pFableSettings, pFable)\n\t{\n\t\tlet tmpSettings = (typeof(pFableSettings) === 'object') ? pFableSettings : {}\n\t\tthis._Settings = tmpSettings;\n\n\t\tthis._Providers = require('./Fable-Log-DefaultProviders-Node.js');\n\n\t\tthis._StreamDefinitions = (tmpSettings.hasOwnProperty('LogStreams')) ? tmpSettings.LogStreams : require('./Fable-Log-DefaultStreams.json');\n\n\t\tthis.logStreams = [];\n\n\t\t// This object gets decorated for one-time instantiated providers that\n\t\t//  have multiple outputs, such as bunyan.\n\t\tthis.logProviders = {};\n\n\t\t// A hash list of the GUIDs for each log stream, so they can't be added to the set more than one time\n\t\tthis.activeLogStreams = {};\n\n\t\tthis.logStreamsTrace = [];\n\t\tthis.logStreamsDebug = [];\n\t\tthis.logStreamsInfo = [];\n\t\tthis.logStreamsWarn = [];\n\t\tthis.logStreamsError = [];\n\t\tthis.logStreamsFatal = [];\n\n\t\tthis.datumDecorator = (pDatum) => pDatum;\n\n\t\tthis.uuid = (typeof(tmpSettings.Product) === 'string') ? tmpSettings.Product : 'Default';\n\t}\n\n\taddLogger(pLogger, pLevel)\n\t{\n\t\t// Bail out if we've already created one.\n\t\tif (this.activeLogStreams.hasOwnProperty(pLogger.loggerUUID))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// Add it to the streams and to the mutex\n\t\tthis.logStreams.push(pLogger);\n\t\tthis.activeLogStreams[pLogger.loggerUUID] = true;\n\n\t\t// Make sure a kosher level was passed in\n\t\tswitch (pLevel)\n\t\t{\n\t\t\tcase 'trace':\n\t\t\t\tthis.logStreamsTrace.push(pLogger);\n\t\t\tcase 'debug':\n\t\t\t\tthis.logStreamsDebug.push(pLogger);\n\t\t\tcase 'info':\n\t\t\t\tthis.logStreamsInfo.push(pLogger);\n\t\t\tcase 'warn':\n\t\t\t\tthis.logStreamsWarn.push(pLogger);\n\t\t\tcase 'error':\n\t\t\t\tthis.logStreamsError.push(pLogger);\n\t\t\tcase 'fatal':\n\t\t\t\tthis.logStreamsFatal.push(pLogger);\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tsetDatumDecorator(fDatumDecorator)\n\t{\n\t\tif (typeof(fDatumDecorator) === 'function')\n\t\t{\n\t\t\tthis.datumDecorator = fDatumDecorator;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.datumDecorator = (pDatum) => pDatum;\n\t\t}\n\t}\n\n\ttrace(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsTrace.length; i++)\n\t\t{\n\t\t\tthis.logStreamsTrace[i].trace(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tdebug(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsDebug.length; i++)\n\t\t{\n\t\t\tthis.logStreamsDebug[i].debug(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tinfo(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsInfo.length; i++)\n\t\t{\n\t\t\tthis.logStreamsInfo[i].info(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\twarn(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsWarn.length; i++)\n\t\t{\n\t\t\tthis.logStreamsWarn[i].warn(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\terror(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsError.length; i++)\n\t\t{\n\t\t\tthis.logStreamsError[i].error(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tfatal(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsFatal.length; i++)\n\t\t{\n\t\t\tthis.logStreamsFatal[i].fatal(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tinitialize()\n\t{\n\t\t// \"initialize\" each logger as defined in the logging parameters\n\t\tfor (let i = 0; i < this._StreamDefinitions.length; i++)\n\t\t{\n\t\t\tlet tmpStreamDefinition = Object.assign({loggertype:'default',streamtype:'console',level:'info'},this._StreamDefinitions[i]);\n\n\t\t\tif (!this._Providers.hasOwnProperty(tmpStreamDefinition.loggertype))\n\t\t\t{\n\t\t\t\tconsole.log(`Error initializing log stream: bad loggertype in stream definition ${JSON.stringify(tmpStreamDefinition)}`);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.addLogger(new this._Providers[tmpStreamDefinition.loggertype](tmpStreamDefinition, this), tmpStreamDefinition.level);\n\t\t\t}\n\t\t}\n\n\t\t// Now initialize each one.\n\t\tfor (let i = 0; i < this.logStreams.length; i++)\n\t\t{\n\t\t\tthis.logStreams[i].initialize();\n\t\t}\n\t}\n\n\tlogTime(pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time';\n\t\tlet tmpTime = new Date();\n\t\tthis.info(`${tmpMessage} ${tmpTime} (epoch ${+tmpTime})`, pDatum);\n\t}\n\n\t// Get a timestamp\n\tgetTimeStamp()\n\t{\n\t\treturn +new Date();\n\t}\n\n\tgetTimeDelta(pTimeStamp)\n\t{\n\t\tlet tmpEndTime = +new Date();\n\t\treturn tmpEndTime-pTimeStamp;\n\t}\n\n\t// Log the delta between a timestamp, and now with a message\n\tlogTimeDelta(pTimeDelta, pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time Measurement';\n\t\tlet tmpDatum = (typeof(pDatum) === 'object') ? pDatum : {};\n\n\t\tlet tmpEndTime = +new Date();\n\n\t\tthis.info(`${tmpMessage} logged at (epoch ${+tmpEndTime}) took (${pTimeDelta}ms)`, pDatum);\n\t}\n\n\tlogTimeDeltaHuman(pTimeDelta, pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time Measurement';\n\n\t\tlet tmpEndTime = +new Date();\n\n\t\tlet tmpMs = parseInt(pTimeDelta%1000);\n\t\tlet tmpSeconds = parseInt((pTimeDelta/1000)%60);\n\t\tlet tmpMinutes = parseInt((pTimeDelta/(1000*60))%60);\n\t\tlet tmpHours = parseInt(pTimeDelta/(1000*60*60));\n\n\t\ttmpMs = (tmpMs < 10) ? \"00\"+tmpMs : (tmpMs < 100) ? \"0\"+tmpMs : tmpMs;\n\t\ttmpSeconds = (tmpSeconds < 10) ? \"0\"+tmpSeconds : tmpSeconds;\n\t\ttmpMinutes = (tmpMinutes < 10) ? \"0\"+tmpMinutes : tmpMinutes;\n\t\ttmpHours = (tmpHours < 10) ? \"0\"+tmpHours : tmpHours;\n\n\t\tthis.info(`${tmpMessage} logged at (epoch ${+tmpEndTime}) took (${pTimeDelta}ms) or (${tmpHours}:${tmpMinutes}:${tmpSeconds}.${tmpMs})`, pDatum);\n\t}\n\n\tlogTimeDeltaRelative(pStartTime, pMessage, pDatum)\n\t{\n\t\tthis.logTimeDelta(this.getTimeDelta(pStartTime), pMessage, pDatum);\n\t}\n\n\tlogTimeDeltaRelativeHuman(pStartTime, pMessage, pDatum)\n\t{\n\t\tthis.logTimeDeltaHuman(this.getTimeDelta(pStartTime), pMessage, pDatum);\n\t}\n}\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new FableLog(pSettings);\n}\n\n\nmodule.exports = FableLog;\nmodule.exports.new = autoConstruct;\nmodule.exports.LogProviderBase = require('./Fable-Log-BaseLogger.js');\nmodule.exports.LogProviderConsole = require('./Fable-Log-Logger-Console.js');\nmodule.exports.LogProviderConsole = require('./Fable-Log-Logger-SimpleFlatFile.js');\n\n},{\"./Fable-Log-BaseLogger.js\":18,\"./Fable-Log-DefaultProviders-Node.js\":19,\"./Fable-Log-DefaultStreams.json\":20,\"./Fable-Log-Logger-Console.js\":21,\"./Fable-Log-Logger-SimpleFlatFile.js\":22}],24:[function(require,module,exports){\nmodule.exports={\n\t\"Product\": \"ApplicationNameHere\",\n\t\"ProductVersion\": \"0.0.0\",\n\n\t\"ConfigFile\": false,\n\n\t\"LogStreams\":\n\t[\n\t\t{\n\t\t\t\"level\": \"trace\"\n\t\t}\n\t]\n}\n\n},{}],25:[function(require,module,exports){\n(function (process){(function (){\n/**\n* Fable Settings Template Processor\n*\n* This class allows environment variables to come in via templated expressions, and defaults to be set.\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable Settings\n*/\n\nclass FableSettingsTemplateProcessor\n{\n\tconstructor(pDependencies)\n\t{\n        // Use a no-dependencies templating engine to parse out environment variables\n\t\tthis.templateProcessor = new pDependencies.precedent();\n\n        // TODO: Make the environment variable wrap expression demarcation characters configurable?\n\t\tthis.templateProcessor.addPattern('${', '}',\n\t\t\t(pTemplateValue)=>\n\t\t\t{\n\t\t\t\tlet tmpTemplateValue = pTemplateValue.trim();\n\n\t\t\t\tlet tmpSeparatorIndex = tmpTemplateValue.indexOf('|');\n\n\t\t\t\t// If there is no pipe, the default value will end up being whatever the variable name is.\n\t\t\t\tlet tmpDefaultValue = tmpTemplateValue.substring(tmpSeparatorIndex+1);\n\n\t\t\t\tlet tmpEnvironmentVariableName = (tmpSeparatorIndex > -1) ? tmpTemplateValue.substring(0, tmpSeparatorIndex) : tmpTemplateValue;\n\n\t\t\t\tif (process.env.hasOwnProperty(tmpEnvironmentVariableName))\n\t\t\t\t{\n\t\t\t\t\treturn process.env[tmpEnvironmentVariableName];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn tmpDefaultValue;\n\t\t\t\t}\n\t\t\t});\n    }\n\n    parseSetting(pString)\n    {\n        return this.templateProcessor.parseString(pString);\n    }\n}\n\nmodule.exports = FableSettingsTemplateProcessor;\n}).call(this)}).call(this,require('_process'))\n\n},{\"_process\":33}],26:[function(require,module,exports){\n/**\n* Fable Settings Add-on\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable Settings\n*/\n\nconst libPrecedent = require('precedent');\nconst libFableSettingsTemplateProcessor = require('./Fable-Settings-TemplateProcessor.js');\n\nclass FableSettings\n{\n\tconstructor(pFableSettings)\n\t{\n\t\t// Expose the dependencies for downstream re-use\n\t\tthis.dependencies = (\n\t\t\t{\n\t\t\t\tprecedent: libPrecedent\n\t\t\t});\n\n\t\t// Initialize the settings value template processor\n\t\tthis.settingsTemplateProcessor = new libFableSettingsTemplateProcessor(this.dependencies);\n\n\t\t// set straight away so anything that uses it respects the initial setting\n\t\tthis._configureEnvTemplating(pFableSettings);\n\n\t\tthis.default = this.buildDefaultSettings();\n\n\t\t// Construct a new settings object\n\t\tlet tmpSettings = this.merge(pFableSettings, this.buildDefaultSettings());\n\n\t\t// The base settings object (what they were on initialization, before other actors have altered them)\n\t\tthis.base = JSON.parse(JSON.stringify(tmpSettings));\n\n\t\tif (tmpSettings.DefaultConfigFile)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// If there is a DEFAULT configuration file, try to load and merge it.\n\t\t\t\ttmpSettings = this.merge(require(tmpSettings.DefaultConfigFile), tmpSettings);\n\t\t\t}\n\t\t\tcatch (pException)\n\t\t\t{\n\t\t\t\t// Why this?  Often for an app we want settings to work out of the box, but\n\t\t\t\t// would potentially want to have a config file for complex settings.\n\t\t\t\tconsole.log('Fable-Settings Warning: Default configuration file specified but there was a problem loading it.  Falling back to base.');\n\t\t\t\tconsole.log('     Loading Exception: '+pException);\n\t\t\t}\n\t\t}\n\n\t\tif (tmpSettings.ConfigFile)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// If there is a configuration file, try to load and merge it.\n\t\t\t\ttmpSettings = this.merge(require(tmpSettings.ConfigFile), tmpSettings);\n\t\t\t}\n\t\t\tcatch (pException)\n\t\t\t{\n\t\t\t\t// Why this?  Often for an app we want settings to work out of the box, but\n\t\t\t\t// would potentially want to have a config file for complex settings.\n\t\t\t\tconsole.log('Fable-Settings Warning: Configuration file specified but there was a problem loading it.  Falling back to base.');\n\t\t\t\tconsole.log('     Loading Exception: '+pException);\n\t\t\t}\n\t\t}\n\n\t\tthis.settings = tmpSettings;\n\t}\n\n\t// Build a default settings object.  Use the JSON jimmy to ensure it is always a new object.\n\tbuildDefaultSettings()\n\t{\n\t\treturn JSON.parse(JSON.stringify(require('./Fable-Settings-Default')));\n\t}\n\n\t// Update the configuration for environment variable templating based on the current settings object\n\t_configureEnvTemplating(pSettings)\n\t{\n\t\t// default environment variable templating to on\n\t\tthis._PerformEnvTemplating = !pSettings || pSettings.NoEnvReplacement !== true;\n\t}\n\n\t// Resolve (recursive) any environment variables found in settings object.\n\t_resolveEnv(pSettings)\n\t{\n\t\tfor (const tmpKey in pSettings)\n\t\t{\n\t\t\tif (typeof(pSettings[tmpKey]) === 'object')\n\t\t\t{\n\t\t\t\tthis._resolveEnv(pSettings[tmpKey]);\n\t\t\t}\n\t\t\telse if (typeof(pSettings[tmpKey]) === 'string')\n\t\t\t{\n\t\t\t\tpSettings[tmpKey] = this.settingsTemplateProcessor.parseSetting(pSettings[tmpKey]);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Check to see if a value is an object (but not an array).\n\t */\n\t_isObject(value)\n\t{\n\t\treturn typeof(value) === 'object' && !Array.isArray(value);\n\t}\n\n\t/**\n\t * Merge two plain objects. Keys that are objects in both will be merged property-wise.\n\t */\n\t_deepMergeObjects(toObject, fromObject)\n\t{\n\t\tif (!fromObject || !this._isObject(fromObject))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tObject.keys(fromObject).forEach((key) =>\n\t\t{\n\t\t\tconst fromValue = fromObject[key];\n\t\t\tif (this._isObject(fromValue))\n\t\t\t{\n\t\t\t\tconst toValue = toObject[key];\n\t\t\t\tif (toValue && this._isObject(toValue))\n\t\t\t\t{\n\t\t\t\t\t// both are objects, so do a recursive merge\n\t\t\t\t\tthis._deepMergeObjects(toValue, fromValue);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttoObject[key] = fromValue;\n\t\t});\n\t\treturn toObject;\n\t}\n\n\t// Merge some new object into the existing settings.\n\tmerge(pSettingsFrom, pSettingsTo)\n\t{\n\t\t// If an invalid settings from object is passed in (e.g. object constructor without passing in anything) this should still work\n\t\tlet tmpSettingsFrom = (typeof(pSettingsFrom) === 'object') ? pSettingsFrom : {};\n\t\t// Default to the settings object if none is passed in for the merge.\n\t\tlet tmpSettingsTo = (typeof(pSettingsTo) === 'object') ? pSettingsTo : this.settings;\n\n\t\t// do not mutate the From object property values\n\t\tlet tmpSettingsFromCopy = JSON.parse(JSON.stringify(tmpSettingsFrom));\n\t\ttmpSettingsTo = this._deepMergeObjects(tmpSettingsTo, tmpSettingsFromCopy);\n\n\t\tif (this._PerformEnvTemplating)\n\t\t{\n\t\t\tthis._resolveEnv(tmpSettingsTo);\n\t\t}\n\t\t// Update env tempating config, since we just updated the config object, and it may have changed\n\t\tthis._configureEnvTemplating(tmpSettingsTo);\n\n\t\treturn tmpSettingsTo;\n\t}\n\n\t// Fill in settings gaps without overwriting settings that are already there\n\tfill(pSettingsFrom)\n\t{\n\t\t// If an invalid settings from object is passed in (e.g. object constructor without passing in anything) this should still work\n\t\tlet tmpSettingsFrom = (typeof(pSettingsFrom) === 'object') ? pSettingsFrom : {};\n\n\t\t// do not mutate the From object property values\n\t\tlet tmpSettingsFromCopy = JSON.parse(JSON.stringify(tmpSettingsFrom));\n\n\t\tthis.settings = this._deepMergeObjects(tmpSettingsFromCopy, this.settings);\n\n\t\treturn this.settings;\n\t}\n};\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new FableSettings(pSettings);\n}\n\nmodule.exports = FableSettings;\nmodule.exports.new = autoConstruct;\nmodule.exports.precedent = libPrecedent;\n},{\"./Fable-Settings-Default\":24,\"./Fable-Settings-TemplateProcessor.js\":25,\"precedent\":30}],27:[function(require,module,exports){\n/**\n* Random Byte Generator - Browser version\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\n// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\nclass RandomBytes\n{\n\tconstructor()\n\t{\n\n\t\t// getRandomValues needs to be invoked in a context where \"this\" is a Crypto\n\t\t// implementation. Also, find the complete implementation of crypto on IE11.\n\t\tthis.getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||\n                      \t\t(typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));\n\t}\n\n\t// WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n\tgenerateWhatWGBytes()\n\t{\n\t\tlet tmpBuffer = new Uint8Array(16); // eslint-disable-line no-undef\n\n\t\tthis.getRandomValues(tmpBuffer);\n\t\treturn tmpBuffer;\n\t}\n\n\t// Math.random()-based (RNG)\n\tgenerateRandomBytes()\n\t{\n\t\t// If all else fails, use Math.random().  It's fast, but is of unspecified\n\t\t// quality.\n\t\tlet tmpBuffer = new Uint8Array(16); // eslint-disable-line no-undef\n\n\t\tfor (let i = 0, tmpValue; i < 16; i++)\n\t\t{\n\t\t\tif ((i & 0x03) === 0)\n\t\t\t{\n\t\t\t\ttmpValue = Math.random() * 0x100000000;\n\t\t\t}\n\n\t\t\ttmpBuffer[i] = tmpValue >>> ((i & 0x03) << 3) & 0xff;\n\t\t}\n\n\t\treturn tmpBuffer;\n\t}\n\n\tgenerate()\n\t{\n\t\tif (this.getRandomValues)\n\t\t{\n\t\t\treturn this.generateWhatWGBytes();\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.generateRandomBytes();\n\t\t}\n\t}\n}\n\nmodule.exports = RandomBytes;\n\n},{}],28:[function(require,module,exports){\n/**\n* Fable UUID Generator\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable UUID\n*/\n\n/**\n* Fable Solution UUID Generation Main Class\n*\n* @class FableUUID\n* @constructor\n*/\n\nvar libRandomByteGenerator = require('./Fable-UUID-Random.js')\n\nclass FableUUID\n{\n\tconstructor(pSettings)\n\t{\n\t\t// Determine if the module is in \"Random UUID Mode\" which means just use the random character function rather than the v4 random UUID spec.\n\t\t// Note this allows UUIDs of various lengths (including very short ones) although guaranteed uniqueness goes downhill fast.\n\t\tthis._UUIDModeRandom = (typeof(pSettings) === 'object') && (pSettings.hasOwnProperty('UUIDModeRandom')) ? (pSettings.UUIDModeRandom == true) : false;\n\t\t// These two properties are only useful if we are in Random mode.  Otherwise it generates a v4 spec\n\t\t// Length for \"Random UUID Mode\" is set -- if not set it to 8\n\t\tthis._UUIDLength = (typeof(pSettings) === 'object') && (pSettings.hasOwnProperty('UUIDLength')) ? (pSettings.UUIDLength + 0) : 8;\n\t\t// Dictionary for \"Random UUID Mode\"\n\t\tthis._UUIDRandomDictionary = (typeof(pSettings) === 'object') && (pSettings.hasOwnProperty('UUIDDictionary')) ? (pSettings.UUIDDictionary + 0) : '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n\n\t\tthis.randomByteGenerator = new libRandomByteGenerator();\n\n\t\t// Lookup table for hex codes\n\t\tthis._HexLookup = [];\n\t\tfor (let i = 0; i < 256; ++i)\n\t\t{\n\t\t\tthis._HexLookup[i] = (i + 0x100).toString(16).substr(1);\n\t\t}\n\t}\n\n\t// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n\tbytesToUUID(pBuffer)\n\t{\n\t\tlet i = 0;\n\t\t// join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n\t\treturn ([\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], \n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]]\n\t\t\t\t]).join('');\n\t}\n\n\t// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n\tgenerateUUIDv4()\n\t{\n\t\tlet tmpBuffer = new Array(16);\n\t\tvar tmpRandomBytes = this.randomByteGenerator.generate();\n\n\t\t// Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\t\ttmpRandomBytes[6] = (tmpRandomBytes[6] & 0x0f) | 0x40;\n\t\ttmpRandomBytes[8] = (tmpRandomBytes[8] & 0x3f) | 0x80;\n\n\t\treturn this.bytesToUUID(tmpRandomBytes);\n\t}\n\n\t// Simple random UUID generation\n\tgenerateRandom()\n\t{\n\t\tlet tmpUUID = '';\n\n\t\tfor (let i = 0; i < this._UUIDLength; i++)\n\t\t{\n\t\t\ttmpUUID += this._UUIDRandomDictionary.charAt(Math.floor(Math.random() * (this._UUIDRandomDictionary.length-1)));\n\t\t}\n\n\t\treturn tmpUUID;\n\t}\n\n\t// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n\tgetUUID()\n\t{\n\t\tif (this._UUIDModeRandom)\n\t\t{\n\t\t\treturn this.generateRandom();\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.generateUUIDv4();\n\t\t}\n\t}\n}\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new FableUUID(pSettings);\n}\n\n\nmodule.exports = FableUUID;\nmodule.exports.new = autoConstruct;\n\n},{\"./Fable-UUID-Random.js\":27}],29:[function(require,module,exports){\n(function (process){(function (){\n// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n\n}).call(this)}).call(this,require('_process'))\n\n},{\"_process\":33}],30:[function(require,module,exports){\n/**\n* Precedent Meta-Templating\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Process text streams, parsing out meta-template expressions.\n*/\nvar libWordTree = require(`./WordTree.js`);\nvar libStringParser = require(`./StringParser.js`);\n\nclass Precedent\n{\n\t/**\n\t * Precedent Constructor\n\t */\n\tconstructor()\n\t{\n\t\tthis.WordTree = new libWordTree();\n\t\t\n\t\tthis.StringParser = new libStringParser();\n\n\t\tthis.ParseTree = this.WordTree.ParseTree;\n\t}\n\t\n\t/**\n\t * Add a Pattern to the Parse Tree\n\t * @method addPattern\n\t * @param {Object} pTree - A node on the parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @param {number} pIndex - callback function\n\t * @return {bool} True if adding the pattern was successful\n\t */\n\taddPattern(pPatternStart, pPatternEnd, pParser)\n\t{\n\t\treturn this.WordTree.addPattern(pPatternStart, pPatternEnd, pParser);\n\t}\n\t\n\t/**\n\t * Parse a string with the existing parse tree\n\t * @method parseString\n\t * @param {string} pString - The string to parse\n\t * @return {string} The result from the parser\n\t */\n\tparseString(pString)\n\t{\n\t\treturn this.StringParser.parseString(pString, this.ParseTree);\n\t}\n}\n\nmodule.exports = Precedent;\n\n},{\"./StringParser.js\":31,\"./WordTree.js\":32}],31:[function(require,module,exports){\n/**\n* String Parser\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Parse a string, properly processing each matched token in the word tree.\n*/\n\nclass StringParser\n{\n\t/**\n\t * StringParser Constructor\n\t */\n\tconstructor()\n\t{\n\t}\n\t\n\t/**\n\t * Create a fresh parsing state object to work with.\n\t * @method newParserState\n\t * @param {Object} pParseTree - A node on the parse tree to begin parsing from (usually root)\n\t * @return {Object} A new parser state object for running a character parser on\n\t * @private\n\t */\n\tnewParserState (pParseTree)\n\t{\n\t\treturn (\n\t\t{\n\t\t\tParseTree: pParseTree,\n\n\t\t\tOutput: '',\n\t\t\tOutputBuffer: '',\n\n\t\t\tPattern: false,\n\n\t\t\tPatternMatch: false,\n\t\t\tPatternMatchOutputBuffer: ''\n\t\t});\n\t}\n\t\t\n\t/**\n\t * Assign a node of the parser tree to be the next potential match.\n\t * If the node has a PatternEnd property, it is a valid match and supercedes the last valid match (or becomes the initial match).\n\t * @method assignNode\n\t * @param {Object} pNode - A node on the parse tree to assign\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tassignNode (pNode, pParserState)\n\t{\n\t\tpParserState.PatternMatch = pNode;\n\n\t\t// If the pattern has a END we can assume it has a parse function...\n\t\tif (pParserState.PatternMatch.hasOwnProperty('PatternEnd'))\n\t\t{\n\t\t\t// ... this is the legitimate start of a pattern.\n\t\t\tpParserState.Pattern = pParserState.PatternMatch;\n\t\t}\n\t}\n\t\n\t/**\n\t * Append a character to the output buffer in the parser state.\n\t * This output buffer is used when a potential match is being explored, or a match is being explored.\n\t * @method appendOutputBuffer\n\t * @param {string} pCharacter - The character to append\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tappendOutputBuffer (pCharacter, pParserState)\n\t{\n\t\tpParserState.OutputBuffer += pCharacter;\n\t}\n\t\n\t/**\n\t * Flush the output buffer to the output and clear it.\n\t * @method flushOutputBuffer\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tflushOutputBuffer (pParserState)\n\t{\n\t\tpParserState.Output += pParserState.OutputBuffer;\n\t\tpParserState.OutputBuffer = '';\n\t}\n\n\t\n\t/**\n\t * Check if the pattern has ended.  If it has, properly flush the buffer and start looking for new patterns.\n\t * @method checkPatternEnd\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tcheckPatternEnd (pParserState)\n\t{\n\t\tif ((pParserState.OutputBuffer.length >= pParserState.Pattern.PatternEnd.length+pParserState.Pattern.PatternStart.length) && \n\t\t\t(pParserState.OutputBuffer.substr(-pParserState.Pattern.PatternEnd.length) === pParserState.Pattern.PatternEnd))\n\t\t{\n\t\t\t// ... this is the end of a pattern, cut off the end tag and parse it.\n\t\t\t// Trim the start and end tags off the output buffer now\n\t\t\tpParserState.OutputBuffer = pParserState.Pattern.Parse(pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStart.length, pParserState.OutputBuffer.length - (pParserState.Pattern.PatternStart.length+pParserState.Pattern.PatternEnd.length)));\n\t\t\t// Flush the output buffer.\n\t\t\tthis.flushOutputBuffer(pParserState);\n\t\t\t// End pattern mode\n\t\t\tpParserState.Pattern = false;\n\t\t\tpParserState.PatternMatch = false;\n\t\t}\n\t}\n\t\n\t/**\n\t * Parse a character in the buffer.\n\t * @method parseCharacter\n\t * @param {string} pCharacter - The character to append\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tparseCharacter (pCharacter, pParserState)\n\t{\n\t\t// (1) If we aren't in a pattern match, and we aren't potentially matching, and this may be the start of a new pattern....\n\t\tif (!pParserState.PatternMatch && pParserState.ParseTree.hasOwnProperty(pCharacter))\n\t\t{\n\t\t\t// ... assign the node as the matched node.\n\t\t\tthis.assignNode(pParserState.ParseTree[pCharacter], pParserState);\n\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t}\n\t\t// (2) If we are in a pattern match (actively seeing if this is part of a new pattern token)\n\t\telse if (pParserState.PatternMatch)\n\t\t{\n\t\t\t// If the pattern has a subpattern with this key\n\t\t\tif (pParserState.PatternMatch.hasOwnProperty(pCharacter))\n\t\t\t{\n\t\t\t\t// Continue matching patterns.\n\t\t\t\tthis.assignNode(pParserState.PatternMatch[pCharacter], pParserState);\n\t\t\t}\n\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\tif (pParserState.Pattern)\n\t\t\t{\n\t\t\t\t// ... Check if this is the end of the pattern (if we are matching a valid pattern)...\n\t\t\t\tthis.checkPatternEnd(pParserState);\n\t\t\t}\n\t\t}\n\t\t// (3) If we aren't in a pattern match or pattern, and this isn't the start of a new pattern (RAW mode)....\n\t\telse\n\t\t{\n\t\t\tpParserState.Output += pCharacter;\n\t\t}\n\t}\n\t\n\t/**\n\t * Parse a string for matches, and process any template segments that occur.\n\t * @method parseString\n\t * @param {string} pString - The string to parse.\n\t * @param {Object} pParseTree - The parse tree to begin parsing from (usually root)\n\t */\n\tparseString (pString, pParseTree)\n\t{\n\t\tlet tmpParserState = this.newParserState(pParseTree);\n\n\t\tfor (var i = 0; i < pString.length; i++)\n\t\t{\n\t\t\t// TODO: This is not fast.\n\t\t\tthis.parseCharacter(pString[i], tmpParserState);\n\t\t}\n\t\t\n\t\tthis.flushOutputBuffer(tmpParserState);\n\t\t\n\t\treturn tmpParserState.Output;\n\t}\n}\n\nmodule.exports = StringParser;\n\n},{}],32:[function(require,module,exports){\n/**\n* Word Tree\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Create a tree (directed graph) of Javascript objects, one character per object.\n*/\n\nclass WordTree\n{\n\t/**\n\t * WordTree Constructor\n\t */\n\tconstructor()\n\t{\n\t\tthis.ParseTree = {};\n\t}\n\t\n\t/** \n\t * Add a child character to a Parse Tree node\n\t * @method addChild\n\t * @param {Object} pTree - A parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @param {number} pIndex - The index of the character in the pattern\n\t * @returns {Object} The resulting leaf node that was added (or found)\n\t * @private\n\t */\n\taddChild (pTree, pPattern, pIndex)\n\t{\n\t\tif (!pTree.hasOwnProperty(pPattern[pIndex]))\n\t\t\tpTree[pPattern[pIndex]] = {};\n\t\t\n\t\treturn pTree[pPattern[pIndex]];\n\t}\n\t\n\t/** Add a Pattern to the Parse Tree\n\t * @method addPattern\n\t * @param {Object} pPatternStart - The starting string for the pattern (e.g. \"${\")\n\t * @param {string} pPatternEnd - The ending string for the pattern (e.g. \"}\")\n\t * @param {number} pParser - The function to parse if this is the matched pattern, once the Pattern End is met.  If this is a string, a simple replacement occurs.\n\t * @return {bool} True if adding the pattern was successful\n\t */\n\taddPattern (pPatternStart, pPatternEnd, pParser)\n\t{\n\t\tif (pPatternStart.length < 1)\n\t\t\treturn false;\n\n\t\tif ((typeof(pPatternEnd) === 'string') && (pPatternEnd.length < 1))\n\t\t\treturn false;\n\n\t\tlet tmpLeaf = this.ParseTree;\n\n\t\t// Add the tree of leaves iteratively\n\t\tfor (var i = 0; i < pPatternStart.length; i++)\n\t\t\ttmpLeaf = this.addChild(tmpLeaf, pPatternStart, i);\n\n\t\ttmpLeaf.PatternStart = pPatternStart;\n\t\ttmpLeaf.PatternEnd = ((typeof(pPatternEnd) === 'string') && (pPatternEnd.length > 0)) ? pPatternEnd : pPatternStart;\n\t\ttmpLeaf.Parse = (typeof(pParser) === 'function') ? pParser : \n\t\t\t\t\t\t(typeof(pParser) === 'string') ? () => { return pParser; } :\n\t\t\t\t\t\t(pData) => { return pData; };\n\n\t\treturn true;\n\t}\n}\n\nmodule.exports = WordTree;\n\n},{}],33:[function(require,module,exports){\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],34:[function(require,module,exports){\n(function (setImmediate,clearImmediate){(function (){\nvar nextTick = require('process/browser.js').nextTick;\nvar apply = Function.prototype.apply;\nvar slice = Array.prototype.slice;\nvar immediateIds = {};\nvar nextImmediateId = 0;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) { timeout.close(); };\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// That's not how node.js implements it but the exposed api is the same.\nexports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n  var id = nextImmediateId++;\n  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n  immediateIds[id] = true;\n\n  nextTick(function onNextTick() {\n    if (immediateIds[id]) {\n      // fn.call() is faster so we optimize for the common use-case\n      // @see http://jsperf.com/call-apply-segu\n      if (args) {\n        fn.apply(null, args);\n      } else {\n        fn.call(null);\n      }\n      // Prevent ids from leaking\n      exports.clearImmediate(id);\n    }\n  });\n\n  return id;\n};\n\nexports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n  delete immediateIds[id];\n};\n}).call(this)}).call(this,require(\"timers\").setImmediate,require(\"timers\").clearImmediate)\n\n},{\"process/browser.js\":33,\"timers\":34}],35:[function(require,module,exports){\nvar libNPMModuleWrapper = require('./Fable.js');\n\nif ((typeof(window) === 'object') && !window.hasOwnProperty('Fable'))\n{\n\twindow.Fable = libNPMModuleWrapper;\n}\n\nmodule.exports = libNPMModuleWrapper;\n},{\"./Fable.js\":42}],36:[function(require,module,exports){\nconst _OperationStatePrototype = JSON.stringify(\n{\n\t\"Metadata\": {\n\t\t\"GUID\": false,\n\t\t\"Hash\": false,\n\n\t\t\"Title\": \"\",\n\t\t\"Summary\": \"\",\n\n\t\t\"Version\": 0\n\t},\n\t\"Status\": {\n        \"Completed\": false,\n\n        \"CompletionProgress\": 0,\n        \"CompletionTimeElapsed\": 0,\n\n        \"Steps\": 1,\n        \"StepsCompleted\": 0,\n\n        \"StartTime\": 0,\n        \"EndTime\": 0\n\t},\n\t\"Errors\": [],\n\t\"Log\": []\n});\n\nclass FableOperation\n{\n\tconstructor(pFable, pOperationName, pOperationHash)\n\t{\n\t\tthis.fable = pFable;\n\n\t\tthis.name = pOperationName;\n\n\t\tthis.state = JSON.parse(_OperationStatePrototype);\n\n\t\tthis.state.Metadata.GUID = this.fable.getUUID();\n\t\tthis.state.Metadata.Hash = this.state.GUID;\n\n\t\tif (typeof(pOperationHash) == 'string')\n\t\t{\n\t\t\tthis.state.Metadata.Hash = pOperationHash;\n\t\t}\n\t}\n\n\tget GUID()\n\t{\n\t\treturn this.state.Metadata.GUID;\n\t}\n\n\tget Hash()\n\t{\n\t\treturn this.state.Metadata.Hash;\n\t}\n\n\tget log()\n\t{\n\t\treturn this;\n\t}\n\n\twriteOperationLog(pLogLevel, pLogText, pLogObject)\n\t{\n\t\tthis.state.Log.push(`${new Date().toUTCString()} [${pLogLevel}]: ${pLogText}`);\n\n\t\tif (typeof(pLogObject) == 'object')\n\t\t{\n\t\t\tthis.state.Log.push(JSON.stringify(pLogObject));\n\t\t}\n\t}\n\n\twriteOperationErrors(pLogText, pLogObject)\n\t{\n\t\tthis.state.Errors.push(`${pLogText}`);\n\n\t\tif (typeof(pLogObject) == 'object')\n\t\t{\n\t\t\tthis.state.Errors.push(JSON.stringify(pLogObject));\n\t\t}\n\t}\n\n\ttrace(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('TRACE', pLogText, pLogObject);\n\t\tthis.fable.log.trace(pLogText, pLogObject);\n\t}\n\n\tdebug(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('DEBUG', pLogText, pLogObject);\n\t\tthis.fable.log.debug(pLogText, pLogObject);\n\t}\n\n\tinfo(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('INFO', pLogText, pLogObject);\n\t\tthis.fable.log.info(pLogText, pLogObject);\n\t}\n\n\twarn(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('WARN', pLogText, pLogObject);\n\t\tthis.fable.log.warn(pLogText, pLogObject);\n\t}\n\n\terror(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('ERROR', pLogText, pLogObject);\n\t\tthis.writeOperationErrors(pLogText, pLogObject);\n\t\tthis.fable.log.error(pLogText, pLogObject);\n\t}\n\n\tfatal(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('FATAL', pLogText, pLogObject);\n\t\tthis.writeOperationErrors(pLogText, pLogObject);\n\t\tthis.fable.log.fatal(pLogText, pLogObject);\n\t}\n}\n\nmodule.exports = FableOperation;\n},{}],37:[function(require,module,exports){\nconst libFableServiceBase = require('./Fable-ServiceProviderBase.js');\nconst libDataArithmatic = require('data-arithmatic');\n\nclass FableServiceDataArithmatic extends libFableServiceBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n        super(pFable, pOptions, pServiceHash);\n\n        this.serviceType = 'DataArithmatic';\n\n        this._DataArithmaticLibrary = new libDataArithmatic();\n\t}\n}\n\nmodule.exports = FableServiceDataArithmatic;\n},{\"./Fable-ServiceProviderBase.js\":41,\"data-arithmatic\":17}],38:[function(require,module,exports){\nconst libFableServiceBase = require('./Fable-ServiceProviderBase.js');\n\nclass FableServiceTemplate extends libFableServiceBase\n{\n\t// Underscore and lodash have a behavior, _.template, which compiles a\n\t// string-based template with code snippets into simple executable pieces,\n\t// with the added twist of returning a precompiled function ready to go.\n\t//\n\t// NOTE: This does not implement underscore escape expressions\n\t// NOTE: This does not implement underscore magic browser variable assignment\n\t//\n\t// This is an implementation of that.\n\t// TODO: Make this use precedent, add configuration, add debugging.\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n        super(pFable, pOptions, pServiceHash);\n\n        this.serviceType = 'Template';\n\n\t\t// These are the exact regex's used in lodash/underscore\n\t\t// TODO: Switch this to precedent\n\t\tthis.Matchers = (\n\t\t\t{\n\t\t\t\tEvaluate: /<%([\\s\\S]+?)%>/g,\n\t\t\t\tInterpolate: /<%=([\\s\\S]+?)%>/g,\n\t\t\t\tEscaper: /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g,\n\t\t\t\tUnescaper: /\\\\(\\\\|'|r|n|t|u2028|u2029)/g,\n\t\t\t\t// This is how underscore does it, so we are keeping it for now.\n\t\t\t\tGuaranteedNonMatch: /.^/\n\t\t\t});\n\n\t\t// This is a helper for the escaper and unescaper functions.\n\t\t// Right now we are going to keep what underscore is doing, but, not forever.\n\t\tthis.templateEscapes = {\n\t\t\t'\\\\': '\\\\',\n\t\t\t\"'\": \"'\",\n\t\t\t'r': '\\r',\n\t\t\t'\\r': 'r',\n\t\t\t'n': '\\n',\n\t\t\t'\\n': 'n',\n\t\t\t't': '\\t',\n\t\t\t'\\t': 't',\n\t\t\t'u2028': '\\u2028',\n\t\t\t'\\u2028': 'u2028',\n\t\t\t'u2029': '\\u2029',\n\t\t\t'\\u2029': 'u2029'\n\t\t};\n\n\t\t// This is defined as such to underscore that it is a dynamic programming\n\t\t// function on this class.\n\t\tthis.renderFunction = false;\n        this.templateString = false;\n\t}\n\n\trenderTemplate(pData)\n\t{\n\t\treturn this.renderFunction(pData);\n\t}\n\n\ttemplateFunction(pData)\n\t{\n\t\tlet fRenderTemplateBound = this.renderTemplate.bind(this);\n\t\treturn fRenderTemplateBound;\n\t}\n\n\tbuildTemplateFunction(pTemplateText, pData)\n\t{\n\t\t// For now this is being kept in a weird form ... this is to mimic the old\n\t\t// underscore code until this is rewritten using precedent.\n\t\tthis.TemplateSource = \"__p+='\" + pTemplateText\n\t\t\t.replace(this.Matchers.Escaper,\n\t\t\t\t(pMatch)=>\n\t\t\t\t{\n\t\t\t\t\treturn `\\\\${this.templateEscapes[pMatch]}`;\n\t\t\t\t})\n\t\t\t.replace(this.Matchers.Interpolate || this.Matchers.GuaranteedNonMatch,\n\t\t\t\t(pMatch, pCode) =>\n\t\t\t\t{\n\t\t\t\t\treturn `'+\\n(${decodeURIComponent(pCode)})+\\n'`;\n\t\t\t\t})\n\t\t\t.replace(this.Matchers.Evaluate || this.Matchers.GuaranteedNonMatch,\n\t\t\t\t(pMatch, pCode) =>\n\t\t\t\t{\n\t\t\t\t\treturn `';\\n${decodeURIComponent(pCode)}\\n;__p+='`;\n\t\t\t\t}) + `';\\n`;\n\n\n\t\tthis.TemplateSource = `with(pTemplateDataObject||{}){\\n${this.TemplateSource}}\\n`;\n\t\tthis.TemplateSource = `var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};\\n${this.TemplateSource}return __p;\\n`;\n\n\t\tthis.renderFunction = new Function('pTemplateDataObject', this.TemplateSource);\n\n\t\tif (typeof(pData) != 'undefined')\n\t\t{\n\t\t\treturn this.renderFunction(pData);\n\t\t}\n\n\t\t// Provide the compiled function source as a convenience for build time\n\t\t// precompilation.\n\t\tthis.TemplateSourceCompiled = 'function(obj){\\n' + this.TemplateSource + '}';\n\n\t\treturn this.templateFunction();\n\t}\n}\n\nmodule.exports = FableServiceTemplate;\n},{\"./Fable-ServiceProviderBase.js\":41}],39:[function(require,module,exports){\nconst libFableServiceBase = require('./Fable-ServiceProviderBase.js');\n\n\n// TODO: These are still pretty big -- consider the smaller polyfills\nconst libAsyncWaterfall = require('async.waterfall');\nconst libAsyncEachLimit = require('async.eachlimit');\n\nclass FableServiceUtility extends libFableServiceBase\n{\n\t// Underscore and lodash have a behavior, _.template, which compiles a\n\t// string-based template with code snippets into simple executable pieces,\n\t// with the added twist of returning a precompiled function ready to go.\n\t//\n\t// NOTE: This does not implement underscore escape expressions\n\t// NOTE: This does not implement underscore magic browser variable assignment\n\t//\n\t// This is an implementation of that.\n\t// TODO: Make this use precedent, add configuration, add debugging.\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n        super(pFable, pOptions, pServiceHash);\n\n\t\tthis.templates = {};\n\n\t\t// These two functions are used extensively throughout\n\t\tthis.waterfall = libAsyncWaterfall;\n\t\tthis.eachLimit = libAsyncEachLimit;\n\t}\n\n\t// Underscore and lodash have a behavior, _.extend, which merges objects.\n\t// Now that es6 gives us this, use the native thingy.\n\textend(pDestinationObject, ...pSourceObjects)\n\t{\n\t\treturn Object.assign(pDestinationObject, ...pSourceObjects);\n\t}\n\n\t// Underscore and lodash have a behavior, _.template, which compiles a\n\t// string-based template with code snippets into simple executable pieces,\n\t// with the added twist of returning a precompiled function ready to go.\n\ttemplate(pTemplateText, pData)\n\t{\n\t\tlet tmpTemplate = this.fable.serviceManager.instantiateServiceProviderWithoutRegistration('Template');\n\n\t\treturn tmpTemplate.buildTemplateFunction(pTemplateText, pData);\n\t}\n\n\t// Build a template function from a template hash, and, register it with the service provider\n\tbuildHashedTemplate(pTemplateHash, pTemplateText, pData)\n\t{\n\t\tlet tmpTemplate = this.fable.serviceManager.instantiateServiceProvider('Template', {}, pTemplateHash);\n\n\t\tthis.templates[pTemplateHash] = tmpTemplate.buildTemplateFunction(pTemplateText, pData);\n\n\t\treturn this.templates[pTemplateHash];\n\t}\n\n\t// This is a safe, modern version of chunk from underscore\n\t// Algorithm pulled from a mix of these two polyfills:\n\t// https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_chunk\n\t// https://youmightnotneed.com/lodash\n\t// This implementation was most tolerant in browsers.  Uglify can fix the rest.\n\tchunk (pInput, pChunkSize, pChunkCache)\n\t{\n\t\tlet tmpInputArray = [...pInput];\n\t\t// Note lodash defaults to 1, underscore defaults to 0\n\t\tlet tmpChunkSize = (typeof(pChunkSize) == 'number') ? pChunkSize : 0;\n\t\tlet tmpChunkCache = (typeof(pChunkCache) != 'undefined') ? pChunkCache : [];\n\n\t\tif (tmpChunkSize <= 0)\n\t\t{\n\t\t\treturn tmpChunkCache;\n\t\t}\n\n\t\twhile (tmpInputArray.length)\n\t\t{\n\t\t\ttmpChunkCache.push(tmpInputArray.splice(0, tmpChunkSize));\n\t\t}\n\n\t\treturn tmpChunkCache;\n\t}\n}\n\nmodule.exports = FableServiceUtility;\n},{\"./Fable-ServiceProviderBase.js\":41,\"async.eachlimit\":1,\"async.waterfall\":15}],40:[function(require,module,exports){\n/**\n* Fable Application Services Management\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\nconst libFableServiceBase = require('./Fable-ServiceProviderBase.js');\n\nclass FableService\n{\n\tconstructor(pFable)\n\t{\n\t\tthis.fable = pFable;\n\n\t\tthis.serviceTypes = [];\n\n\t\t// A map of instantiated services\n\t\tthis.services = {};\n\n\t\t// A map of the default instantiated service by type\n\t\tthis.defaultServices = {};\n\n\t\t// A map of class constructors for services\n\t\tthis.serviceClasses = {};\n\t}\n\n\taddServiceType(pServiceType, pServiceClass)\n\t{\n\t\t// Add the type to the list of types\n\t\tthis.serviceTypes.push(pServiceType);\n\n\t\t// Add the container for instantiated services to go in\n\t\tthis.services[pServiceType] = {};\n\n\t\tif ((typeof(pServiceClass) == 'function') && (pServiceClass.prototype instanceof libFableServiceBase))\n\t\t{\n\t\t\t// Add the class to the list of classes\n\t\t\tthis.serviceClasses[pServiceType] = pServiceClass;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Add the base class to the list of classes\n\t\t\tthis.serviceClasses[pServiceType] = libFableServiceBase;\n\t\t}\n\t}\n\n\tinstantiateServiceProvider(pServiceType, pOptions, pCustomServiceHash)\n\t{\n\t\t// Instantiate the service\n\t\tlet tmpService = this.instantiateServiceProviderWithoutRegistration(pServiceType, pOptions, pCustomServiceHash);\n\n\t\t// Add the service to the service map\n\t\tthis.services[pServiceType][tmpService.Hash] = tmpService;\n\n\t\t// If this is the first service of this type, make it the default\n\t\tif (!this.defaultServices.hasOwnProperty(pServiceType))\n\t\t{\n\t\t\tthis.defaultServices[pServiceType] = tmpService;\n\t\t}\n\n\t\treturn tmpService;\n\t}\n\n\t// Create a service provider but don't register it to live forever in fable.services\n\tinstantiateServiceProviderWithoutRegistration(pServiceType, pOptions, pCustomServiceHash)\n\t{\n\t\t// Instantiate the service\n\t\tlet tmpService = new this.serviceClasses[pServiceType](this.fable, pOptions, pCustomServiceHash);\n\t\treturn tmpService;\n\t}\n\n\tsetDefaultServiceInstantiation(pServiceType, pServiceHash)\n\t{\n\t\tif (this.services[pServiceType].hasOwnProperty(pServiceHash))\n\t\t{\n\t\t\tthis.defaultServices[pServiceType] = this.services[pServiceType][pServiceHash];\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n}\n\nmodule.exports = FableService;\n\nmodule.exports.ServiceProviderBase = libFableServiceBase;\n},{\"./Fable-ServiceProviderBase.js\":41}],41:[function(require,module,exports){\n/**\n* Fable Service Base\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\nclass FableServiceProviderBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tthis.fable = pFable;\n\n\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions : {};\n\n        this.serviceType = 'Unknown';\n\n        this.UUID = pFable.getUUID();\n\n        this.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash : `${this.UUID}`;\n\t}\n}\n\nmodule.exports = FableServiceProviderBase;\n\n},{}],42:[function(require,module,exports){\n/**\n* Fable Application Services Support Library\n* @license MIT\n* @author <steven@velozo.com>\n*/\nconst libFableSettings = require('fable-settings');\nconst libFableUUID = require('fable-uuid');\nconst libFableLog = require('fable-log');\n\nconst libFableServiceManager = require('./Fable-ServiceManager.js');\n\nconst libFableServiceDataArithmatic = require('./Fable-Service-DataArithmatic.js');\nconst libFableServiceTemplate = require('./Fable-Service-Template.js');\nconst libFableServiceUtility = require('./Fable-Service-Utility.js');\n\nconst libFableOperation = require('./Fable-Operation.js');\n\nclass Fable\n{\n\tconstructor(pSettings)\n\t{\n\t\tlet tmpSettings = new libFableSettings(pSettings);\n\n\t\tthis.settingsManager = tmpSettings;\n\n\t\t// Instantiate the UUID generator\n\t\tthis.libUUID = new libFableUUID(this.settingsManager.settings);\n\n\t\tthis.log = new libFableLog(this.settingsManager.settings);\n\t\tthis.log.initialize();\n\n\t\t// Built-in dependencies\n\t\tthis.Dependencies = (\n\t\t\t{\n\t\t\t\tprecedent: libFableSettings.precedent\n\t\t\t});\n\n\t\t// Location for Operation state\n\t\tthis.Operations = {};\n\n\t\tthis.serviceManager = new libFableServiceManager(this);\n\n\t\t// Initialize and instantiate the default baked-in Data Arithmatic service\n\t\tthis.serviceManager.addServiceType('DataArithmatic', libFableServiceDataArithmatic);\n\t\tthis.fable.serviceManager.instantiateServiceProvider('DataArithmatic', {}, 'Default-Service-DataArithmatic');\n\t\t// This service is passing through the data arithmatic library\n\t\tthis.DataArithmatic = this.serviceManager.defaultServices.DataArithmatic._DataArithmaticLibrary;\n\n\t\t// Initialize the template service\n\t\tthis.serviceManager.addServiceType('Template', libFableServiceTemplate);\n\n\t\t// Initialize and instantiate the default baked-in Utility service\n\t\tthis.serviceManager.addServiceType('Utility', libFableServiceUtility)\n\t\tthis.fable.serviceManager.instantiateServiceProvider('Utility', {}, 'Default-Service-Utility');\n\t\tthis.Utility = this.serviceManager.defaultServices.Utility;\n\n\t\tthis.services = this.serviceManager.services;\n\t\tthis.defaultServices = this.serviceManager.defaultServices;\n\t}\n\n\tget settings()\n\t{\n\t\treturn this.settingsManager.settings;\n\t}\n\n\tget fable()\n\t{\n\t\treturn this;\n\t}\n\n\tgetUUID()\n\t{\n\t\treturn this.libUUID.getUUID();\n\t}\n\n\tcreateOperation(pOperationName, pOperationHash)\n\t{\n\t\tlet tmpOperation = new libFableOperation(this, pOperationName, pOperationHash);\n\n\t\tif (this.Operations.hasOwnProperty(tmpOperation.Hash))\n\t\t{\n\t\t\t// Uh Oh ...... Operation Hash Collision!\n\t\t\t// TODO: What to do?!\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.Operations[tmpOperation.Hash] = tmpOperation;\n\t\t}\n\n\t\treturn tmpOperation;\n\t}\n\n\tgetOperation(pOperationHash)\n\t{\n\t\tif (!this.Operations.hasOwnProperty(pOperationHash))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.Operations[pOperationHash];\n\t\t}\n\t}\n}\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new Fable(pSettings);\n}\n\nmodule.exports = Fable;\nmodule.exports.new = autoConstruct;\n\nmodule.exports.LogProviderBase = libFableLog.LogProviderBase;\nmodule.exports.ServiceProviderBase = libFableServiceManager.ServiceProviderBase;\n\nmodule.exports.precedent = libFableSettings.precedent;\n},{\"./Fable-Operation.js\":36,\"./Fable-Service-DataArithmatic.js\":37,\"./Fable-Service-Template.js\":38,\"./Fable-Service-Utility.js\":39,\"./Fable-ServiceManager.js\":40,\"fable-log\":23,\"fable-settings\":26,\"fable-uuid\":28}]},{},[35])(35)\n});\n\n","(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","'use strict';\n\nvar eachOfLimit = require('async.util.eachoflimit');\nvar withoutIndex = require('async.util.withoutindex');\n\nmodule.exports = function eachLimit(arr, limit, iterator, cb) {\n    return eachOfLimit(limit)(arr, withoutIndex(iterator), cb);\n};\n","'use strict';\n\nmodule.exports = function(tasks) {\n    function makeCallback(index) {\n        function fn() {\n            if (tasks.length) {\n                tasks[index].apply(null, arguments);\n            }\n            return fn.next();\n        }\n        fn.next = function() {\n            return (index < tasks.length - 1) ? makeCallback(index + 1) : null;\n        };\n        return fn;\n    }\n    return makeCallback(0);\n};\n","var once = require('async.util.once');\nvar noop = require('async.util.noop');\nvar onlyOnce = require('async.util.onlyonce');\nvar keyIterator = require('async.util.keyiterator');\n\nmodule.exports = function eachOfLimit(limit) {\n    return function(obj, iterator, cb) {\n        cb = once(cb || noop);\n        obj = obj || [];\n        var nextKey = keyIterator(obj);\n        if (limit <= 0) {\n            return cb(null);\n        }\n        var done = false;\n        var running = 0;\n        var errored = false;\n\n        (function replenish() {\n            if (done && running <= 0) {\n                return cb(null);\n            }\n\n            while (running < limit && !errored) {\n                var key = nextKey();\n                if (key === null) {\n                    done = true;\n                    if (running <= 0) {\n                        cb(null);\n                    }\n                    return;\n                }\n                running += 1;\n                iterator(obj[key], key, onlyOnce(function(err) {\n                    running -= 1;\n                    if (err) {\n                        cb(err);\n                        errored = true;\n                    } else {\n                        replenish();\n                    }\n                }));\n            }\n        })();\n    };\n};\n","'use strict';\nvar setImmediate = require('async.util.setimmediate');\nvar restParam = require('async.util.restparam');\n\nmodule.exports = function(fn) {\n    return restParam(function(args) {\n        var callback = args.pop();\n        args.push(function() {\n            var innerArgs = arguments;\n            if (sync) {\n                setImmediate(function() {\n                    callback.apply(null, innerArgs);\n                });\n            } else {\n                callback.apply(null, innerArgs);\n            }\n        });\n        var sync = true;\n        fn.apply(this, args);\n        sync = false;\n    });\n};\n","'use strict';\n\nmodule.exports = Array.isArray || function isArray(obj) {\n    return Object.prototype.toString.call(obj) === '[object Array]';\n};\n","'use strict';\n\nvar isArray = require('async.util.isarray');\n\nmodule.exports = function isArrayLike(arr) {\n    return isArray(arr) || (\n        // has a positive integer length property\n        typeof arr.length === 'number' &&\n        arr.length >= 0 &&\n        arr.length % 1 === 0\n    );\n};\n","'use strict';\n\nvar _keys = require('async.util.keys');\nvar isArrayLike = require('async.util.isarraylike');\n\nmodule.exports = function keyIterator(coll) {\n    var i = -1;\n    var len;\n    var keys;\n    if (isArrayLike(coll)) {\n        len = coll.length;\n        return function next() {\n            i++;\n            return i < len ? i : null;\n        };\n    } else {\n        keys = _keys(coll);\n        len = keys.length;\n        return function next() {\n            i++;\n            return i < len ? keys[i] : null;\n        };\n    }\n};\n","'use strict';\n\nmodule.exports = Object.keys || function keys(obj) {\n    var _keys = [];\n    for (var k in obj) {\n        if (obj.hasOwnProperty(k)) {\n            _keys.push(k);\n        }\n    }\n    return _keys;\n};\n","'use strict';\n\nmodule.exports = function noop () {};\n","'use strict';\n\nmodule.exports = function once(fn) {\n    return function() {\n        if (fn === null) return;\n        fn.apply(this, arguments);\n        fn = null;\n    };\n};\n","'use strict';\n\nmodule.exports = function only_once(fn) {\n    return function() {\n        if (fn === null) throw new Error('Callback was already called.');\n        fn.apply(this, arguments);\n        fn = null;\n    };\n};\n","'use strict';\nmodule.exports = function restParam(func, startIndex) {\n    startIndex = startIndex == null ? func.length - 1 : +startIndex;\n    return function() {\n        var length = Math.max(arguments.length - startIndex, 0);\n        var rest = new Array(length);\n        for (var index = 0; index < length; index++) {\n            rest[index] = arguments[index + startIndex];\n        }\n        switch (startIndex) {\n            case 0:\n                return func.call(this, rest);\n            case 1:\n                return func.call(this, arguments[0], rest);\n        }\n    };\n};\n","'use strict';\n\nvar _setImmediate = typeof setImmediate === 'function' && setImmediate;\nvar fallback = function(fn) {\n    setTimeout(fn, 0);\n};\n\nmodule.exports = function setImmediate(fn) {\n    // not a direct alias for IE10 compatibility\n    return (_setImmediate || fallback)(fn);\n};\n","'use strict';\n\nmodule.exports = function withoutIndex(iterator) {\n    return function(value, index, callback) {\n        return iterator(value, callback);\n    };\n};\n","'use strict';\n\nvar once = require('async.util.once');\nvar noop = require('async.util.noop');\nvar isArray = require('async.util.isarray');\nvar restParam = require('async.util.restparam');\nvar ensureAsync = require('async.util.ensureasync');\nvar iterator = require('async.iterator');\n\nmodule.exports = function(tasks, cb) {\n    cb = once(cb || noop);\n    if (!isArray(tasks)) return cb(new Error('First argument to waterfall must be an array of functions'));\n    if (!tasks.length) return cb();\n\n    function wrapIterator(iterator) {\n        return restParam(function(err, args) {\n            if (err) {\n                cb.apply(null, [err].concat(args));\n            } else {\n                var next = iterator.next();\n                if (next) {\n                    args.push(wrapIterator(next));\n                } else {\n                    args.push(cb);\n                }\n                ensureAsync(iterator).apply(null, args);\n            }\n        });\n    }\n    wrapIterator(iterator(tasks))();\n};\n","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\n/**\n* Data Arithmatic\n*\n* @class DataArithmatic\n*/\nclass DataArithmatic\n{\n\tconstructor()\n\t{\n\t\t// Regular Expressions (so they don't have to be recompiled every time)\n\t\t// These could be defined as static, but I'm not sure if that will work with browserify ... and specifically the QT browser.\n\t\tthis._Regex_formatterInsertCommas = /.{1,3}/g;\n\t\t// Match Function:\n\t\t// function(pMatch, pSign, pZeros, pBefore, pDecimal, pAfter)\n\t\t// Thoughts about below:   /^([+-]?)(0*)(\\d+)(\\.(\\d+))?$/;\n\t\tthis._Regex_formatterAddCommasToNumber = /^([-+]?)(0?)(\\d+)(.?)(\\d+)$/g;\n\t\tthis._Regex_formatterDollarsRemoveCommas = /,/gi;\n\t\tthis._Regex_formatterCleanNonAlpha = /[^a-z0-9]/gi;\n\n\t\t// TODO: Potentially pull these in from a configuration.\n\t\t// TODO: Use locale data for this if it's defaults all the way down.\n\t\tthis._Value_MoneySign_Currency = '$';\n\t\tthis._Value_NaN_Currency = '--';\n\t\tthis._Value_GroupSeparator_Number = ',';\n\n\t\tthis._Value_Prefix_StringHash = 'HSH';\n\t\tthis._Value_Clean_formatterCleanNonAlpha = '_';\n\n\t\tthis._UseEngineStringStartsWith = (typeof(String.prototype.startsWith) === 'function');\n\t\tthis._UseEngineStringEndsWith = (typeof(String.prototype.endsWith) === 'function');\n\t}\n\n\n\t/*************************************************************************\n\t * String Manipulation and Comparison Functions\n\t *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/\n\n\t/**\n\t * Reverse a string\n\t *\n\t * @param {string} pString - The string to reverse\n\t * @returns {string}\n\t */\n\tstringReverse (pString)\n\t{\n\t\t// TODO: Benchmark if there are faster ways we want to do this with all the newer JS stuff\n\t\t//       ... and if it will work with browserify in a clean way.\n\t    return pString.split('').reverse().join('');\n\t}\n\n\t/**\n\t * Test if a string starts with a given substring.\n\t *\n\t * @param {*} pString\n\t * @param {*} pSearchString\n\t * @param {*} pStartIndex\n\t * @returns {*}\n\t */\n\tstringStartsWith (pString, pSearchString, pStartIndex)\n\t{\n\t\tif (this._UseEngineStringStartsWith)\n\t\t{\n\t\t\treturn pString.startsWith(pSearchString, pStartIndex);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.stringStartsWith_Polyfill.call(pString, pSearchString, pStartIndex);\n\t\t}\n\t}\n\n\t/**\n\t * Check if a string starts with a given substring.  This is a safe polyfill for the ES6 string.startsWith() function.\n\t *\n\t * @param {*} pSearchString - The string to search for\n\t * @param {*} pStartIndex - The index to start the search at\n\t * @returns {boolean}\n\t */\n\tstringStartsWith_Polyfill (pSearchString, pStartIndex)\n\t{\n\t\treturn this.slice(pStartIndex || 0, pSearchString.length) === pSearchString;\n\t}\n\n\t/**\n\t * Test if a string starts with a given substring.\n\t *\n\t * @param {*} pString\n\t * @param {*} pSearchString\n\t * @param {*} pEndIndex\n\t * @returns {*}\n\t */\n\tstringEndsWith (pString, pSearchString, pEndIndex)\n\t{\n\t\tif (this._UseEngineStringEndsWith)\n\t\t{\n\t\t\treturn pString.endsWith(pSearchString, pEndIndex);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.stringEndsWith_Polyfill.call(pString, pSearchString, pEndIndex);\n\t\t}\n\t}\n\n\t/**\n\t * Check if a string starts with a given substring.  This is a safe polyfill for the ES6 string.startsWith() function.\n\t *\n\t * @param {*} pSearchString - The string to search for\n\t * @param {*} pEndIndex - The index to end the search at\n\t * @returns {boolean}\n\t */\n\tstringEndsWith_Polyfill (pSearchString, pEndIndex)\n\t{\n\t\t// This works much better than >= because\n\t\t// it compensates for NaN:\n\t\tif (!(pEndIndex < this.length))\n\t\t{\n\t\t\tpEndIndex = this.length;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpEndIndex |= 0; // round position\n\t\t}\n\t\treturn this.substr(pEndIndex - pSearchString.length, pSearchString.length) === pSearchString;\n\t}\n\n\t/**\n\t * Generate an insecure string hash.  Not meant to be secure, just a quick way to generate a hash for a string.  This is not a cryptographic hash.  Additional warranty and disclaimer ... this is not for passwords!\n\t *\n\t * @param {string} pString\n\t * @returns {string}\n\t */\n\tinsecureStringHash (pString)\n\t{\n\t    let tmpHash = 0;\n\t    let tmpStringLength = pString.length;\n\t    let tmpCharacterIndex = 0;\n\n\t    while (tmpCharacterIndex < tmpStringLength)\n\t    {\n\t        tmpHash = (tmpHash << 5) - tmpHash + pString.charCodeAt(tmpCharacterIndex++) | 0;\n\t    }\n\n\t    return `${this._Value_Prefix_StringHash}${tmpHash}`;\n\t}\n\n\t/**\n\t * Clean wrapping characters if they exist consistently around the string.  If they do not, the string is returned unchanged.\n\t *\n\t * @param {string} pWrapCharacter - The character expected as the wrapping character\n\t * @param {string} pString - the string to clean\n\t * @returns {string}\n\t */\n\tcleanEnclosureWrapCharacters (pWrapCharacter, pString)\n\t{\n\t\t// # Use case from ManyFest DSL:\n\t\t//\n\t\t// When a boxed property is passed in, it should have quotes of some\n\t\t// kind around it.\n\t\t//\n\t\t// For instance:\n\t\t// \t\tMyValues['Name']\n\t\t// \t\tMyValues[\"Age\"]\n\t\t// \t\tMyValues[`Cost`]\n\t\t//\n\t\t// This function is necessary to remove the wrapping quotes before object\n\t\t// resolution can occur.\n\t\tif (pString.startsWith(pWrapCharacter) && pString.endsWith(pWrapCharacter))\n\t\t{\n\t\t\treturn pString.substring(1, pString.length - 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn pString;\n\t\t}\n\t}\n\n\t/**\n\t *\n\t * @param {*} pString\n\t * @returns\n\t */\n\tcleanNonAlphaCharacters (pString)\n\t{\n\t    if ((typeof(pString) == 'string') && (pString != ''))\n\t    {\n\t        return pString.replace(this._Regex_formatterCleanNonAlpha, this._Value_Clean_formatterCleanNonAlpha);\n\t    }\n\t}\n\n\n\t/*************************************************************************\n\t * Number Formatting Functions\n\t *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/\n\n\t/**\n\t * Insert commas every 3 characters from the right.  Used by formatterAddCommasToNumber().\n\t *\n\t * @param {*} pString\n\t * @returns {*}\n\t */\n\tformatterInsertCommas (pString)\n\t{\n\t    // Reverse, because it's easier to do things from the left, given arbitrary digit counts\n\t    let tmpReversed = this.stringReverse(pString);\n\t    // Add commas every three characters\n\t    let tmpReversedWithCommas = tmpReversed.match(this._Regex_formatterInsertCommas).join(',');\n\t    // Reverse again (back to normal direction)\n\t    return this.stringReverse(tmpReversedWithCommas);\n\t}\n\n\tprocessAddCommasToNumberRegex(pMatch, pSign, pZeros, pBefore, pDecimal, pAfter)\n\t{\n\t\t// If there was no decimal, the last capture grabs the final digit, so\n\t\t// we have to put it back together with the 'before' substring\n\t\treturn pSign + (pDecimal ? this.formatterInsertCommas(pBefore) + pDecimal + pAfter : this.formatterInsertCommas(pBefore + pAfter));\n\t}\n\n\t/**\n\t * Add Commas to a Number for readability.\n\t *\n\t * @param {*} pNumber\n\t * @returns {string}\n\t */\n\tformatterAddCommasToNumber (pNumber)\n\t{\n\t    // If the regex doesn't match, `replace` returns the string unmodified\n\t    return (pNumber.toString()).replace\n\t    (\n\t\t\tthis._Regex_formatterAddCommasToNumber,\n\t        this.processAddCommasToNumberRegex.bind(this)\n\t    );\n\t}\n\n\t/**\n\t * This will take a number and format it as a dollar string.  It will also add commas to the number.  If the number is not a number, it will return '--'.\n\t *\n\t * @param {*} pValue\n\t * @returns {string}\n\t */\n\tformatterDollars (pValue)\n\t{\n\t    let tmpDollarAmount = parseFloat(pValue).toFixed(2);\n\n\t    if (isNaN(tmpDollarAmount))\n\t    {\n\t        // Try again and see if what was passed in was a dollars string.\n\t        if (typeof(pValue) == 'string')\n\t        {\n\t\t\t\t// TODO: Better rounding function?  This is a hack to get rid of the currency symbol and commas.\n\t            tmpDollarAmount = parseFloat(pValue.replace(this._Value_MoneySign_Currency,'').replace(this._Regex_formatterDollarsRemoveCommas,'')).toFixed(2);\n\t        }\n\t\t\t// If we didn't get a number, return the \"not a number\" string.\n\t        if (isNaN(tmpDollarAmount))\n\t        {\n\t            return this._Value_NaN_Currency;\n\t        }\n\t    }\n\n\t    // TODO: Get locale data and use that for this stuff.\n\t    return `$${this.formatterAddCommasToNumber(tmpDollarAmount)}`;\n\t}\n\n\t/**\n\t * Round a number to a certain number of digits.  If the number is not a number, it will return 0.  If no digits are specified, it will default to 2 significant digits.\n\t *\n\t * @param {*} pValue\n\t * @param {number} pDigits\n\t * @returns {string}\n\t */\n\tformatterRoundNumber (pValue, pDigits)\n\t{\n\t    let tmpDigits = (typeof(pDigits) == 'undefined') ? 2 : pDigits;\n\n\t    let tmpValue = Number.parseFloat(pValue).toFixed(tmpDigits);\n\t    if (isNaN(tmpValue))\n\t    {\n\t        let tmpZed = 0;\n\t        return tmpZed.toFixed(tmpDigits);\n\t    }\n\t    else\n\t    {\n\t        return tmpValue;\n\t    }\n\t}\n\n\n\t/*************************************************************************\n\t * String Tokenization Functions\n\t *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/\n\n\t/**\n\t * Return the string before the matched substring.\n\t *\n\t * If the substring is not found, the entire string is returned.  This only deals with the *first* match.\n\t *\n\t * @param {string} pString\n\t * @param {string} pMatch\n\t * @returns {string}\n\t */\n\tstringBeforeMatch (pString, pMatch)\n\t{\n\t\treturn pString.split(pMatch)[0];\n\t}\n\n\t/**\n\t * Return the string after the matched substring.\n\t *\n\t * If the substring is not found, an empty string is returned.  This only deals with the *first* match.\n\t *\n\t * @param {string} pString\n\t * @param {string} pMatch\n\t * @returns {string}\n\t */\n\tstringAfterMatch (pString, pMatch)\n\t{\n\t    let tmpStringSplitLocation = pString.indexOf(pMatch);\n\n\t\tif ((tmpStringSplitLocation < 0) || ((tmpStringSplitLocation + pMatch.length) >= pString.length))\n\t    {\n\t        return '';\n\t    }\n\n\t    return pString.substring(tmpStringSplitLocation + pMatch.length);\n\t}\n\n\t/**\n\t * Count the number of enclosures in a string based on the start and end characters.\n\t *\n\t * If no start or end characters are specified, it will default to parentheses.  If the string is not a string, it will return 0.\n\t *\n\t * @param {string} pString\n\t * @param {string} pEnclosureStart\n\t * @param {string} pEnclosureEnd\n\t * @returns the count of full in the string\n\t */\n\tstringCountEnclosures (pString, pEnclosureStart, pEnclosureEnd)\n\t{\n\t    let tmpString = (typeof(pString) == 'string') ? pString : '';\n\t    let tmpEnclosureStart = (typeof(pEnclosureStart) == 'string') ? pEnclosureStart : '(';\n\t    let tmpEnclosureEnd = (typeof(pEnclosureEnd) == 'string') ? pEnclosureEnd : ')';\n\n\t    let tmpEnclosureCount = 0;\n\t    let tmpEnclosureDepth = 0;\n\t    for (let i = 0; i < tmpString.length; i++)\n\t    {\n\t        // This is the start of an enclosure\n\t        if (tmpString[i] == tmpEnclosureStart)\n\t        {\n\t            if (tmpEnclosureDepth == 0)\n\t            {\n\t                tmpEnclosureCount++;\n\t            }\n\t            tmpEnclosureDepth++;\n\t        }\n\t        else if (tmpString[i] == tmpEnclosureEnd)\n\t        {\n\t            tmpEnclosureDepth--;\n\t        }\n\t    }\n\n\t    return tmpEnclosureCount;\n\t}\n\n\n\t/**\n\t * Get the value of the enclosure at the specified index.\n\t *\n\t * If the index is not a number, it will default to 0.  If the string is not a string, it will return an empty string.  If the enclosure is not found, it will return an empty string.  If the enclosure\n\t *\n\t * @param {string} pString\n\t * @param {number} pEnclosureIndexToGet\n\t * @param {string} pEnclosureStart\n\t * @param {string}} pEnclosureEnd\n\t * @returns {string}\n\t */\n\tstringGetEnclosureValueByIndex (pString, pEnclosureIndexToGet, pEnclosureStart, pEnclosureEnd)\n\t{\n\t    let tmpString = (typeof(pString) == 'string') ? pString : '';\n\t    let tmpEnclosureIndexToGet = (typeof(pEnclosureIndexToGet) == 'number') ? pEnclosureIndexToGet : 0;\n\t    let tmpEnclosureStart = (typeof(pEnclosureStart) == 'string') ? pEnclosureStart : '(';\n\t    let tmpEnclosureEnd = (typeof(pEnclosureEnd) == 'string') ? pEnclosureEnd : ')';\n\n\t    let tmpEnclosureCount = 0;\n\t    let tmpEnclosureDepth = 0;\n\n\t\tlet tmpMatchedEnclosureIndex = false;\n\t    let tmpEnclosedValueStartIndex = 0;\n\t    let tmpEnclosedValueEndIndex = 0;\n\n\t    for (let i = 0; i < tmpString.length; i++)\n\t    {\n\t        // This is the start of an enclosure\n\t        if (tmpString[i] == tmpEnclosureStart)\n\t        {\n\t            tmpEnclosureDepth++;\n\n\t\t\t\t// Only count enclosures at depth 1, but still this parses both pairs of all of them.\n\t\t\t\tif (tmpEnclosureDepth == 1)\n\t\t\t\t{\n\t\t\t\t\ttmpEnclosureCount++;\n\t\t\t\t\tif (tmpEnclosureIndexToGet == (tmpEnclosureCount - 1))\n\t\t\t\t\t{\n\t\t\t\t\t\t// This is the start of *the* enclosure\n\t\t\t\t\t\ttmpMatchedEnclosureIndex = true;\n\t\t\t\t\t\ttmpEnclosedValueStartIndex = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t        }\n\t\t\t// This is the end of an enclosure\n\t        else if (tmpString[i] == tmpEnclosureEnd)\n\t        {\n\t            tmpEnclosureDepth--;\n\n\t\t\t\t// Again, only count enclosures at depth 1, but still this parses both pairs of all of them.\n\t\t\t\tif ((tmpEnclosureDepth == 0) &&\n\t\t\t\t\ttmpMatchedEnclosureIndex &&\n\t\t\t\t\t(tmpEnclosedValueEndIndex <= tmpEnclosedValueStartIndex))\n\t\t\t\t{\n\t\t\t\t\ttmpEnclosedValueEndIndex = i;\n\t\t\t\t\ttmpMatchedEnclosureIndex = false;\n\t\t\t\t}\n\t        }\n\t    }\n\n\t    if (tmpEnclosureCount <= tmpEnclosureIndexToGet)\n\t    {\n\t\t\t// Return an empty string if the enclosure is not found\n\t        return '';\n\t    }\n\n\t    if ((tmpEnclosedValueEndIndex > 0) && (tmpEnclosedValueEndIndex > tmpEnclosedValueStartIndex))\n\t    {\n\t        return tmpString.substring(tmpEnclosedValueStartIndex+1, tmpEnclosedValueEndIndex);\n\t    }\n\t    else\n\t    {\n\t        return tmpString.substring(tmpEnclosedValueStartIndex+1);\n\t    }\n\t}\n\n\n\t/**\n\t * Remove an enclosure from a string based on the index of the enclosure.\n\t *\n\t * @param {string} pString\n\t * @param {number} pEnclosureIndexToRemove\n\t * @param {number} pEnclosureStart\n\t * @param {number} pEnclosureEnd\n\t * @returns {string}\n\t */\n\tstringRemoveEnclosureByIndex (pString, pEnclosureIndexToRemove, pEnclosureStart, pEnclosureEnd)\n\t{\n\t    let tmpString = (typeof(pString) == 'string') ? pString : '';\n\t    let tmpEnclosureIndexToRemove = (typeof(pEnclosureIndexToRemove) == 'number') ? pEnclosureIndexToRemove : 0;\n\t    let tmpEnclosureStart = (typeof(pEnclosureStart) == 'string') ? pEnclosureStart : '(';\n\t    let tmpEnclosureEnd = (typeof(pEnclosureEnd) == 'string') ? pEnclosureEnd : ')';\n\n\t    let tmpEnclosureCount = 0;\n\t    let tmpEnclosureDepth = 0;\n\n\t\tlet tmpMatchedEnclosureIndex = false;\n\t    let tmpEnclosureStartIndex = 0;\n\t    let tmpEnclosureEndIndex = 0;\n\n\t    for (let i = 0; i < tmpString.length; i++)\n\t    {\n\t        // This is the start of an enclosure\n\t        if (tmpString[i] == tmpEnclosureStart)\n\t        {\n\t            tmpEnclosureDepth++;\n\n\t            if (tmpEnclosureDepth == 1)\n\t            {\n\t                tmpEnclosureCount++;\n\t\t\t\t\tif (tmpEnclosureIndexToRemove == (tmpEnclosureCount - 1))\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpMatchedEnclosureIndex = true;\n\t\t\t\t\t\ttmpEnclosureStartIndex = i;\n\t\t\t\t\t}\n\t            }\n\t        }\n\t        else if (tmpString[i] == tmpEnclosureEnd)\n\t        {\n\t            tmpEnclosureDepth--;\n\n\t\t\t\tif ((tmpEnclosureDepth == 0) &&\n\t\t\t\t\ttmpMatchedEnclosureIndex &&\n\t\t\t\t\t(tmpEnclosureEndIndex <= tmpEnclosureStartIndex))\n\t\t\t\t{\n\t\t\t\t\ttmpEnclosureEndIndex = i;\n\t\t\t\t\ttmpMatchedEnclosureIndex = false;\n\t\t\t\t}\n\t        }\n\t    }\n\n\t    if (tmpEnclosureCount <= tmpEnclosureIndexToRemove)\n\t    {\n\t        return tmpString;\n\t    }\n\n\t    let tmpReturnString = '';\n\n\t    if (tmpEnclosureStartIndex > 1)\n\t    {\n\t        tmpReturnString = tmpString.substring(0, tmpEnclosureStartIndex);\n\t    }\n\n\t    if ((tmpString.length > (tmpEnclosureEndIndex + 1)) && (tmpEnclosureEndIndex > tmpEnclosureStartIndex))\n\t    {\n\t        tmpReturnString += tmpString.substring(tmpEnclosureEndIndex+1);\n\t    }\n\n\t    return tmpReturnString;\n\t}\n}\n\nmodule.exports = DataArithmatic;","/**\n* Base Logger Class\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\nclass BaseLogger\n{\n\tconstructor(pLogStreamSettings, pFableLog)\n\t{\n\t\t// This should not possibly be able to be instantiated without a settings object\n\t\tthis._Settings = (typeof(pLogStreamSettings) == 'object') ? pLogStreamSettings : {};\n\n\t\t// The base logger does nothing but associate a UUID with itself\n\t\t// We added this as the mechanism for tracking loggers to allow multiple simultaneous streams\n\t\t// to the same provider.\n\t\tthis.loggerUUID = this.generateInsecureUUID();\n\n\t\t// Eventually we can use this array to ompute which levels the provider allows.\n\t\t// For now it's just used to precompute some string concatenations.\n\t\tthis.levels = (\n\t\t\t[\n\t\t\t\t\"trace\",\n\t\t\t\t\"debug\",\n\t\t\t\t\"info\",\n\t\t\t\t\"warn\",\n\t\t\t\t\"error\",\n\t\t\t\t\"fatal\"\n\t\t\t]);\n\t}\n\n\t// This is meant to generate programmatically insecure UUIDs to identify loggers\n\tgenerateInsecureUUID()\n\t{\n\t\tlet tmpDate = new Date().getTime();\n\t\tlet tmpUUID = 'LOGSTREAM-xxxxxx-yxxxxx'.replace(/[xy]/g,\n\t\t\t\t(pCharacter) =>\n\t\t\t\t{\n\t\t\t\t\t// Funny algorithm from w3resource that is twister-ish without the deep math and security\n\t\t\t\t\t// ..but good enough for unique log stream identifiers\n\t\t\t\t\tlet tmpRandomData = (tmpDate + Math.random()*16)%16 | 0;\n\t\t\t\t\ttmpDate = Math.floor(tmpDate/16);\n\n\t\t\t\t\treturn (pCharacter =='x' ? tmpRandomData : (tmpRandomData&0x3|0x8)).toString(16);\n\t\t\t\t});\n\t\treturn tmpUUID;\n\t}\n\n\tinitialize()\n\t{\n\t\t// No operation.\n\t}\n\n\ttrace(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"trace\", pLogText, pLogObject);\n\t}\n\n\tdebug(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"debug\", pLogText, pLogObject);\n\t}\n\n\tinfo(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"info\", pLogText, pLogObject);\n\t}\n\n\twarn(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"warn\", pLogText, pLogObject);\n\t}\n\n\terror(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"error\", pLogText, pLogObject);\n\t}\n\n\tfatal(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"fatal\", pLogText, pLogObject);\n\t}\n\n\twrite(pLogLevel, pLogText, pLogObject)\n\t{\n\t\t// The base logger does nothing.\n\t\treturn true;\n\t}\n}\n\nmodule.exports = BaseLogger;\n","/**\n* Default Logger Provider Function\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\n// Return the providers that are available without extensions loaded\ngetDefaultProviders = () =>\n{\n\tlet tmpDefaultProviders = {};\n\n\ttmpDefaultProviders.console = require('./Fable-Log-Logger-Console.js');\n\n\ttmpDefaultProviders.default = tmpDefaultProviders.console;\n\n\treturn tmpDefaultProviders;\n}\n\nmodule.exports = getDefaultProviders();","module.exports=[\n    {\n        \"loggertype\": \"console\",\n        \"streamtype\": \"console\",\n        \"level\": \"trace\"\n    }\n]","let libBaseLogger = require('./Fable-Log-BaseLogger.js');\n\nclass ConsoleLogger extends libBaseLogger\n{\n\tconstructor(pLogStreamSettings, pFableLog)\n\t{\n\t\tsuper(pLogStreamSettings);\n\n\t\tthis._ShowTimeStamps = this._Settings.hasOwnProperty('showtimestamps') ? (this._Settings.showtimestamps == true) : true;\n\t\tthis._FormattedTimeStamps = this._Settings.hasOwnProperty('formattedtimestamps') ? (this._Settings.formattedtimestamps == true) : true;\n\n\t\tthis._ContextMessage = this._Settings.hasOwnProperty('Context') ? `(${this._Settings.Context})` : \n\t\t\t\t\t\t\t\tpFableLog._Settings.hasOwnProperty('Product') ? `(${pFableLog._Settings.Product})` :\n\t\t\t\t\t\t\t\t'Unnamed_Log_Context';\n\n\t\t// Allow the user to decide what gets output to the console\n\t\tthis._OutputLogLinesToConsole = this._Settings.hasOwnProperty('outputloglinestoconsole') ? this._Settings.outputloglinestoconsole : true;\n\t\tthis._OutputObjectsToConsole = this._Settings.hasOwnProperty('outputobjectstoconsole') ? this._Settings.outputobjectstoconsole : true;\n\n\t\t// Precompute the prefix for each level\n\t\tthis.prefixCache = {};\n\t\tfor (let i = 0; i <= this.levels.length; i++)\n\t\t{\n\t\t\tthis.prefixCache[this.levels[i]] = `[${this.levels[i]}] ${this._ContextMessage}: `;\n\n\t\t\tif (this._ShowTimeStamps)\n\t\t\t{\n\t\t\t\t// If there is a timestamp we need a to prepend space before the prefixcache string, since the timestamp comes first\n\t\t\t\tthis.prefixCache[this.levels[i]] = ' '+this.prefixCache[this.levels[i]];\n\t\t\t}\n\t\t}\n\t}\n\n\twrite(pLevel, pLogText, pObject)\n\t{\n\t\tlet tmpTimeStamp = '';\n\t\tif (this._ShowTimeStamps && this._FormattedTimeStamps)\n\t\t{\n\t\t\ttmpTimeStamp = (new Date()).toISOString();\n\t\t}\n\t\telse if (this._ShowTimeStamps)\n\t\t{\n\t\t\ttmpTimeStamp = +new Date();\n\t\t}\n\n\t\tlet tmpLogLine = `${tmpTimeStamp}${this.prefixCache[pLevel]}${pLogText}`;\n\n\t\tif (this._OutputLogLinesToConsole)\n\t\t{\n\t\t\tconsole.log(tmpLogLine);\n\t\t}\n\n\t\t// Write out the object on a separate line if it is passed in\n\t\tif (this._OutputObjectsToConsole && (typeof(pObject) !== 'undefined'))\n\t\t{\n\t\t\tconsole.log(JSON.stringify(pObject, null, 2));\n\t\t}\n\n\t\t// Provide an easy way to be overridden and be consistent\n\t\treturn tmpLogLine;\n\t}\n}\n\nmodule.exports = ConsoleLogger;","const libConsoleLog = require('./Fable-Log-Logger-Console.js');\nconst libFS = require('fs');\nconst libPath = require('path');\n\nclass SimpleFlatFileLogger extends libConsoleLog\n{\n\tconstructor(pLogStreamSettings, pFableLog)\n\t{\n\t\tsuper(pLogStreamSettings, pFableLog);\n\n\t\t// If a path isn't provided for the logfile, it tries to use the ProductName or Context\n\t\tthis.logFileRawPath = (this._Settings.hasOwnProperty('path')) ? this._Settings.path : `./${this._ContextMessage}.log`;\n\t\tthis.logFilePath = libPath.normalize(this.logFileRawPath);\n\n\t\tthis.logFileStreamOptions = (this._Settings.hasOwnProperty('fileStreamoptions')) ? this._Settings.fileStreamOptions : (\n\t\t\t{\n\t\t\t\t\"flags\": \"a\",\n\t\t\t\t\"encoding\": \"utf8\"\n\t\t\t})\n\n\t\tthis.fileWriter = libFS.createWriteStream(this.logFilePath, this.logFileStreamOptions);\n\n\t\tthis.activelyWriting = false;\n\n\t\tthis.logLineStrings = [];\n\t\tthis.logObjectStrings = [];\n\n\t\tthis.defaultWriteCompleteCallback = ()=>{};\n\t\tthis.defaultBufferFlushCallback = ()=>{};\n\t}\n\n\tcloseWriter(fCloseComplete)\n\t{\n\t\tlet tmpCloseComplete = (typeof(fCloseComplete) == 'function') ? fCloseComplete : ()=>{};\n\t\tif (this.fileWriter)\n\t\t{\n\t\t\tthis.fileWriter.end('\\n');\n\t\t\treturn this.fileWriter.once('finish', tmpCloseComplete.bind(this));\n\t\t}\n\t};\n\n\tcompleteBufferFlushToLogFile(fFlushComplete)\n\t{\n\t\tthis.activelyWriting = false;\n\t\tlet tmpFlushComplete = (typeof(fFlushComplete) == 'function') ? fFlushComplete : this.defaultBufferFlushCallback;\n\n\t\tif (this.logLineStrings.length > 0)\n\t\t{\n\t\t\tthis.flushBufferToLogFile(tmpFlushComplete);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn tmpFlushComplete();\n\t\t}\n\t}\n\n\tflushBufferToLogFile(fFlushComplete)\n\t{\n\t\tif (!this.activelyWriting)\n\t\t{\n\t\t\t// Only want to be writing one thing at a time....\n\t\t\tthis.activelyWriting = true;\n\n\t\t\tlet tmpFlushComplete = (typeof(fFlushComplete) == 'function') ? fFlushComplete : this.defaultBufferFlushCallback;\n\n\t\t\t// Get the current buffer arrays.  These should always have matching number of elements.\n\t\t\tlet tmpLineStrings = this.logLineStrings;\n\t\t\tlet tmpObjectStrings = this.logObjectStrings;\n\n\t\t\t// Reset these to be filled while we process this queue...\n\t\t\tthis.logLineStrings = [];\n\t\t\tthis.logObjectStrings = [];\n\n\t\t\t// This is where we will put each line before writing it to the file...\n\t\t\tlet tmpConstructedBufferOutputString = '';\n\n\t\t\tfor (let i = 0; i < tmpLineStrings.length; i++)\n\t\t\t{\n\t\t\t\t// TODO: Windows Newline?   ....... yo no se!\n\t\t\t\ttmpConstructedBufferOutputString += `${tmpLineStrings[i]}\\n`;\n\t\t\t\tif (tmpObjectStrings[i] !== false)\n\t\t\t\t{\n\t\t\t\t\ttmpConstructedBufferOutputString += `${tmpObjectStrings[i]}\\n`;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!this.fileWriter.write(tmpConstructedBufferOutputString, 'utf8'))\n\t\t\t{\n\t\t\t\t// If the streamwriter returns false, we need to wait for it to drain.\n\t\t\t\tthis.fileWriter.once('drain', this.completeBufferFlushToLogFile.bind(this, tmpFlushComplete));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn this.completeBufferFlushToLogFile(tmpFlushComplete);\n\t\t\t}\n\t\t}\n\t}\n\n\twrite(pLevel, pLogText, pObject)\n\t{\n\t\tlet tmpLogLine = super.write(pLevel, pLogText, pObject);\n\n\t\t// Use a very simple array as the write buffer\n\t\tthis.logLineStrings.push(tmpLogLine);\n\n\t\t// Write out the object on a separate line if it is passed in\n\t\tif (typeof(pObject) !== 'undefined')\n\t\t{\n\t\t\tthis.logObjectStrings.push(JSON.stringify(pObject, null, 4));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logObjectStrings.push(false);\n\t\t}\n\n\t\tthis.flushBufferToLogFile();\n\t}\n}\n\nmodule.exports = SimpleFlatFileLogger;","/**\n* Fable Logging Add-on\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable Logger\n*/\n\n/**\n* Fable Solution Log Wrapper Main Class\n*\n* @class FableLog\n* @constructor\n*/\nclass FableLog\n{\n\tconstructor(pFableSettings, pFable)\n\t{\n\t\tlet tmpSettings = (typeof(pFableSettings) === 'object') ? pFableSettings : {}\n\t\tthis._Settings = tmpSettings;\n\n\t\tthis._Providers = require('./Fable-Log-DefaultProviders-Node.js');\n\n\t\tthis._StreamDefinitions = (tmpSettings.hasOwnProperty('LogStreams')) ? tmpSettings.LogStreams : require('./Fable-Log-DefaultStreams.json');\n\n\t\tthis.logStreams = [];\n\n\t\t// This object gets decorated for one-time instantiated providers that\n\t\t//  have multiple outputs, such as bunyan.\n\t\tthis.logProviders = {};\n\n\t\t// A hash list of the GUIDs for each log stream, so they can't be added to the set more than one time\n\t\tthis.activeLogStreams = {};\n\n\t\tthis.logStreamsTrace = [];\n\t\tthis.logStreamsDebug = [];\n\t\tthis.logStreamsInfo = [];\n\t\tthis.logStreamsWarn = [];\n\t\tthis.logStreamsError = [];\n\t\tthis.logStreamsFatal = [];\n\n\t\tthis.datumDecorator = (pDatum) => pDatum;\n\n\t\tthis.uuid = (typeof(tmpSettings.Product) === 'string') ? tmpSettings.Product : 'Default';\n\t}\n\n\taddLogger(pLogger, pLevel)\n\t{\n\t\t// Bail out if we've already created one.\n\t\tif (this.activeLogStreams.hasOwnProperty(pLogger.loggerUUID))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// Add it to the streams and to the mutex\n\t\tthis.logStreams.push(pLogger);\n\t\tthis.activeLogStreams[pLogger.loggerUUID] = true;\n\n\t\t// Make sure a kosher level was passed in\n\t\tswitch (pLevel)\n\t\t{\n\t\t\tcase 'trace':\n\t\t\t\tthis.logStreamsTrace.push(pLogger);\n\t\t\tcase 'debug':\n\t\t\t\tthis.logStreamsDebug.push(pLogger);\n\t\t\tcase 'info':\n\t\t\t\tthis.logStreamsInfo.push(pLogger);\n\t\t\tcase 'warn':\n\t\t\t\tthis.logStreamsWarn.push(pLogger);\n\t\t\tcase 'error':\n\t\t\t\tthis.logStreamsError.push(pLogger);\n\t\t\tcase 'fatal':\n\t\t\t\tthis.logStreamsFatal.push(pLogger);\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tsetDatumDecorator(fDatumDecorator)\n\t{\n\t\tif (typeof(fDatumDecorator) === 'function')\n\t\t{\n\t\t\tthis.datumDecorator = fDatumDecorator;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.datumDecorator = (pDatum) => pDatum;\n\t\t}\n\t}\n\n\ttrace(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsTrace.length; i++)\n\t\t{\n\t\t\tthis.logStreamsTrace[i].trace(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tdebug(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsDebug.length; i++)\n\t\t{\n\t\t\tthis.logStreamsDebug[i].debug(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tinfo(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsInfo.length; i++)\n\t\t{\n\t\t\tthis.logStreamsInfo[i].info(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\twarn(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsWarn.length; i++)\n\t\t{\n\t\t\tthis.logStreamsWarn[i].warn(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\terror(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsError.length; i++)\n\t\t{\n\t\t\tthis.logStreamsError[i].error(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tfatal(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsFatal.length; i++)\n\t\t{\n\t\t\tthis.logStreamsFatal[i].fatal(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tinitialize()\n\t{\n\t\t// \"initialize\" each logger as defined in the logging parameters\n\t\tfor (let i = 0; i < this._StreamDefinitions.length; i++)\n\t\t{\n\t\t\tlet tmpStreamDefinition = Object.assign({loggertype:'default',streamtype:'console',level:'info'},this._StreamDefinitions[i]);\n\n\t\t\tif (!this._Providers.hasOwnProperty(tmpStreamDefinition.loggertype))\n\t\t\t{\n\t\t\t\tconsole.log(`Error initializing log stream: bad loggertype in stream definition ${JSON.stringify(tmpStreamDefinition)}`);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.addLogger(new this._Providers[tmpStreamDefinition.loggertype](tmpStreamDefinition, this), tmpStreamDefinition.level);\n\t\t\t}\n\t\t}\n\n\t\t// Now initialize each one.\n\t\tfor (let i = 0; i < this.logStreams.length; i++)\n\t\t{\n\t\t\tthis.logStreams[i].initialize();\n\t\t}\n\t}\n\n\tlogTime(pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time';\n\t\tlet tmpTime = new Date();\n\t\tthis.info(`${tmpMessage} ${tmpTime} (epoch ${+tmpTime})`, pDatum);\n\t}\n\n\t// Get a timestamp\n\tgetTimeStamp()\n\t{\n\t\treturn +new Date();\n\t}\n\n\tgetTimeDelta(pTimeStamp)\n\t{\n\t\tlet tmpEndTime = +new Date();\n\t\treturn tmpEndTime-pTimeStamp;\n\t}\n\n\t// Log the delta between a timestamp, and now with a message\n\tlogTimeDelta(pTimeDelta, pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time Measurement';\n\t\tlet tmpDatum = (typeof(pDatum) === 'object') ? pDatum : {};\n\n\t\tlet tmpEndTime = +new Date();\n\n\t\tthis.info(`${tmpMessage} logged at (epoch ${+tmpEndTime}) took (${pTimeDelta}ms)`, pDatum);\n\t}\n\n\tlogTimeDeltaHuman(pTimeDelta, pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time Measurement';\n\n\t\tlet tmpEndTime = +new Date();\n\n\t\tlet tmpMs = parseInt(pTimeDelta%1000);\n\t\tlet tmpSeconds = parseInt((pTimeDelta/1000)%60);\n\t\tlet tmpMinutes = parseInt((pTimeDelta/(1000*60))%60);\n\t\tlet tmpHours = parseInt(pTimeDelta/(1000*60*60));\n\n\t\ttmpMs = (tmpMs < 10) ? \"00\"+tmpMs : (tmpMs < 100) ? \"0\"+tmpMs : tmpMs;\n\t\ttmpSeconds = (tmpSeconds < 10) ? \"0\"+tmpSeconds : tmpSeconds;\n\t\ttmpMinutes = (tmpMinutes < 10) ? \"0\"+tmpMinutes : tmpMinutes;\n\t\ttmpHours = (tmpHours < 10) ? \"0\"+tmpHours : tmpHours;\n\n\t\tthis.info(`${tmpMessage} logged at (epoch ${+tmpEndTime}) took (${pTimeDelta}ms) or (${tmpHours}:${tmpMinutes}:${tmpSeconds}.${tmpMs})`, pDatum);\n\t}\n\n\tlogTimeDeltaRelative(pStartTime, pMessage, pDatum)\n\t{\n\t\tthis.logTimeDelta(this.getTimeDelta(pStartTime), pMessage, pDatum);\n\t}\n\n\tlogTimeDeltaRelativeHuman(pStartTime, pMessage, pDatum)\n\t{\n\t\tthis.logTimeDeltaHuman(this.getTimeDelta(pStartTime), pMessage, pDatum);\n\t}\n}\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new FableLog(pSettings);\n}\n\n\nmodule.exports = FableLog;\nmodule.exports.new = autoConstruct;\nmodule.exports.LogProviderBase = require('./Fable-Log-BaseLogger.js');\nmodule.exports.LogProviderConsole = require('./Fable-Log-Logger-Console.js');\nmodule.exports.LogProviderConsole = require('./Fable-Log-Logger-SimpleFlatFile.js');\n","module.exports={\n\t\"Product\": \"ApplicationNameHere\",\n\t\"ProductVersion\": \"0.0.0\",\n\n\t\"ConfigFile\": false,\n\n\t\"LogStreams\":\n\t[\n\t\t{\n\t\t\t\"level\": \"trace\"\n\t\t}\n\t]\n}\n","/**\n* Fable Settings Template Processor\n*\n* This class allows environment variables to come in via templated expressions, and defaults to be set.\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable Settings\n*/\n\nclass FableSettingsTemplateProcessor\n{\n\tconstructor(pDependencies)\n\t{\n        // Use a no-dependencies templating engine to parse out environment variables\n\t\tthis.templateProcessor = new pDependencies.precedent();\n\n        // TODO: Make the environment variable wrap expression demarcation characters configurable?\n\t\tthis.templateProcessor.addPattern('${', '}',\n\t\t\t(pTemplateValue)=>\n\t\t\t{\n\t\t\t\tlet tmpTemplateValue = pTemplateValue.trim();\n\n\t\t\t\tlet tmpSeparatorIndex = tmpTemplateValue.indexOf('|');\n\n\t\t\t\t// If there is no pipe, the default value will end up being whatever the variable name is.\n\t\t\t\tlet tmpDefaultValue = tmpTemplateValue.substring(tmpSeparatorIndex+1);\n\n\t\t\t\tlet tmpEnvironmentVariableName = (tmpSeparatorIndex > -1) ? tmpTemplateValue.substring(0, tmpSeparatorIndex) : tmpTemplateValue;\n\n\t\t\t\tif (process.env.hasOwnProperty(tmpEnvironmentVariableName))\n\t\t\t\t{\n\t\t\t\t\treturn process.env[tmpEnvironmentVariableName];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn tmpDefaultValue;\n\t\t\t\t}\n\t\t\t});\n    }\n\n    parseSetting(pString)\n    {\n        return this.templateProcessor.parseString(pString);\n    }\n}\n\nmodule.exports = FableSettingsTemplateProcessor;","/**\n* Fable Settings Add-on\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable Settings\n*/\n\nconst libPrecedent = require('precedent');\nconst libFableSettingsTemplateProcessor = require('./Fable-Settings-TemplateProcessor.js');\n\nclass FableSettings\n{\n\tconstructor(pFableSettings)\n\t{\n\t\t// Expose the dependencies for downstream re-use\n\t\tthis.dependencies = (\n\t\t\t{\n\t\t\t\tprecedent: libPrecedent\n\t\t\t});\n\n\t\t// Initialize the settings value template processor\n\t\tthis.settingsTemplateProcessor = new libFableSettingsTemplateProcessor(this.dependencies);\n\n\t\t// set straight away so anything that uses it respects the initial setting\n\t\tthis._configureEnvTemplating(pFableSettings);\n\n\t\tthis.default = this.buildDefaultSettings();\n\n\t\t// Construct a new settings object\n\t\tlet tmpSettings = this.merge(pFableSettings, this.buildDefaultSettings());\n\n\t\t// The base settings object (what they were on initialization, before other actors have altered them)\n\t\tthis.base = JSON.parse(JSON.stringify(tmpSettings));\n\n\t\tif (tmpSettings.DefaultConfigFile)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// If there is a DEFAULT configuration file, try to load and merge it.\n\t\t\t\ttmpSettings = this.merge(require(tmpSettings.DefaultConfigFile), tmpSettings);\n\t\t\t}\n\t\t\tcatch (pException)\n\t\t\t{\n\t\t\t\t// Why this?  Often for an app we want settings to work out of the box, but\n\t\t\t\t// would potentially want to have a config file for complex settings.\n\t\t\t\tconsole.log('Fable-Settings Warning: Default configuration file specified but there was a problem loading it.  Falling back to base.');\n\t\t\t\tconsole.log('     Loading Exception: '+pException);\n\t\t\t}\n\t\t}\n\n\t\tif (tmpSettings.ConfigFile)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// If there is a configuration file, try to load and merge it.\n\t\t\t\ttmpSettings = this.merge(require(tmpSettings.ConfigFile), tmpSettings);\n\t\t\t}\n\t\t\tcatch (pException)\n\t\t\t{\n\t\t\t\t// Why this?  Often for an app we want settings to work out of the box, but\n\t\t\t\t// would potentially want to have a config file for complex settings.\n\t\t\t\tconsole.log('Fable-Settings Warning: Configuration file specified but there was a problem loading it.  Falling back to base.');\n\t\t\t\tconsole.log('     Loading Exception: '+pException);\n\t\t\t}\n\t\t}\n\n\t\tthis.settings = tmpSettings;\n\t}\n\n\t// Build a default settings object.  Use the JSON jimmy to ensure it is always a new object.\n\tbuildDefaultSettings()\n\t{\n\t\treturn JSON.parse(JSON.stringify(require('./Fable-Settings-Default')));\n\t}\n\n\t// Update the configuration for environment variable templating based on the current settings object\n\t_configureEnvTemplating(pSettings)\n\t{\n\t\t// default environment variable templating to on\n\t\tthis._PerformEnvTemplating = !pSettings || pSettings.NoEnvReplacement !== true;\n\t}\n\n\t// Resolve (recursive) any environment variables found in settings object.\n\t_resolveEnv(pSettings)\n\t{\n\t\tfor (const tmpKey in pSettings)\n\t\t{\n\t\t\tif (typeof(pSettings[tmpKey]) === 'object')\n\t\t\t{\n\t\t\t\tthis._resolveEnv(pSettings[tmpKey]);\n\t\t\t}\n\t\t\telse if (typeof(pSettings[tmpKey]) === 'string')\n\t\t\t{\n\t\t\t\tpSettings[tmpKey] = this.settingsTemplateProcessor.parseSetting(pSettings[tmpKey]);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Check to see if a value is an object (but not an array).\n\t */\n\t_isObject(value)\n\t{\n\t\treturn typeof(value) === 'object' && !Array.isArray(value);\n\t}\n\n\t/**\n\t * Merge two plain objects. Keys that are objects in both will be merged property-wise.\n\t */\n\t_deepMergeObjects(toObject, fromObject)\n\t{\n\t\tif (!fromObject || !this._isObject(fromObject))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tObject.keys(fromObject).forEach((key) =>\n\t\t{\n\t\t\tconst fromValue = fromObject[key];\n\t\t\tif (this._isObject(fromValue))\n\t\t\t{\n\t\t\t\tconst toValue = toObject[key];\n\t\t\t\tif (toValue && this._isObject(toValue))\n\t\t\t\t{\n\t\t\t\t\t// both are objects, so do a recursive merge\n\t\t\t\t\tthis._deepMergeObjects(toValue, fromValue);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttoObject[key] = fromValue;\n\t\t});\n\t\treturn toObject;\n\t}\n\n\t// Merge some new object into the existing settings.\n\tmerge(pSettingsFrom, pSettingsTo)\n\t{\n\t\t// If an invalid settings from object is passed in (e.g. object constructor without passing in anything) this should still work\n\t\tlet tmpSettingsFrom = (typeof(pSettingsFrom) === 'object') ? pSettingsFrom : {};\n\t\t// Default to the settings object if none is passed in for the merge.\n\t\tlet tmpSettingsTo = (typeof(pSettingsTo) === 'object') ? pSettingsTo : this.settings;\n\n\t\t// do not mutate the From object property values\n\t\tlet tmpSettingsFromCopy = JSON.parse(JSON.stringify(tmpSettingsFrom));\n\t\ttmpSettingsTo = this._deepMergeObjects(tmpSettingsTo, tmpSettingsFromCopy);\n\n\t\tif (this._PerformEnvTemplating)\n\t\t{\n\t\t\tthis._resolveEnv(tmpSettingsTo);\n\t\t}\n\t\t// Update env tempating config, since we just updated the config object, and it may have changed\n\t\tthis._configureEnvTemplating(tmpSettingsTo);\n\n\t\treturn tmpSettingsTo;\n\t}\n\n\t// Fill in settings gaps without overwriting settings that are already there\n\tfill(pSettingsFrom)\n\t{\n\t\t// If an invalid settings from object is passed in (e.g. object constructor without passing in anything) this should still work\n\t\tlet tmpSettingsFrom = (typeof(pSettingsFrom) === 'object') ? pSettingsFrom : {};\n\n\t\t// do not mutate the From object property values\n\t\tlet tmpSettingsFromCopy = JSON.parse(JSON.stringify(tmpSettingsFrom));\n\n\t\tthis.settings = this._deepMergeObjects(tmpSettingsFromCopy, this.settings);\n\n\t\treturn this.settings;\n\t}\n};\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new FableSettings(pSettings);\n}\n\nmodule.exports = FableSettings;\nmodule.exports.new = autoConstruct;\nmodule.exports.precedent = libPrecedent;","/**\n* Random Byte Generator - Browser version\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\n// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\nclass RandomBytes\n{\n\tconstructor()\n\t{\n\n\t\t// getRandomValues needs to be invoked in a context where \"this\" is a Crypto\n\t\t// implementation. Also, find the complete implementation of crypto on IE11.\n\t\tthis.getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||\n                      \t\t(typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));\n\t}\n\n\t// WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n\tgenerateWhatWGBytes()\n\t{\n\t\tlet tmpBuffer = new Uint8Array(16); // eslint-disable-line no-undef\n\n\t\tthis.getRandomValues(tmpBuffer);\n\t\treturn tmpBuffer;\n\t}\n\n\t// Math.random()-based (RNG)\n\tgenerateRandomBytes()\n\t{\n\t\t// If all else fails, use Math.random().  It's fast, but is of unspecified\n\t\t// quality.\n\t\tlet tmpBuffer = new Uint8Array(16); // eslint-disable-line no-undef\n\n\t\tfor (let i = 0, tmpValue; i < 16; i++)\n\t\t{\n\t\t\tif ((i & 0x03) === 0)\n\t\t\t{\n\t\t\t\ttmpValue = Math.random() * 0x100000000;\n\t\t\t}\n\n\t\t\ttmpBuffer[i] = tmpValue >>> ((i & 0x03) << 3) & 0xff;\n\t\t}\n\n\t\treturn tmpBuffer;\n\t}\n\n\tgenerate()\n\t{\n\t\tif (this.getRandomValues)\n\t\t{\n\t\t\treturn this.generateWhatWGBytes();\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.generateRandomBytes();\n\t\t}\n\t}\n}\n\nmodule.exports = RandomBytes;\n","/**\n* Fable UUID Generator\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable UUID\n*/\n\n/**\n* Fable Solution UUID Generation Main Class\n*\n* @class FableUUID\n* @constructor\n*/\n\nvar libRandomByteGenerator = require('./Fable-UUID-Random.js')\n\nclass FableUUID\n{\n\tconstructor(pSettings)\n\t{\n\t\t// Determine if the module is in \"Random UUID Mode\" which means just use the random character function rather than the v4 random UUID spec.\n\t\t// Note this allows UUIDs of various lengths (including very short ones) although guaranteed uniqueness goes downhill fast.\n\t\tthis._UUIDModeRandom = (typeof(pSettings) === 'object') && (pSettings.hasOwnProperty('UUIDModeRandom')) ? (pSettings.UUIDModeRandom == true) : false;\n\t\t// These two properties are only useful if we are in Random mode.  Otherwise it generates a v4 spec\n\t\t// Length for \"Random UUID Mode\" is set -- if not set it to 8\n\t\tthis._UUIDLength = (typeof(pSettings) === 'object') && (pSettings.hasOwnProperty('UUIDLength')) ? (pSettings.UUIDLength + 0) : 8;\n\t\t// Dictionary for \"Random UUID Mode\"\n\t\tthis._UUIDRandomDictionary = (typeof(pSettings) === 'object') && (pSettings.hasOwnProperty('UUIDDictionary')) ? (pSettings.UUIDDictionary + 0) : '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n\n\t\tthis.randomByteGenerator = new libRandomByteGenerator();\n\n\t\t// Lookup table for hex codes\n\t\tthis._HexLookup = [];\n\t\tfor (let i = 0; i < 256; ++i)\n\t\t{\n\t\t\tthis._HexLookup[i] = (i + 0x100).toString(16).substr(1);\n\t\t}\n\t}\n\n\t// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n\tbytesToUUID(pBuffer)\n\t{\n\t\tlet i = 0;\n\t\t// join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n\t\treturn ([\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], \n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]]\n\t\t\t\t]).join('');\n\t}\n\n\t// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n\tgenerateUUIDv4()\n\t{\n\t\tlet tmpBuffer = new Array(16);\n\t\tvar tmpRandomBytes = this.randomByteGenerator.generate();\n\n\t\t// Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\t\ttmpRandomBytes[6] = (tmpRandomBytes[6] & 0x0f) | 0x40;\n\t\ttmpRandomBytes[8] = (tmpRandomBytes[8] & 0x3f) | 0x80;\n\n\t\treturn this.bytesToUUID(tmpRandomBytes);\n\t}\n\n\t// Simple random UUID generation\n\tgenerateRandom()\n\t{\n\t\tlet tmpUUID = '';\n\n\t\tfor (let i = 0; i < this._UUIDLength; i++)\n\t\t{\n\t\t\ttmpUUID += this._UUIDRandomDictionary.charAt(Math.floor(Math.random() * (this._UUIDRandomDictionary.length-1)));\n\t\t}\n\n\t\treturn tmpUUID;\n\t}\n\n\t// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n\tgetUUID()\n\t{\n\t\tif (this._UUIDModeRandom)\n\t\t{\n\t\t\treturn this.generateRandom();\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.generateUUIDv4();\n\t\t}\n\t}\n}\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new FableUUID(pSettings);\n}\n\n\nmodule.exports = FableUUID;\nmodule.exports.new = autoConstruct;\n","// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n","/**\n* Precedent Meta-Templating\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Process text streams, parsing out meta-template expressions.\n*/\nvar libWordTree = require(`./WordTree.js`);\nvar libStringParser = require(`./StringParser.js`);\n\nclass Precedent\n{\n\t/**\n\t * Precedent Constructor\n\t */\n\tconstructor()\n\t{\n\t\tthis.WordTree = new libWordTree();\n\t\t\n\t\tthis.StringParser = new libStringParser();\n\n\t\tthis.ParseTree = this.WordTree.ParseTree;\n\t}\n\t\n\t/**\n\t * Add a Pattern to the Parse Tree\n\t * @method addPattern\n\t * @param {Object} pTree - A node on the parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @param {number} pIndex - callback function\n\t * @return {bool} True if adding the pattern was successful\n\t */\n\taddPattern(pPatternStart, pPatternEnd, pParser)\n\t{\n\t\treturn this.WordTree.addPattern(pPatternStart, pPatternEnd, pParser);\n\t}\n\t\n\t/**\n\t * Parse a string with the existing parse tree\n\t * @method parseString\n\t * @param {string} pString - The string to parse\n\t * @return {string} The result from the parser\n\t */\n\tparseString(pString)\n\t{\n\t\treturn this.StringParser.parseString(pString, this.ParseTree);\n\t}\n}\n\nmodule.exports = Precedent;\n","/**\n* String Parser\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Parse a string, properly processing each matched token in the word tree.\n*/\n\nclass StringParser\n{\n\t/**\n\t * StringParser Constructor\n\t */\n\tconstructor()\n\t{\n\t}\n\t\n\t/**\n\t * Create a fresh parsing state object to work with.\n\t * @method newParserState\n\t * @param {Object} pParseTree - A node on the parse tree to begin parsing from (usually root)\n\t * @return {Object} A new parser state object for running a character parser on\n\t * @private\n\t */\n\tnewParserState (pParseTree)\n\t{\n\t\treturn (\n\t\t{\n\t\t\tParseTree: pParseTree,\n\n\t\t\tOutput: '',\n\t\t\tOutputBuffer: '',\n\n\t\t\tPattern: false,\n\n\t\t\tPatternMatch: false,\n\t\t\tPatternMatchOutputBuffer: ''\n\t\t});\n\t}\n\t\t\n\t/**\n\t * Assign a node of the parser tree to be the next potential match.\n\t * If the node has a PatternEnd property, it is a valid match and supercedes the last valid match (or becomes the initial match).\n\t * @method assignNode\n\t * @param {Object} pNode - A node on the parse tree to assign\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tassignNode (pNode, pParserState)\n\t{\n\t\tpParserState.PatternMatch = pNode;\n\n\t\t// If the pattern has a END we can assume it has a parse function...\n\t\tif (pParserState.PatternMatch.hasOwnProperty('PatternEnd'))\n\t\t{\n\t\t\t// ... this is the legitimate start of a pattern.\n\t\t\tpParserState.Pattern = pParserState.PatternMatch;\n\t\t}\n\t}\n\t\n\t/**\n\t * Append a character to the output buffer in the parser state.\n\t * This output buffer is used when a potential match is being explored, or a match is being explored.\n\t * @method appendOutputBuffer\n\t * @param {string} pCharacter - The character to append\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tappendOutputBuffer (pCharacter, pParserState)\n\t{\n\t\tpParserState.OutputBuffer += pCharacter;\n\t}\n\t\n\t/**\n\t * Flush the output buffer to the output and clear it.\n\t * @method flushOutputBuffer\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tflushOutputBuffer (pParserState)\n\t{\n\t\tpParserState.Output += pParserState.OutputBuffer;\n\t\tpParserState.OutputBuffer = '';\n\t}\n\n\t\n\t/**\n\t * Check if the pattern has ended.  If it has, properly flush the buffer and start looking for new patterns.\n\t * @method checkPatternEnd\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tcheckPatternEnd (pParserState)\n\t{\n\t\tif ((pParserState.OutputBuffer.length >= pParserState.Pattern.PatternEnd.length+pParserState.Pattern.PatternStart.length) && \n\t\t\t(pParserState.OutputBuffer.substr(-pParserState.Pattern.PatternEnd.length) === pParserState.Pattern.PatternEnd))\n\t\t{\n\t\t\t// ... this is the end of a pattern, cut off the end tag and parse it.\n\t\t\t// Trim the start and end tags off the output buffer now\n\t\t\tpParserState.OutputBuffer = pParserState.Pattern.Parse(pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStart.length, pParserState.OutputBuffer.length - (pParserState.Pattern.PatternStart.length+pParserState.Pattern.PatternEnd.length)));\n\t\t\t// Flush the output buffer.\n\t\t\tthis.flushOutputBuffer(pParserState);\n\t\t\t// End pattern mode\n\t\t\tpParserState.Pattern = false;\n\t\t\tpParserState.PatternMatch = false;\n\t\t}\n\t}\n\t\n\t/**\n\t * Parse a character in the buffer.\n\t * @method parseCharacter\n\t * @param {string} pCharacter - The character to append\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tparseCharacter (pCharacter, pParserState)\n\t{\n\t\t// (1) If we aren't in a pattern match, and we aren't potentially matching, and this may be the start of a new pattern....\n\t\tif (!pParserState.PatternMatch && pParserState.ParseTree.hasOwnProperty(pCharacter))\n\t\t{\n\t\t\t// ... assign the node as the matched node.\n\t\t\tthis.assignNode(pParserState.ParseTree[pCharacter], pParserState);\n\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t}\n\t\t// (2) If we are in a pattern match (actively seeing if this is part of a new pattern token)\n\t\telse if (pParserState.PatternMatch)\n\t\t{\n\t\t\t// If the pattern has a subpattern with this key\n\t\t\tif (pParserState.PatternMatch.hasOwnProperty(pCharacter))\n\t\t\t{\n\t\t\t\t// Continue matching patterns.\n\t\t\t\tthis.assignNode(pParserState.PatternMatch[pCharacter], pParserState);\n\t\t\t}\n\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\tif (pParserState.Pattern)\n\t\t\t{\n\t\t\t\t// ... Check if this is the end of the pattern (if we are matching a valid pattern)...\n\t\t\t\tthis.checkPatternEnd(pParserState);\n\t\t\t}\n\t\t}\n\t\t// (3) If we aren't in a pattern match or pattern, and this isn't the start of a new pattern (RAW mode)....\n\t\telse\n\t\t{\n\t\t\tpParserState.Output += pCharacter;\n\t\t}\n\t}\n\t\n\t/**\n\t * Parse a string for matches, and process any template segments that occur.\n\t * @method parseString\n\t * @param {string} pString - The string to parse.\n\t * @param {Object} pParseTree - The parse tree to begin parsing from (usually root)\n\t */\n\tparseString (pString, pParseTree)\n\t{\n\t\tlet tmpParserState = this.newParserState(pParseTree);\n\n\t\tfor (var i = 0; i < pString.length; i++)\n\t\t{\n\t\t\t// TODO: This is not fast.\n\t\t\tthis.parseCharacter(pString[i], tmpParserState);\n\t\t}\n\t\t\n\t\tthis.flushOutputBuffer(tmpParserState);\n\t\t\n\t\treturn tmpParserState.Output;\n\t}\n}\n\nmodule.exports = StringParser;\n","/**\n* Word Tree\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Create a tree (directed graph) of Javascript objects, one character per object.\n*/\n\nclass WordTree\n{\n\t/**\n\t * WordTree Constructor\n\t */\n\tconstructor()\n\t{\n\t\tthis.ParseTree = {};\n\t}\n\t\n\t/** \n\t * Add a child character to a Parse Tree node\n\t * @method addChild\n\t * @param {Object} pTree - A parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @param {number} pIndex - The index of the character in the pattern\n\t * @returns {Object} The resulting leaf node that was added (or found)\n\t * @private\n\t */\n\taddChild (pTree, pPattern, pIndex)\n\t{\n\t\tif (!pTree.hasOwnProperty(pPattern[pIndex]))\n\t\t\tpTree[pPattern[pIndex]] = {};\n\t\t\n\t\treturn pTree[pPattern[pIndex]];\n\t}\n\t\n\t/** Add a Pattern to the Parse Tree\n\t * @method addPattern\n\t * @param {Object} pPatternStart - The starting string for the pattern (e.g. \"${\")\n\t * @param {string} pPatternEnd - The ending string for the pattern (e.g. \"}\")\n\t * @param {number} pParser - The function to parse if this is the matched pattern, once the Pattern End is met.  If this is a string, a simple replacement occurs.\n\t * @return {bool} True if adding the pattern was successful\n\t */\n\taddPattern (pPatternStart, pPatternEnd, pParser)\n\t{\n\t\tif (pPatternStart.length < 1)\n\t\t\treturn false;\n\n\t\tif ((typeof(pPatternEnd) === 'string') && (pPatternEnd.length < 1))\n\t\t\treturn false;\n\n\t\tlet tmpLeaf = this.ParseTree;\n\n\t\t// Add the tree of leaves iteratively\n\t\tfor (var i = 0; i < pPatternStart.length; i++)\n\t\t\ttmpLeaf = this.addChild(tmpLeaf, pPatternStart, i);\n\n\t\ttmpLeaf.PatternStart = pPatternStart;\n\t\ttmpLeaf.PatternEnd = ((typeof(pPatternEnd) === 'string') && (pPatternEnd.length > 0)) ? pPatternEnd : pPatternStart;\n\t\ttmpLeaf.Parse = (typeof(pParser) === 'function') ? pParser : \n\t\t\t\t\t\t(typeof(pParser) === 'string') ? () => { return pParser; } :\n\t\t\t\t\t\t(pData) => { return pData; };\n\n\t\treturn true;\n\t}\n}\n\nmodule.exports = WordTree;\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","var nextTick = require('process/browser.js').nextTick;\nvar apply = Function.prototype.apply;\nvar slice = Array.prototype.slice;\nvar immediateIds = {};\nvar nextImmediateId = 0;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) { timeout.close(); };\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// That's not how node.js implements it but the exposed api is the same.\nexports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n  var id = nextImmediateId++;\n  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n  immediateIds[id] = true;\n\n  nextTick(function onNextTick() {\n    if (immediateIds[id]) {\n      // fn.call() is faster so we optimize for the common use-case\n      // @see http://jsperf.com/call-apply-segu\n      if (args) {\n        fn.apply(null, args);\n      } else {\n        fn.call(null);\n      }\n      // Prevent ids from leaking\n      exports.clearImmediate(id);\n    }\n  });\n\n  return id;\n};\n\nexports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n  delete immediateIds[id];\n};","var libNPMModuleWrapper = require('./Fable.js');\n\nif ((typeof(window) === 'object') && !window.hasOwnProperty('Fable'))\n{\n\twindow.Fable = libNPMModuleWrapper;\n}\n\nmodule.exports = libNPMModuleWrapper;","const _OperationStatePrototype = JSON.stringify(\n{\n\t\"Metadata\": {\n\t\t\"GUID\": false,\n\t\t\"Hash\": false,\n\n\t\t\"Title\": \"\",\n\t\t\"Summary\": \"\",\n\n\t\t\"Version\": 0\n\t},\n\t\"Status\": {\n        \"Completed\": false,\n\n        \"CompletionProgress\": 0,\n        \"CompletionTimeElapsed\": 0,\n\n        \"Steps\": 1,\n        \"StepsCompleted\": 0,\n\n        \"StartTime\": 0,\n        \"EndTime\": 0\n\t},\n\t\"Errors\": [],\n\t\"Log\": []\n});\n\nclass FableOperation\n{\n\tconstructor(pFable, pOperationName, pOperationHash)\n\t{\n\t\tthis.fable = pFable;\n\n\t\tthis.name = pOperationName;\n\n\t\tthis.state = JSON.parse(_OperationStatePrototype);\n\n\t\tthis.state.Metadata.GUID = this.fable.getUUID();\n\t\tthis.state.Metadata.Hash = this.state.GUID;\n\n\t\tif (typeof(pOperationHash) == 'string')\n\t\t{\n\t\t\tthis.state.Metadata.Hash = pOperationHash;\n\t\t}\n\t}\n\n\tget GUID()\n\t{\n\t\treturn this.state.Metadata.GUID;\n\t}\n\n\tget Hash()\n\t{\n\t\treturn this.state.Metadata.Hash;\n\t}\n\n\tget log()\n\t{\n\t\treturn this;\n\t}\n\n\twriteOperationLog(pLogLevel, pLogText, pLogObject)\n\t{\n\t\tthis.state.Log.push(`${new Date().toUTCString()} [${pLogLevel}]: ${pLogText}`);\n\n\t\tif (typeof(pLogObject) == 'object')\n\t\t{\n\t\t\tthis.state.Log.push(JSON.stringify(pLogObject));\n\t\t}\n\t}\n\n\twriteOperationErrors(pLogText, pLogObject)\n\t{\n\t\tthis.state.Errors.push(`${pLogText}`);\n\n\t\tif (typeof(pLogObject) == 'object')\n\t\t{\n\t\t\tthis.state.Errors.push(JSON.stringify(pLogObject));\n\t\t}\n\t}\n\n\ttrace(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('TRACE', pLogText, pLogObject);\n\t\tthis.fable.log.trace(pLogText, pLogObject);\n\t}\n\n\tdebug(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('DEBUG', pLogText, pLogObject);\n\t\tthis.fable.log.debug(pLogText, pLogObject);\n\t}\n\n\tinfo(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('INFO', pLogText, pLogObject);\n\t\tthis.fable.log.info(pLogText, pLogObject);\n\t}\n\n\twarn(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('WARN', pLogText, pLogObject);\n\t\tthis.fable.log.warn(pLogText, pLogObject);\n\t}\n\n\terror(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('ERROR', pLogText, pLogObject);\n\t\tthis.writeOperationErrors(pLogText, pLogObject);\n\t\tthis.fable.log.error(pLogText, pLogObject);\n\t}\n\n\tfatal(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('FATAL', pLogText, pLogObject);\n\t\tthis.writeOperationErrors(pLogText, pLogObject);\n\t\tthis.fable.log.fatal(pLogText, pLogObject);\n\t}\n}\n\nmodule.exports = FableOperation;","const libFableServiceBase = require('./Fable-ServiceProviderBase.js');\nconst libDataArithmatic = require('data-arithmatic');\n\nclass FableServiceDataArithmatic extends libFableServiceBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n        super(pFable, pOptions, pServiceHash);\n\n        this.serviceType = 'DataArithmatic';\n\n        this._DataArithmaticLibrary = new libDataArithmatic();\n\t}\n}\n\nmodule.exports = FableServiceDataArithmatic;","const libFableServiceBase = require('./Fable-ServiceProviderBase.js');\n\nclass FableServiceTemplate extends libFableServiceBase\n{\n\t// Underscore and lodash have a behavior, _.template, which compiles a\n\t// string-based template with code snippets into simple executable pieces,\n\t// with the added twist of returning a precompiled function ready to go.\n\t//\n\t// NOTE: This does not implement underscore escape expressions\n\t// NOTE: This does not implement underscore magic browser variable assignment\n\t//\n\t// This is an implementation of that.\n\t// TODO: Make this use precedent, add configuration, add debugging.\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n        super(pFable, pOptions, pServiceHash);\n\n        this.serviceType = 'Template';\n\n\t\t// These are the exact regex's used in lodash/underscore\n\t\t// TODO: Switch this to precedent\n\t\tthis.Matchers = (\n\t\t\t{\n\t\t\t\tEvaluate: /<%([\\s\\S]+?)%>/g,\n\t\t\t\tInterpolate: /<%=([\\s\\S]+?)%>/g,\n\t\t\t\tEscaper: /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g,\n\t\t\t\tUnescaper: /\\\\(\\\\|'|r|n|t|u2028|u2029)/g,\n\t\t\t\t// This is how underscore does it, so we are keeping it for now.\n\t\t\t\tGuaranteedNonMatch: /.^/\n\t\t\t});\n\n\t\t// This is a helper for the escaper and unescaper functions.\n\t\t// Right now we are going to keep what underscore is doing, but, not forever.\n\t\tthis.templateEscapes = {\n\t\t\t'\\\\': '\\\\',\n\t\t\t\"'\": \"'\",\n\t\t\t'r': '\\r',\n\t\t\t'\\r': 'r',\n\t\t\t'n': '\\n',\n\t\t\t'\\n': 'n',\n\t\t\t't': '\\t',\n\t\t\t'\\t': 't',\n\t\t\t'u2028': '\\u2028',\n\t\t\t'\\u2028': 'u2028',\n\t\t\t'u2029': '\\u2029',\n\t\t\t'\\u2029': 'u2029'\n\t\t};\n\n\t\t// This is defined as such to underscore that it is a dynamic programming\n\t\t// function on this class.\n\t\tthis.renderFunction = false;\n        this.templateString = false;\n\t}\n\n\trenderTemplate(pData)\n\t{\n\t\treturn this.renderFunction(pData);\n\t}\n\n\ttemplateFunction(pData)\n\t{\n\t\tlet fRenderTemplateBound = this.renderTemplate.bind(this);\n\t\treturn fRenderTemplateBound;\n\t}\n\n\tbuildTemplateFunction(pTemplateText, pData)\n\t{\n\t\t// For now this is being kept in a weird form ... this is to mimic the old\n\t\t// underscore code until this is rewritten using precedent.\n\t\tthis.TemplateSource = \"__p+='\" + pTemplateText\n\t\t\t.replace(this.Matchers.Escaper,\n\t\t\t\t(pMatch)=>\n\t\t\t\t{\n\t\t\t\t\treturn `\\\\${this.templateEscapes[pMatch]}`;\n\t\t\t\t})\n\t\t\t.replace(this.Matchers.Interpolate || this.Matchers.GuaranteedNonMatch,\n\t\t\t\t(pMatch, pCode) =>\n\t\t\t\t{\n\t\t\t\t\treturn `'+\\n(${decodeURIComponent(pCode)})+\\n'`;\n\t\t\t\t})\n\t\t\t.replace(this.Matchers.Evaluate || this.Matchers.GuaranteedNonMatch,\n\t\t\t\t(pMatch, pCode) =>\n\t\t\t\t{\n\t\t\t\t\treturn `';\\n${decodeURIComponent(pCode)}\\n;__p+='`;\n\t\t\t\t}) + `';\\n`;\n\n\n\t\tthis.TemplateSource = `with(pTemplateDataObject||{}){\\n${this.TemplateSource}}\\n`;\n\t\tthis.TemplateSource = `var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};\\n${this.TemplateSource}return __p;\\n`;\n\n\t\tthis.renderFunction = new Function('pTemplateDataObject', this.TemplateSource);\n\n\t\tif (typeof(pData) != 'undefined')\n\t\t{\n\t\t\treturn this.renderFunction(pData);\n\t\t}\n\n\t\t// Provide the compiled function source as a convenience for build time\n\t\t// precompilation.\n\t\tthis.TemplateSourceCompiled = 'function(obj){\\n' + this.TemplateSource + '}';\n\n\t\treturn this.templateFunction();\n\t}\n}\n\nmodule.exports = FableServiceTemplate;","const libFableServiceBase = require('./Fable-ServiceProviderBase.js');\n\n\n// TODO: These are still pretty big -- consider the smaller polyfills\nconst libAsyncWaterfall = require('async.waterfall');\nconst libAsyncEachLimit = require('async.eachlimit');\n\nclass FableServiceUtility extends libFableServiceBase\n{\n\t// Underscore and lodash have a behavior, _.template, which compiles a\n\t// string-based template with code snippets into simple executable pieces,\n\t// with the added twist of returning a precompiled function ready to go.\n\t//\n\t// NOTE: This does not implement underscore escape expressions\n\t// NOTE: This does not implement underscore magic browser variable assignment\n\t//\n\t// This is an implementation of that.\n\t// TODO: Make this use precedent, add configuration, add debugging.\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n        super(pFable, pOptions, pServiceHash);\n\n\t\tthis.templates = {};\n\n\t\t// These two functions are used extensively throughout\n\t\tthis.waterfall = libAsyncWaterfall;\n\t\tthis.eachLimit = libAsyncEachLimit;\n\t}\n\n\t// Underscore and lodash have a behavior, _.extend, which merges objects.\n\t// Now that es6 gives us this, use the native thingy.\n\textend(pDestinationObject, ...pSourceObjects)\n\t{\n\t\treturn Object.assign(pDestinationObject, ...pSourceObjects);\n\t}\n\n\t// Underscore and lodash have a behavior, _.template, which compiles a\n\t// string-based template with code snippets into simple executable pieces,\n\t// with the added twist of returning a precompiled function ready to go.\n\ttemplate(pTemplateText, pData)\n\t{\n\t\tlet tmpTemplate = this.fable.serviceManager.instantiateServiceProviderWithoutRegistration('Template');\n\n\t\treturn tmpTemplate.buildTemplateFunction(pTemplateText, pData);\n\t}\n\n\t// Build a template function from a template hash, and, register it with the service provider\n\tbuildHashedTemplate(pTemplateHash, pTemplateText, pData)\n\t{\n\t\tlet tmpTemplate = this.fable.serviceManager.instantiateServiceProvider('Template', {}, pTemplateHash);\n\n\t\tthis.templates[pTemplateHash] = tmpTemplate.buildTemplateFunction(pTemplateText, pData);\n\n\t\treturn this.templates[pTemplateHash];\n\t}\n\n\t// This is a safe, modern version of chunk from underscore\n\t// Algorithm pulled from a mix of these two polyfills:\n\t// https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_chunk\n\t// https://youmightnotneed.com/lodash\n\t// This implementation was most tolerant in browsers.  Uglify can fix the rest.\n\tchunk (pInput, pChunkSize, pChunkCache)\n\t{\n\t\tlet tmpInputArray = [...pInput];\n\t\t// Note lodash defaults to 1, underscore defaults to 0\n\t\tlet tmpChunkSize = (typeof(pChunkSize) == 'number') ? pChunkSize : 0;\n\t\tlet tmpChunkCache = (typeof(pChunkCache) != 'undefined') ? pChunkCache : [];\n\n\t\tif (tmpChunkSize <= 0)\n\t\t{\n\t\t\treturn tmpChunkCache;\n\t\t}\n\n\t\twhile (tmpInputArray.length)\n\t\t{\n\t\t\ttmpChunkCache.push(tmpInputArray.splice(0, tmpChunkSize));\n\t\t}\n\n\t\treturn tmpChunkCache;\n\t}\n}\n\nmodule.exports = FableServiceUtility;","/**\n* Fable Application Services Management\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\nconst libFableServiceBase = require('./Fable-ServiceProviderBase.js');\n\nclass FableService\n{\n\tconstructor(pFable)\n\t{\n\t\tthis.fable = pFable;\n\n\t\tthis.serviceTypes = [];\n\n\t\t// A map of instantiated services\n\t\tthis.services = {};\n\n\t\t// A map of the default instantiated service by type\n\t\tthis.defaultServices = {};\n\n\t\t// A map of class constructors for services\n\t\tthis.serviceClasses = {};\n\t}\n\n\taddServiceType(pServiceType, pServiceClass)\n\t{\n\t\t// Add the type to the list of types\n\t\tthis.serviceTypes.push(pServiceType);\n\n\t\t// Add the container for instantiated services to go in\n\t\tthis.services[pServiceType] = {};\n\n\t\tif ((typeof(pServiceClass) == 'function') && (pServiceClass.prototype instanceof libFableServiceBase))\n\t\t{\n\t\t\t// Add the class to the list of classes\n\t\t\tthis.serviceClasses[pServiceType] = pServiceClass;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Add the base class to the list of classes\n\t\t\tthis.serviceClasses[pServiceType] = libFableServiceBase;\n\t\t}\n\t}\n\n\tinstantiateServiceProvider(pServiceType, pOptions, pCustomServiceHash)\n\t{\n\t\t// Instantiate the service\n\t\tlet tmpService = this.instantiateServiceProviderWithoutRegistration(pServiceType, pOptions, pCustomServiceHash);\n\n\t\t// Add the service to the service map\n\t\tthis.services[pServiceType][tmpService.Hash] = tmpService;\n\n\t\t// If this is the first service of this type, make it the default\n\t\tif (!this.defaultServices.hasOwnProperty(pServiceType))\n\t\t{\n\t\t\tthis.defaultServices[pServiceType] = tmpService;\n\t\t}\n\n\t\treturn tmpService;\n\t}\n\n\t// Create a service provider but don't register it to live forever in fable.services\n\tinstantiateServiceProviderWithoutRegistration(pServiceType, pOptions, pCustomServiceHash)\n\t{\n\t\t// Instantiate the service\n\t\tlet tmpService = new this.serviceClasses[pServiceType](this.fable, pOptions, pCustomServiceHash);\n\t\treturn tmpService;\n\t}\n\n\tsetDefaultServiceInstantiation(pServiceType, pServiceHash)\n\t{\n\t\tif (this.services[pServiceType].hasOwnProperty(pServiceHash))\n\t\t{\n\t\t\tthis.defaultServices[pServiceType] = this.services[pServiceType][pServiceHash];\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n}\n\nmodule.exports = FableService;\n\nmodule.exports.ServiceProviderBase = libFableServiceBase;","/**\n* Fable Service Base\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\nclass FableServiceProviderBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tthis.fable = pFable;\n\n\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions : {};\n\n        this.serviceType = 'Unknown';\n\n        this.UUID = pFable.getUUID();\n\n        this.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash : `${this.UUID}`;\n\t}\n}\n\nmodule.exports = FableServiceProviderBase;\n","/**\n* Fable Application Services Support Library\n* @license MIT\n* @author <steven@velozo.com>\n*/\nconst libFableSettings = require('fable-settings');\nconst libFableUUID = require('fable-uuid');\nconst libFableLog = require('fable-log');\n\nconst libFableServiceManager = require('./Fable-ServiceManager.js');\n\nconst libFableServiceDataArithmatic = require('./Fable-Service-DataArithmatic.js');\nconst libFableServiceTemplate = require('./Fable-Service-Template.js');\nconst libFableServiceUtility = require('./Fable-Service-Utility.js');\n\nconst libFableOperation = require('./Fable-Operation.js');\n\nclass Fable\n{\n\tconstructor(pSettings)\n\t{\n\t\tlet tmpSettings = new libFableSettings(pSettings);\n\n\t\tthis.settingsManager = tmpSettings;\n\n\t\t// Instantiate the UUID generator\n\t\tthis.libUUID = new libFableUUID(this.settingsManager.settings);\n\n\t\tthis.log = new libFableLog(this.settingsManager.settings);\n\t\tthis.log.initialize();\n\n\t\t// Built-in dependencies\n\t\tthis.Dependencies = (\n\t\t\t{\n\t\t\t\tprecedent: libFableSettings.precedent\n\t\t\t});\n\n\t\t// Location for Operation state\n\t\tthis.Operations = {};\n\n\t\tthis.serviceManager = new libFableServiceManager(this);\n\n\t\t// Initialize and instantiate the default baked-in Data Arithmatic service\n\t\tthis.serviceManager.addServiceType('DataArithmatic', libFableServiceDataArithmatic);\n\t\tthis.fable.serviceManager.instantiateServiceProvider('DataArithmatic', {}, 'Default-Service-DataArithmatic');\n\t\t// This service is passing through the data arithmatic library\n\t\tthis.DataArithmatic = this.serviceManager.defaultServices.DataArithmatic._DataArithmaticLibrary;\n\n\t\t// Initialize the template service\n\t\tthis.serviceManager.addServiceType('Template', libFableServiceTemplate);\n\n\t\t// Initialize and instantiate the default baked-in Utility service\n\t\tthis.serviceManager.addServiceType('Utility', libFableServiceUtility)\n\t\tthis.fable.serviceManager.instantiateServiceProvider('Utility', {}, 'Default-Service-Utility');\n\t\tthis.Utility = this.serviceManager.defaultServices.Utility;\n\n\t\tthis.services = this.serviceManager.services;\n\t\tthis.defaultServices = this.serviceManager.defaultServices;\n\t}\n\n\tget settings()\n\t{\n\t\treturn this.settingsManager.settings;\n\t}\n\n\tget fable()\n\t{\n\t\treturn this;\n\t}\n\n\tgetUUID()\n\t{\n\t\treturn this.libUUID.getUUID();\n\t}\n\n\tcreateOperation(pOperationName, pOperationHash)\n\t{\n\t\tlet tmpOperation = new libFableOperation(this, pOperationName, pOperationHash);\n\n\t\tif (this.Operations.hasOwnProperty(tmpOperation.Hash))\n\t\t{\n\t\t\t// Uh Oh ...... Operation Hash Collision!\n\t\t\t// TODO: What to do?!\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.Operations[tmpOperation.Hash] = tmpOperation;\n\t\t}\n\n\t\treturn tmpOperation;\n\t}\n\n\tgetOperation(pOperationHash)\n\t{\n\t\tif (!this.Operations.hasOwnProperty(pOperationHash))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.Operations[pOperationHash];\n\t\t}\n\t}\n}\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new Fable(pSettings);\n}\n\nmodule.exports = Fable;\nmodule.exports.new = autoConstruct;\n\nmodule.exports.LogProviderBase = libFableLog.LogProviderBase;\nmodule.exports.ServiceProviderBase = libFableServiceManager.ServiceProviderBase;\n\nmodule.exports.precedent = libFableSettings.precedent;"]}