{"version":3,"sources":["fable.compatible.min.js","node_modules/browser-pack/_prelude.js","node_modules/async.eachlimit/index.js","node_modules/async.iterator/index.js","node_modules/async.util.eachoflimit/index.js","node_modules/async.util.ensureasync/index.js","node_modules/async.util.isarray/index.js","node_modules/async.util.isarraylike/index.js","node_modules/async.util.keyiterator/index.js","node_modules/async.util.keys/index.js","node_modules/async.util.noop/index.js","node_modules/async.util.once/index.js","node_modules/async.util.onlyonce/index.js","node_modules/async.util.restparam/index.js","node_modules/async.util.setimmediate/index.js","node_modules/async.util.withoutindex/index.js","node_modules/async.waterfall/index.js","node_modules/fable-log/source/Fable-Log-BaseLogger.js","node_modules/fable-log/source/Fable-Log-DefaultProviders-Web.js","node_modules/fable-log/source/Fable-Log-DefaultStreams.json","node_modules/fable-log/source/Fable-Log-Logger-Console.js","node_modules/fable-log/source/Fable-Log-Logger-SimpleFlatFile.js","node_modules/fable-log/source/Fable-Log.js","node_modules/fable-settings/source/Fable-Settings-Default.json","node_modules/fable-settings/source/Fable-Settings-TemplateProcessor.js","node_modules/fable-settings/source/Fable-Settings.js","node_modules/fable-uuid/source/Fable-UUID-Random-Browser.js","node_modules/fable-uuid/source/Fable-UUID.js","node_modules/path-browserify/index.js","node_modules/precedent/source/Precedent.js","node_modules/precedent/source/StringParser.js","node_modules/precedent/source/WordTree.js","node_modules/process/browser.js","node_modules/timers-browserify/main.js","source/Fable-Browser-Shim.js","source/Fable-Operation.js","source/Fable-Service-Template.js","source/Fable-ServiceManager.js","source/Fable-ServiceProviderBase.js","source/Fable-Utility.js","source/Fable.js"],"names":["_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","TypeError","o","minLen","_arrayLikeToArray","n","Object","prototype","toString","call","slice","constructor","name","Array","from","test","iter","Symbol","iterator","isArray","len","length","i","arr2","_get","Reflect","get","bind","target","property","receiver","base","_superPropBase","desc","getOwnPropertyDescriptor","arguments","value","apply","this","object","hasOwnProperty","_getPrototypeOf","_inherits","subClass","superClass","create","writable","configurable","defineProperty","_setPrototypeOf","p","setPrototypeOf","__proto__","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","result","Super","NewTarget","construct","_possibleConstructorReturn","self","_typeof","_assertThisInitialized","ReferenceError","sham","Proxy","Boolean","valueOf","e","getPrototypeOf","_classCallCheck","instance","Constructor","_defineProperties","props","descriptor","enumerable","_toPropertyKey","key","_createClass","protoProps","staticProps","arg","_toPrimitive","String","input","hint","prim","toPrimitive","undefined","res","Number","obj","f","exports","module","define","amd","window","global","Fable","r","t","c","require","u","a","Error","code","eachOfLimit","withoutIndex","limit","cb","tasks","makeCallback","index","fn","next","once","noop","onlyOnce","keyIterator","nextKey","done","running","errored","replenish","err","setImmediate","restParam","args","callback","pop","push","innerArgs","sync","_keys","isArrayLike","coll","keys","k","func","startIndex","Math","max","rest","_setImmediate","fallback","setTimeout","timers","ensureAsync","wrapIterator","concat","BaseLogger","pLogStreamSettings","pFableLog","_Settings","loggerUUID","generateInsecureUUID","levels","tmpDate","Date","getTime","replace","pCharacter","tmpRandomData","random","floor","pLogText","pLogObject","write","pLogLevel","getDefaultProviders","tmpDefaultProviders","console","loggertype","streamtype","level","ConsoleLogger","_libBaseLogger","_super","_this","_ShowTimeStamps","showtimestamps","_FormattedTimeStamps","formattedtimestamps","_ContextMessage","Context","Product","_OutputLogLinesToConsole","outputloglinestoconsole","_OutputObjectsToConsole","outputobjectstoconsole","prefixCache","pLevel","pObject","tmpTimeStamp","toISOString","tmpLogLine","log","JSON","stringify","libConsoleLog","libFS","libPath","SimpleFlatFileLogger","_libConsoleLog","_super2","_this2","logFileRawPath","path","logFilePath","normalize","logFileStreamOptions","fileStreamOptions","flags","encoding","fileWriter","createWriteStream","activelyWriting","logLineStrings","logObjectStrings","defaultWriteCompleteCallback","defaultBufferFlushCallback","fCloseComplete","tmpCloseComplete","end","fFlushComplete","tmpFlushComplete","flushBufferToLogFile","tmpLineStrings","tmpObjectStrings","tmpConstructedBufferOutputString","completeBufferFlushToLogFile","fs","FableLog","pFableSettings","pFable","tmpSettings","_Providers","_StreamDefinitions","LogStreams","logStreams","logProviders","activeLogStreams","logStreamsTrace","logStreamsDebug","logStreamsInfo","logStreamsWarn","logStreamsError","logStreamsFatal","datumDecorator","pDatum","uuid","pLogger","fDatumDecorator","pMessage","tmpDecoratedDatum","trace","debug","info","warn","error","fatal","tmpStreamDefinition","assign","addLogger","initialize","tmpMessage","tmpTime","pTimeStamp","pTimeDelta","tmpEndTime","tmpMs","parseInt","tmpSeconds","tmpMinutes","tmpHours","pStartTime","logTimeDelta","getTimeDelta","logTimeDeltaHuman","pSettings","LogProviderBase","LogProviderConsole","ProductVersion","ConfigFile","process","FableSettingsTemplateProcessor","pDependencies","templateProcessor","precedent","addPattern","pTemplateValue","tmpTemplateValue","trim","tmpSeparatorIndex","indexOf","tmpDefaultValue","substring","tmpEnvironmentVariableName","env","pString","parseString","_process","libPrecedent","libFableSettingsTemplateProcessor","FableSettings","dependencies","settingsTemplateProcessor","_configureEnvTemplating","buildDefaultSettings","merge","parse","DefaultConfigFile","pException","settings","_PerformEnvTemplating","NoEnvReplacement","tmpKey","_resolveEnv","parseSetting","toObject","fromObject","_this3","_isObject","forEach","fromValue","toValue","_deepMergeObjects","pSettingsFrom","pSettingsTo","tmpSettingsFrom","tmpSettingsTo","tmpSettingsFromCopy","RandomBytes","getRandomValues","crypto","msCrypto","tmpBuffer","Uint8Array","tmpValue","generateWhatWGBytes","generateRandomBytes","libRandomByteGenerator","FableUUID","_UUIDModeRandom","UUIDModeRandom","_UUIDLength","UUIDLength","_UUIDRandomDictionary","UUIDDictionary","randomByteGenerator","_HexLookup","substr","pBuffer","join","tmpRandomBytes","generate","bytesToUUID","tmpUUID","charAt","generateRandom","generateUUIDv4","assertPath","normalizeStringPosix","allowAboveRoot","lastSegmentLength","lastSlash","dots","charCodeAt","lastSlashIndex","lastIndexOf","posix","resolve","cwd","resolvedPath","resolvedAbsolute","isAbsolute","trailingSeparator","joined","relative","to","fromStart","fromEnd","fromLen","toStart","toLen","lastCommonSep","fromCode","out","_makeLong","dirname","hasRoot","matchedSlash","basename","ext","start","extIdx","firstNonSlashEnd","extname","startDot","startPart","preDotState","format","pathObject","sep","dir","root","_format","ret","delimiter","win32","libWordTree","libStringParser","Precedent","WordTree","StringParser","ParseTree","pPatternStart","pPatternEnd","pParser","pParseTree","Output","OutputBuffer","Pattern","PatternMatch","PatternMatchOutputBuffer","pNode","pParserState","PatternEnd","PatternStart","Parse","flushOutputBuffer","assignNode","appendOutputBuffer","checkPatternEnd","tmpParserState","newParserState","parseCharacter","pTree","pPattern","pIndex","tmpLeaf","addChild","pData","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","fun","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","drainQueue","timeout","run","marker","runClearTimeout","Item","array","nextTick","title","browser","argv","version","versions","on","addListener","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","chdir","umask","clearImmediate","Function","immediateIds","nextImmediateId","Timeout","id","clearFn","_id","_clearFn","setInterval","clearInterval","close","unref","ref","enroll","item","msecs","_idleTimeoutId","_idleTimeout","unenroll","_unrefActive","active","_onTimeout","libNPMModuleWrapper","_OperationStatePrototype","Metadata","GUID","Hash","Title","Summary","Version","Status","Completed","CompletionProgress","CompletionTimeElapsed","Steps","StepsCompleted","StartTime","EndTime","Errors","Log","FableOperation","pOperationName","pOperationHash","fable","state","getUUID","toUTCString","writeOperationLog","writeOperationErrors","FableServiceTemplate","_libFableServiceBase","_super3","pOptions","pServiceHash","_this4","serviceType","Matchers","Evaluate","Interpolate","Escaper","Unescaper","GuaranteedNonMatch","templateEscapes","u2028","u2029","renderFunction","templateString","renderTemplate","pTemplateText","_this5","TemplateSource","pMatch","pCode","decodeURIComponent","TemplateSourceCompiled","templateFunction","libFableServiceBase","FableService","serviceTypes","services","defaultServices","serviceClasses","pServiceType","pServiceClass","pCustomServiceHash","tmpService","instantiateServiceProviderWithoutRegistration","ServiceProviderBase","FableServiceProviderBase","options","UUID","libAsyncWaterfall","libAsyncEachLimit","FableUtility","templates","waterfall","eachLimit","pDestinationObject","_len","pSourceObjects","_key","serviceManager","buildTemplateFunction","pTemplateHash","tmpTemplate","instantiateServiceProvider","pInput","pChunkSize","pChunkCache","tmpInputArray","tmpChunkSize","tmpChunkCache","splice","libFableSettings","libFableUUID","libFableLog","libFableUtility","libFableServiceManager","libFableServiceTemplate","libFableOperation","settingsManager","libUUID","Utility","Dependencies","Operations","addServiceType","tmpOperation"],"mappings":"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","file":"fable.compatible.min.js","sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.Fable = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n'use strict';\n\nvar eachOfLimit = require('async.util.eachoflimit');\nvar withoutIndex = require('async.util.withoutindex');\n\nmodule.exports = function eachLimit(arr, limit, iterator, cb) {\n    return eachOfLimit(limit)(arr, withoutIndex(iterator), cb);\n};\n\n},{\"async.util.eachoflimit\":3,\"async.util.withoutindex\":14}],2:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function(tasks) {\n    function makeCallback(index) {\n        function fn() {\n            if (tasks.length) {\n                tasks[index].apply(null, arguments);\n            }\n            return fn.next();\n        }\n        fn.next = function() {\n            return (index < tasks.length - 1) ? makeCallback(index + 1) : null;\n        };\n        return fn;\n    }\n    return makeCallback(0);\n};\n\n},{}],3:[function(require,module,exports){\nvar once = require('async.util.once');\nvar noop = require('async.util.noop');\nvar onlyOnce = require('async.util.onlyonce');\nvar keyIterator = require('async.util.keyiterator');\n\nmodule.exports = function eachOfLimit(limit) {\n    return function(obj, iterator, cb) {\n        cb = once(cb || noop);\n        obj = obj || [];\n        var nextKey = keyIterator(obj);\n        if (limit <= 0) {\n            return cb(null);\n        }\n        var done = false;\n        var running = 0;\n        var errored = false;\n\n        (function replenish() {\n            if (done && running <= 0) {\n                return cb(null);\n            }\n\n            while (running < limit && !errored) {\n                var key = nextKey();\n                if (key === null) {\n                    done = true;\n                    if (running <= 0) {\n                        cb(null);\n                    }\n                    return;\n                }\n                running += 1;\n                iterator(obj[key], key, onlyOnce(function(err) {\n                    running -= 1;\n                    if (err) {\n                        cb(err);\n                        errored = true;\n                    } else {\n                        replenish();\n                    }\n                }));\n            }\n        })();\n    };\n};\n\n},{\"async.util.keyiterator\":7,\"async.util.noop\":9,\"async.util.once\":10,\"async.util.onlyonce\":11}],4:[function(require,module,exports){\n'use strict';\nvar setImmediate = require('async.util.setimmediate');\nvar restParam = require('async.util.restparam');\n\nmodule.exports = function(fn) {\n    return restParam(function(args) {\n        var callback = args.pop();\n        args.push(function() {\n            var innerArgs = arguments;\n            if (sync) {\n                setImmediate(function() {\n                    callback.apply(null, innerArgs);\n                });\n            } else {\n                callback.apply(null, innerArgs);\n            }\n        });\n        var sync = true;\n        fn.apply(this, args);\n        sync = false;\n    });\n};\n\n},{\"async.util.restparam\":12,\"async.util.setimmediate\":13}],5:[function(require,module,exports){\n'use strict';\n\nmodule.exports = Array.isArray || function isArray(obj) {\n    return Object.prototype.toString.call(obj) === '[object Array]';\n};\n\n},{}],6:[function(require,module,exports){\n'use strict';\n\nvar isArray = require('async.util.isarray');\n\nmodule.exports = function isArrayLike(arr) {\n    return isArray(arr) || (\n        // has a positive integer length property\n        typeof arr.length === 'number' &&\n        arr.length >= 0 &&\n        arr.length % 1 === 0\n    );\n};\n\n},{\"async.util.isarray\":5}],7:[function(require,module,exports){\n'use strict';\n\nvar _keys = require('async.util.keys');\nvar isArrayLike = require('async.util.isarraylike');\n\nmodule.exports = function keyIterator(coll) {\n    var i = -1;\n    var len;\n    var keys;\n    if (isArrayLike(coll)) {\n        len = coll.length;\n        return function next() {\n            i++;\n            return i < len ? i : null;\n        };\n    } else {\n        keys = _keys(coll);\n        len = keys.length;\n        return function next() {\n            i++;\n            return i < len ? keys[i] : null;\n        };\n    }\n};\n\n},{\"async.util.isarraylike\":6,\"async.util.keys\":8}],8:[function(require,module,exports){\n'use strict';\n\nmodule.exports = Object.keys || function keys(obj) {\n    var _keys = [];\n    for (var k in obj) {\n        if (obj.hasOwnProperty(k)) {\n            _keys.push(k);\n        }\n    }\n    return _keys;\n};\n\n},{}],9:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function noop () {};\n\n},{}],10:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function once(fn) {\n    return function() {\n        if (fn === null) return;\n        fn.apply(this, arguments);\n        fn = null;\n    };\n};\n\n},{}],11:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function only_once(fn) {\n    return function() {\n        if (fn === null) throw new Error('Callback was already called.');\n        fn.apply(this, arguments);\n        fn = null;\n    };\n};\n\n},{}],12:[function(require,module,exports){\n'use strict';\nmodule.exports = function restParam(func, startIndex) {\n    startIndex = startIndex == null ? func.length - 1 : +startIndex;\n    return function() {\n        var length = Math.max(arguments.length - startIndex, 0);\n        var rest = new Array(length);\n        for (var index = 0; index < length; index++) {\n            rest[index] = arguments[index + startIndex];\n        }\n        switch (startIndex) {\n            case 0:\n                return func.call(this, rest);\n            case 1:\n                return func.call(this, arguments[0], rest);\n        }\n    };\n};\n\n},{}],13:[function(require,module,exports){\n(function (setImmediate){(function (){\n'use strict';\n\nvar _setImmediate = typeof setImmediate === 'function' && setImmediate;\nvar fallback = function(fn) {\n    setTimeout(fn, 0);\n};\n\nmodule.exports = function setImmediate(fn) {\n    // not a direct alias for IE10 compatibility\n    return (_setImmediate || fallback)(fn);\n};\n\n}).call(this)}).call(this,require(\"timers\").setImmediate)\n\n},{\"timers\":33}],14:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function withoutIndex(iterator) {\n    return function(value, index, callback) {\n        return iterator(value, callback);\n    };\n};\n\n},{}],15:[function(require,module,exports){\n'use strict';\n\nvar once = require('async.util.once');\nvar noop = require('async.util.noop');\nvar isArray = require('async.util.isarray');\nvar restParam = require('async.util.restparam');\nvar ensureAsync = require('async.util.ensureasync');\nvar iterator = require('async.iterator');\n\nmodule.exports = function(tasks, cb) {\n    cb = once(cb || noop);\n    if (!isArray(tasks)) return cb(new Error('First argument to waterfall must be an array of functions'));\n    if (!tasks.length) return cb();\n\n    function wrapIterator(iterator) {\n        return restParam(function(err, args) {\n            if (err) {\n                cb.apply(null, [err].concat(args));\n            } else {\n                var next = iterator.next();\n                if (next) {\n                    args.push(wrapIterator(next));\n                } else {\n                    args.push(cb);\n                }\n                ensureAsync(iterator).apply(null, args);\n            }\n        });\n    }\n    wrapIterator(iterator(tasks))();\n};\n\n},{\"async.iterator\":2,\"async.util.ensureasync\":4,\"async.util.isarray\":5,\"async.util.noop\":9,\"async.util.once\":10,\"async.util.restparam\":12}],16:[function(require,module,exports){\n\n},{}],17:[function(require,module,exports){\n/**\n* Base Logger Class\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\nclass BaseLogger\n{\n\tconstructor(pLogStreamSettings, pFableLog)\n\t{\n\t\t// This should not possibly be able to be instantiated without a settings object\n\t\tthis._Settings = (typeof(pLogStreamSettings) == 'object') ? pLogStreamSettings : {};\n\n\t\t// The base logger does nothing but associate a UUID with itself\n\t\t// We added this as the mechanism for tracking loggers to allow multiple simultaneous streams\n\t\t// to the same provider.\n\t\tthis.loggerUUID = this.generateInsecureUUID();\n\n\t\t// Eventually we can use this array to ompute which levels the provider allows.\n\t\t// For now it's just used to precompute some string concatenations.\n\t\tthis.levels = (\n\t\t\t[\n\t\t\t\t\"trace\",\n\t\t\t\t\"debug\",\n\t\t\t\t\"info\",\n\t\t\t\t\"warn\",\n\t\t\t\t\"error\",\n\t\t\t\t\"fatal\"\n\t\t\t]);\n\t}\n\n\t// This is meant to generate programmatically insecure UUIDs to identify loggers\n\tgenerateInsecureUUID()\n\t{\n\t\tlet tmpDate = new Date().getTime();\n\t\tlet tmpUUID = 'LOGSTREAM-xxxxxx-yxxxxx'.replace(/[xy]/g,\n\t\t\t\t(pCharacter) =>\n\t\t\t\t{\n\t\t\t\t\t// Funny algorithm from w3resource that is twister-ish without the deep math and security\n\t\t\t\t\t// ..but good enough for unique log stream identifiers\n\t\t\t\t\tlet tmpRandomData = (tmpDate + Math.random()*16)%16 | 0;\n\t\t\t\t\ttmpDate = Math.floor(tmpDate/16);\n\n\t\t\t\t\treturn (pCharacter =='x' ? tmpRandomData : (tmpRandomData&0x3|0x8)).toString(16);\n\t\t\t\t});\n\t\treturn tmpUUID;\n\t}\n\n\tinitialize()\n\t{\n\t\t// No operation.\n\t}\n\n\ttrace(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"trace\", pLogText, pLogObject);\n\t}\n\n\tdebug(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"debug\", pLogText, pLogObject);\n\t}\n\n\tinfo(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"info\", pLogText, pLogObject);\n\t}\n\n\twarn(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"warn\", pLogText, pLogObject);\n\t}\n\n\terror(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"error\", pLogText, pLogObject);\n\t}\n\n\tfatal(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"fatal\", pLogText, pLogObject);\n\t}\n\n\twrite(pLogLevel, pLogText, pLogObject)\n\t{\n\t\t// The base logger does nothing.\n\t\treturn true;\n\t}\n}\n\nmodule.exports = BaseLogger;\n\n},{}],18:[function(require,module,exports){\n/**\n* Default Logger Provider Function\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\n// Return the providers that are available without extensions loaded\ngetDefaultProviders = () =>\n{\n\tlet tmpDefaultProviders = {};\n\n\ttmpDefaultProviders.console = require('./Fable-Log-Logger-Console.js');\n\n\ttmpDefaultProviders.default = tmpDefaultProviders.console;\n\n\treturn tmpDefaultProviders;\n}\n\nmodule.exports = getDefaultProviders();\n},{\"./Fable-Log-Logger-Console.js\":20}],19:[function(require,module,exports){\nmodule.exports=[\n    {\n        \"loggertype\": \"console\",\n        \"streamtype\": \"console\",\n        \"level\": \"trace\"\n    }\n]\n},{}],20:[function(require,module,exports){\nlet libBaseLogger = require('./Fable-Log-BaseLogger.js');\n\nclass ConsoleLogger extends libBaseLogger\n{\n\tconstructor(pLogStreamSettings, pFableLog)\n\t{\n\t\tsuper(pLogStreamSettings);\n\n\t\tthis._ShowTimeStamps = this._Settings.hasOwnProperty('showtimestamps') ? (this._Settings.showtimestamps == true) : true;\n\t\tthis._FormattedTimeStamps = this._Settings.hasOwnProperty('formattedtimestamps') ? (this._Settings.formattedtimestamps == true) : true;\n\n\t\tthis._ContextMessage = this._Settings.hasOwnProperty('Context') ? `(${this._Settings.Context})` : \n\t\t\t\t\t\t\t\tpFableLog._Settings.hasOwnProperty('Product') ? `(${pFableLog._Settings.Product})` :\n\t\t\t\t\t\t\t\t'Unnamed_Log_Context';\n\n\t\t// Allow the user to decide what gets output to the console\n\t\tthis._OutputLogLinesToConsole = this._Settings.hasOwnProperty('outputloglinestoconsole') ? this._Settings.outputloglinestoconsole : true;\n\t\tthis._OutputObjectsToConsole = this._Settings.hasOwnProperty('outputobjectstoconsole') ? this._Settings.outputobjectstoconsole : true;\n\n\t\t// Precompute the prefix for each level\n\t\tthis.prefixCache = {};\n\t\tfor (let i = 0; i <= this.levels.length; i++)\n\t\t{\n\t\t\tthis.prefixCache[this.levels[i]] = `[${this.levels[i]}] ${this._ContextMessage}: `;\n\n\t\t\tif (this._ShowTimeStamps)\n\t\t\t{\n\t\t\t\t// If there is a timestamp we need a to prepend space before the prefixcache string, since the timestamp comes first\n\t\t\t\tthis.prefixCache[this.levels[i]] = ' '+this.prefixCache[this.levels[i]];\n\t\t\t}\n\t\t}\n\t}\n\n\twrite(pLevel, pLogText, pObject)\n\t{\n\t\tlet tmpTimeStamp = '';\n\t\tif (this._ShowTimeStamps && this._FormattedTimeStamps)\n\t\t{\n\t\t\ttmpTimeStamp = (new Date()).toISOString();\n\t\t}\n\t\telse if (this._ShowTimeStamps)\n\t\t{\n\t\t\ttmpTimeStamp = +new Date();\n\t\t}\n\n\t\tlet tmpLogLine = `${tmpTimeStamp}${this.prefixCache[pLevel]}${pLogText}`;\n\n\t\tif (this._OutputLogLinesToConsole)\n\t\t{\n\t\t\tconsole.log(tmpLogLine);\n\t\t}\n\n\t\t// Write out the object on a separate line if it is passed in\n\t\tif (this._OutputObjectsToConsole && (typeof(pObject) !== 'undefined'))\n\t\t{\n\t\t\tconsole.log(JSON.stringify(pObject, null, 2));\n\t\t}\n\n\t\t// Provide an easy way to be overridden and be consistent\n\t\treturn tmpLogLine;\n\t}\n}\n\nmodule.exports = ConsoleLogger;\n},{\"./Fable-Log-BaseLogger.js\":17}],21:[function(require,module,exports){\nconst libConsoleLog = require('./Fable-Log-Logger-Console.js');\nconst libFS = require('fs');\nconst libPath = require('path');\n\nclass SimpleFlatFileLogger extends libConsoleLog\n{\n\tconstructor(pLogStreamSettings, pFableLog)\n\t{\n\t\tsuper(pLogStreamSettings, pFableLog);\n\n\t\t// If a path isn't provided for the logfile, it tries to use the ProductName or Context\n\t\tthis.logFileRawPath = (this._Settings.hasOwnProperty('path')) ? this._Settings.path : `./${this._ContextMessage}.log`;\n\t\tthis.logFilePath = libPath.normalize(this.logFileRawPath);\n\n\t\tthis.logFileStreamOptions = (this._Settings.hasOwnProperty('fileStreamoptions')) ? this._Settings.fileStreamOptions : (\n\t\t\t{\n\t\t\t\t\"flags\": \"a\",\n\t\t\t\t\"encoding\": \"utf8\"\n\t\t\t})\n\n\t\tthis.fileWriter = libFS.createWriteStream(this.logFilePath, this.logFileStreamOptions);\n\n\t\tthis.activelyWriting = false;\n\n\t\tthis.logLineStrings = [];\n\t\tthis.logObjectStrings = [];\n\n\t\tthis.defaultWriteCompleteCallback = ()=>{};\n\t\tthis.defaultBufferFlushCallback = ()=>{};\n\t}\n\n\tcloseWriter(fCloseComplete)\n\t{\n\t\tlet tmpCloseComplete = (typeof(fCloseComplete) == 'function') ? fCloseComplete : ()=>{};\n\t\tif (this.fileWriter)\n\t\t{\n\t\t\tthis.fileWriter.end('\\n');\n\t\t\treturn this.fileWriter.once('finish', tmpCloseComplete.bind(this));\n\t\t}\n\t};\n\n\tcompleteBufferFlushToLogFile(fFlushComplete)\n\t{\n\t\tthis.activelyWriting = false;\n\t\tlet tmpFlushComplete = (typeof(fFlushComplete) == 'function') ? fFlushComplete : this.defaultBufferFlushCallback;\n\n\t\tif (this.logLineStrings.length > 0)\n\t\t{\n\t\t\tthis.flushBufferToLogFile(tmpFlushComplete);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn tmpFlushComplete();\n\t\t}\n\t}\n\n\tflushBufferToLogFile(fFlushComplete)\n\t{\n\t\tif (!this.activelyWriting)\n\t\t{\n\t\t\t// Only want to be writing one thing at a time....\n\t\t\tthis.activelyWriting = true;\n\n\t\t\tlet tmpFlushComplete = (typeof(fFlushComplete) == 'function') ? fFlushComplete : this.defaultBufferFlushCallback;\n\n\t\t\t// Get the current buffer arrays.  These should always have matching number of elements.\n\t\t\tlet tmpLineStrings = this.logLineStrings;\n\t\t\tlet tmpObjectStrings = this.logObjectStrings;\n\n\t\t\t// Reset these to be filled while we process this queue...\n\t\t\tthis.logLineStrings = [];\n\t\t\tthis.logObjectStrings = [];\n\n\t\t\t// This is where we will put each line before writing it to the file...\n\t\t\tlet tmpConstructedBufferOutputString = '';\n\n\t\t\tfor (let i = 0; i < tmpLineStrings.length; i++)\n\t\t\t{\n\t\t\t\t// TODO: Windows Newline?   ....... yo no se!\n\t\t\t\ttmpConstructedBufferOutputString += `${tmpLineStrings[i]}\\n`;\n\t\t\t\tif (tmpObjectStrings[i] !== false)\n\t\t\t\t{\n\t\t\t\t\ttmpConstructedBufferOutputString += `${tmpObjectStrings[i]}\\n`;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!this.fileWriter.write(tmpConstructedBufferOutputString, 'utf8'))\n\t\t\t{\n\t\t\t\t// If the streamwriter returns false, we need to wait for it to drain.\n\t\t\t\tthis.fileWriter.once('drain', this.completeBufferFlushToLogFile.bind(this, tmpFlushComplete));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn this.completeBufferFlushToLogFile(tmpFlushComplete);\n\t\t\t}\n\t\t}\n\t}\n\n\twrite(pLevel, pLogText, pObject)\n\t{\n\t\tlet tmpLogLine = super.write(pLevel, pLogText, pObject);\n\n\t\t// Use a very simple array as the write buffer\n\t\tthis.logLineStrings.push(tmpLogLine);\n\n\t\t// Write out the object on a separate line if it is passed in\n\t\tif (typeof(pObject) !== 'undefined')\n\t\t{\n\t\t\tthis.logObjectStrings.push(JSON.stringify(pObject, null, 4));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logObjectStrings.push(false);\n\t\t}\n\n\t\tthis.flushBufferToLogFile();\n\t}\n}\n\nmodule.exports = SimpleFlatFileLogger;\n},{\"./Fable-Log-Logger-Console.js\":20,\"fs\":16,\"path\":28}],22:[function(require,module,exports){\n/**\n* Fable Logging Add-on\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable Logger\n*/\n\n/**\n* Fable Solution Log Wrapper Main Class\n*\n* @class FableLog\n* @constructor\n*/\nclass FableLog\n{\n\tconstructor(pFableSettings, pFable)\n\t{\n\t\tlet tmpSettings = (typeof(pFableSettings) === 'object') ? pFableSettings : {}\n\t\tthis._Settings = tmpSettings;\n\n\t\tthis._Providers = require('./Fable-Log-DefaultProviders-Node.js');\n\n\t\tthis._StreamDefinitions = (tmpSettings.hasOwnProperty('LogStreams')) ? tmpSettings.LogStreams : require('./Fable-Log-DefaultStreams.json');\n\n\t\tthis.logStreams = [];\n\n\t\t// This object gets decorated for one-time instantiated providers that\n\t\t//  have multiple outputs, such as bunyan.\n\t\tthis.logProviders = {};\n\n\t\t// A hash list of the GUIDs for each log stream, so they can't be added to the set more than one time\n\t\tthis.activeLogStreams = {};\n\n\t\tthis.logStreamsTrace = [];\n\t\tthis.logStreamsDebug = [];\n\t\tthis.logStreamsInfo = [];\n\t\tthis.logStreamsWarn = [];\n\t\tthis.logStreamsError = [];\n\t\tthis.logStreamsFatal = [];\n\n\t\tthis.datumDecorator = (pDatum) => pDatum;\n\n\t\tthis.uuid = (typeof(tmpSettings.Product) === 'string') ? tmpSettings.Product : 'Default';\n\t}\n\n\taddLogger(pLogger, pLevel)\n\t{\n\t\t// Bail out if we've already created one.\n\t\tif (this.activeLogStreams.hasOwnProperty(pLogger.loggerUUID))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// Add it to the streams and to the mutex\n\t\tthis.logStreams.push(pLogger);\n\t\tthis.activeLogStreams[pLogger.loggerUUID] = true;\n\n\t\t// Make sure a kosher level was passed in\n\t\tswitch (pLevel)\n\t\t{\n\t\t\tcase 'trace':\n\t\t\t\tthis.logStreamsTrace.push(pLogger);\n\t\t\tcase 'debug':\n\t\t\t\tthis.logStreamsDebug.push(pLogger);\n\t\t\tcase 'info':\n\t\t\t\tthis.logStreamsInfo.push(pLogger);\n\t\t\tcase 'warn':\n\t\t\t\tthis.logStreamsWarn.push(pLogger);\n\t\t\tcase 'error':\n\t\t\t\tthis.logStreamsError.push(pLogger);\n\t\t\tcase 'fatal':\n\t\t\t\tthis.logStreamsFatal.push(pLogger);\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tsetDatumDecorator(fDatumDecorator)\n\t{\n\t\tif (typeof(fDatumDecorator) === 'function')\n\t\t{\n\t\t\tthis.datumDecorator = fDatumDecorator;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.datumDecorator = (pDatum) => pDatum;\n\t\t}\n\t}\n\n\ttrace(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsTrace.length; i++)\n\t\t{\n\t\t\tthis.logStreamsTrace[i].trace(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tdebug(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsDebug.length; i++)\n\t\t{\n\t\t\tthis.logStreamsDebug[i].debug(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tinfo(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsInfo.length; i++)\n\t\t{\n\t\t\tthis.logStreamsInfo[i].info(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\twarn(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsWarn.length; i++)\n\t\t{\n\t\t\tthis.logStreamsWarn[i].warn(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\terror(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsError.length; i++)\n\t\t{\n\t\t\tthis.logStreamsError[i].error(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tfatal(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsFatal.length; i++)\n\t\t{\n\t\t\tthis.logStreamsFatal[i].fatal(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tinitialize()\n\t{\n\t\t// \"initialize\" each logger as defined in the logging parameters\n\t\tfor (let i = 0; i < this._StreamDefinitions.length; i++)\n\t\t{\n\t\t\tlet tmpStreamDefinition = Object.assign({loggertype:'default',streamtype:'console',level:'info'},this._StreamDefinitions[i]);\n\n\t\t\tif (!this._Providers.hasOwnProperty(tmpStreamDefinition.loggertype))\n\t\t\t{\n\t\t\t\tconsole.log(`Error initializing log stream: bad loggertype in stream definition ${JSON.stringify(tmpStreamDefinition)}`);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.addLogger(new this._Providers[tmpStreamDefinition.loggertype](tmpStreamDefinition, this), tmpStreamDefinition.level);\n\t\t\t}\n\t\t}\n\n\t\t// Now initialize each one.\n\t\tfor (let i = 0; i < this.logStreams.length; i++)\n\t\t{\n\t\t\tthis.logStreams[i].initialize();\n\t\t}\n\t}\n\n\tlogTime(pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time';\n\t\tlet tmpTime = new Date();\n\t\tthis.info(`${tmpMessage} ${tmpTime} (epoch ${+tmpTime})`, pDatum);\n\t}\n\n\t// Get a timestamp\n\tgetTimeStamp()\n\t{\n\t\treturn +new Date();\n\t}\n\n\tgetTimeDelta(pTimeStamp)\n\t{\n\t\tlet tmpEndTime = +new Date();\n\t\treturn tmpEndTime-pTimeStamp;\n\t}\n\n\t// Log the delta between a timestamp, and now with a message\n\tlogTimeDelta(pTimeDelta, pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time Measurement';\n\t\tlet tmpDatum = (typeof(pDatum) === 'object') ? pDatum : {};\n\n\t\tlet tmpEndTime = +new Date();\n\n\t\tthis.info(`${tmpMessage} logged at (epoch ${+tmpEndTime}) took (${pTimeDelta}ms)`, pDatum);\n\t}\n\n\tlogTimeDeltaHuman(pTimeDelta, pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time Measurement';\n\n\t\tlet tmpEndTime = +new Date();\n\n\t\tlet tmpMs = parseInt(pTimeDelta%1000);\n\t\tlet tmpSeconds = parseInt((pTimeDelta/1000)%60);\n\t\tlet tmpMinutes = parseInt((pTimeDelta/(1000*60))%60);\n\t\tlet tmpHours = parseInt(pTimeDelta/(1000*60*60));\n\n\t\ttmpMs = (tmpMs < 10) ? \"00\"+tmpMs : (tmpMs < 100) ? \"0\"+tmpMs : tmpMs;\n\t\ttmpSeconds = (tmpSeconds < 10) ? \"0\"+tmpSeconds : tmpSeconds;\n\t\ttmpMinutes = (tmpMinutes < 10) ? \"0\"+tmpMinutes : tmpMinutes;\n\t\ttmpHours = (tmpHours < 10) ? \"0\"+tmpHours : tmpHours;\n\n\t\tthis.info(`${tmpMessage} logged at (epoch ${+tmpEndTime}) took (${pTimeDelta}ms) or (${tmpHours}:${tmpMinutes}:${tmpSeconds}.${tmpMs})`, pDatum);\n\t}\n\n\tlogTimeDeltaRelative(pStartTime, pMessage, pDatum)\n\t{\n\t\tthis.logTimeDelta(this.getTimeDelta(pStartTime), pMessage, pDatum);\n\t}\n\n\tlogTimeDeltaRelativeHuman(pStartTime, pMessage, pDatum)\n\t{\n\t\tthis.logTimeDeltaHuman(this.getTimeDelta(pStartTime), pMessage, pDatum);\n\t}\n}\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new FableLog(pSettings);\n}\n\n\nmodule.exports = FableLog;\nmodule.exports.new = autoConstruct;\nmodule.exports.LogProviderBase = require('./Fable-Log-BaseLogger.js');\nmodule.exports.LogProviderConsole = require('./Fable-Log-Logger-Console.js');\nmodule.exports.LogProviderConsole = require('./Fable-Log-Logger-SimpleFlatFile.js');\n\n},{\"./Fable-Log-BaseLogger.js\":17,\"./Fable-Log-DefaultProviders-Node.js\":18,\"./Fable-Log-DefaultStreams.json\":19,\"./Fable-Log-Logger-Console.js\":20,\"./Fable-Log-Logger-SimpleFlatFile.js\":21}],23:[function(require,module,exports){\nmodule.exports={\n\t\"Product\": \"ApplicationNameHere\",\n\t\"ProductVersion\": \"0.0.0\",\n\n\t\"ConfigFile\": false,\n\n\t\"LogStreams\":\n\t[\n\t\t{\n\t\t\t\"level\": \"trace\"\n\t\t}\n\t]\n}\n\n},{}],24:[function(require,module,exports){\n(function (process){(function (){\n/**\n* Fable Settings Template Processor\n*\n* This class allows environment variables to come in via templated expressions, and defaults to be set.\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable Settings\n*/\n\nclass FableSettingsTemplateProcessor\n{\n\tconstructor(pDependencies)\n\t{\n        // Use a no-dependencies templating engine to parse out environment variables\n\t\tthis.templateProcessor = new pDependencies.precedent();\n\n        // TODO: Make the environment variable wrap expression demarcation characters configurable?\n\t\tthis.templateProcessor.addPattern('${', '}',\n\t\t\t(pTemplateValue)=>\n\t\t\t{\n\t\t\t\tlet tmpTemplateValue = pTemplateValue.trim();\n\n\t\t\t\tlet tmpSeparatorIndex = tmpTemplateValue.indexOf('|');\n\n\t\t\t\t// If there is no pipe, the default value will end up being whatever the variable name is.\n\t\t\t\tlet tmpDefaultValue = tmpTemplateValue.substring(tmpSeparatorIndex+1);\n\n\t\t\t\tlet tmpEnvironmentVariableName = (tmpSeparatorIndex > -1) ? tmpTemplateValue.substring(0, tmpSeparatorIndex) : tmpTemplateValue;\n\n\t\t\t\tif (process.env.hasOwnProperty(tmpEnvironmentVariableName))\n\t\t\t\t{\n\t\t\t\t\treturn process.env[tmpEnvironmentVariableName];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn tmpDefaultValue;\n\t\t\t\t}\n\t\t\t});\n    }\n\n    parseSetting(pString)\n    {\n        return this.templateProcessor.parseString(pString);\n    }\n}\n\nmodule.exports = FableSettingsTemplateProcessor;\n}).call(this)}).call(this,require('_process'))\n\n},{\"_process\":32}],25:[function(require,module,exports){\n/**\n* Fable Settings Add-on\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable Settings\n*/\n\nconst libPrecedent = require('precedent');\nconst libFableSettingsTemplateProcessor = require('./Fable-Settings-TemplateProcessor.js');\n\nclass FableSettings\n{\n\tconstructor(pFableSettings)\n\t{\n\t\t// Expose the dependencies for downstream re-use\n\t\tthis.dependencies = (\n\t\t\t{\n\t\t\t\tprecedent: libPrecedent\n\t\t\t});\n\n\t\t// Initialize the settings value template processor\n\t\tthis.settingsTemplateProcessor = new libFableSettingsTemplateProcessor(this.dependencies);\n\n\t\t// set straight away so anything that uses it respects the initial setting\n\t\tthis._configureEnvTemplating(pFableSettings);\n\n\t\tthis.default = this.buildDefaultSettings();\n\n\t\t// Construct a new settings object\n\t\tlet tmpSettings = this.merge(pFableSettings, this.buildDefaultSettings());\n\n\t\t// The base settings object (what they were on initialization, before other actors have altered them)\n\t\tthis.base = JSON.parse(JSON.stringify(tmpSettings));\n\n\t\tif (tmpSettings.DefaultConfigFile)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// If there is a DEFAULT configuration file, try to load and merge it.\n\t\t\t\ttmpSettings = this.merge(require(tmpSettings.DefaultConfigFile), tmpSettings);\n\t\t\t}\n\t\t\tcatch (pException)\n\t\t\t{\n\t\t\t\t// Why this?  Often for an app we want settings to work out of the box, but\n\t\t\t\t// would potentially want to have a config file for complex settings.\n\t\t\t\tconsole.log('Fable-Settings Warning: Default configuration file specified but there was a problem loading it.  Falling back to base.');\n\t\t\t\tconsole.log('     Loading Exception: '+pException);\n\t\t\t}\n\t\t}\n\n\t\tif (tmpSettings.ConfigFile)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// If there is a configuration file, try to load and merge it.\n\t\t\t\ttmpSettings = this.merge(require(tmpSettings.ConfigFile), tmpSettings);\n\t\t\t}\n\t\t\tcatch (pException)\n\t\t\t{\n\t\t\t\t// Why this?  Often for an app we want settings to work out of the box, but\n\t\t\t\t// would potentially want to have a config file for complex settings.\n\t\t\t\tconsole.log('Fable-Settings Warning: Configuration file specified but there was a problem loading it.  Falling back to base.');\n\t\t\t\tconsole.log('     Loading Exception: '+pException);\n\t\t\t}\n\t\t}\n\n\t\tthis.settings = tmpSettings;\n\t}\n\n\t// Build a default settings object.  Use the JSON jimmy to ensure it is always a new object.\n\tbuildDefaultSettings()\n\t{\n\t\treturn JSON.parse(JSON.stringify(require('./Fable-Settings-Default')));\n\t}\n\n\t// Update the configuration for environment variable templating based on the current settings object\n\t_configureEnvTemplating(pSettings)\n\t{\n\t\t// default environment variable templating to on\n\t\tthis._PerformEnvTemplating = !pSettings || pSettings.NoEnvReplacement !== true;\n\t}\n\n\t// Resolve (recursive) any environment variables found in settings object.\n\t_resolveEnv(pSettings)\n\t{\n\t\tfor (const tmpKey in pSettings)\n\t\t{\n\t\t\tif (typeof(pSettings[tmpKey]) === 'object')\n\t\t\t{\n\t\t\t\tthis._resolveEnv(pSettings[tmpKey]);\n\t\t\t}\n\t\t\telse if (typeof(pSettings[tmpKey]) === 'string')\n\t\t\t{\n\t\t\t\tpSettings[tmpKey] = this.settingsTemplateProcessor.parseSetting(pSettings[tmpKey]);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Check to see if a value is an object (but not an array).\n\t */\n\t_isObject(value)\n\t{\n\t\treturn typeof(value) === 'object' && !Array.isArray(value);\n\t}\n\n\t/**\n\t * Merge two plain objects. Keys that are objects in both will be merged property-wise.\n\t */\n\t_deepMergeObjects(toObject, fromObject)\n\t{\n\t\tif (!fromObject || !this._isObject(fromObject))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tObject.keys(fromObject).forEach((key) =>\n\t\t{\n\t\t\tconst fromValue = fromObject[key];\n\t\t\tif (this._isObject(fromValue))\n\t\t\t{\n\t\t\t\tconst toValue = toObject[key];\n\t\t\t\tif (toValue && this._isObject(toValue))\n\t\t\t\t{\n\t\t\t\t\t// both are objects, so do a recursive merge\n\t\t\t\t\tthis._deepMergeObjects(toValue, fromValue);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttoObject[key] = fromValue;\n\t\t});\n\t\treturn toObject;\n\t}\n\n\t// Merge some new object into the existing settings.\n\tmerge(pSettingsFrom, pSettingsTo)\n\t{\n\t\t// If an invalid settings from object is passed in (e.g. object constructor without passing in anything) this should still work\n\t\tlet tmpSettingsFrom = (typeof(pSettingsFrom) === 'object') ? pSettingsFrom : {};\n\t\t// Default to the settings object if none is passed in for the merge.\n\t\tlet tmpSettingsTo = (typeof(pSettingsTo) === 'object') ? pSettingsTo : this.settings;\n\n\t\t// do not mutate the From object property values\n\t\tlet tmpSettingsFromCopy = JSON.parse(JSON.stringify(tmpSettingsFrom));\n\t\ttmpSettingsTo = this._deepMergeObjects(tmpSettingsTo, tmpSettingsFromCopy);\n\n\t\tif (this._PerformEnvTemplating)\n\t\t{\n\t\t\tthis._resolveEnv(tmpSettingsTo);\n\t\t}\n\t\t// Update env tempating config, since we just updated the config object, and it may have changed\n\t\tthis._configureEnvTemplating(tmpSettingsTo);\n\n\t\treturn tmpSettingsTo;\n\t}\n\n\t// Fill in settings gaps without overwriting settings that are already there\n\tfill(pSettingsFrom)\n\t{\n\t\t// If an invalid settings from object is passed in (e.g. object constructor without passing in anything) this should still work\n\t\tlet tmpSettingsFrom = (typeof(pSettingsFrom) === 'object') ? pSettingsFrom : {};\n\n\t\t// do not mutate the From object property values\n\t\tlet tmpSettingsFromCopy = JSON.parse(JSON.stringify(tmpSettingsFrom));\n\n\t\tthis.settings = this._deepMergeObjects(tmpSettingsFromCopy, this.settings);\n\n\t\treturn this.settings;\n\t}\n};\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new FableSettings(pSettings);\n}\n\nmodule.exports = FableSettings;\nmodule.exports.new = autoConstruct;\nmodule.exports.precedent = libPrecedent;\n},{\"./Fable-Settings-Default\":23,\"./Fable-Settings-TemplateProcessor.js\":24,\"precedent\":29}],26:[function(require,module,exports){\n/**\n* Random Byte Generator - Browser version\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\n// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\nclass RandomBytes\n{\n\tconstructor()\n\t{\n\n\t\t// getRandomValues needs to be invoked in a context where \"this\" is a Crypto\n\t\t// implementation. Also, find the complete implementation of crypto on IE11.\n\t\tthis.getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||\n                      \t\t(typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));\n\t}\n\n\t// WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n\tgenerateWhatWGBytes()\n\t{\n\t\tlet tmpBuffer = new Uint8Array(16); // eslint-disable-line no-undef\n\n\t\tthis.getRandomValues(tmpBuffer);\n\t\treturn tmpBuffer;\n\t}\n\n\t// Math.random()-based (RNG)\n\tgenerateRandomBytes()\n\t{\n\t\t// If all else fails, use Math.random().  It's fast, but is of unspecified\n\t\t// quality.\n\t\tlet tmpBuffer = new Uint8Array(16); // eslint-disable-line no-undef\n\n\t\tfor (let i = 0, tmpValue; i < 16; i++)\n\t\t{\n\t\t\tif ((i & 0x03) === 0)\n\t\t\t{\n\t\t\t\ttmpValue = Math.random() * 0x100000000;\n\t\t\t}\n\n\t\t\ttmpBuffer[i] = tmpValue >>> ((i & 0x03) << 3) & 0xff;\n\t\t}\n\n\t\treturn tmpBuffer;\n\t}\n\n\tgenerate()\n\t{\n\t\tif (this.getRandomValues)\n\t\t{\n\t\t\treturn this.generateWhatWGBytes();\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.generateRandomBytes();\n\t\t}\n\t}\n}\n\nmodule.exports = RandomBytes;\n\n},{}],27:[function(require,module,exports){\n/**\n* Fable UUID Generator\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable UUID\n*/\n\n/**\n* Fable Solution UUID Generation Main Class\n*\n* @class FableUUID\n* @constructor\n*/\n\nvar libRandomByteGenerator = require('./Fable-UUID-Random.js')\n\nclass FableUUID\n{\n\tconstructor(pSettings)\n\t{\n\t\t// Determine if the module is in \"Random UUID Mode\" which means just use the random character function rather than the v4 random UUID spec.\n\t\t// Note this allows UUIDs of various lengths (including very short ones) although guaranteed uniqueness goes downhill fast.\n\t\tthis._UUIDModeRandom = (typeof(pSettings) === 'object') && (pSettings.hasOwnProperty('UUIDModeRandom')) ? (pSettings.UUIDModeRandom == true) : false;\n\t\t// These two properties are only useful if we are in Random mode.  Otherwise it generates a v4 spec\n\t\t// Length for \"Random UUID Mode\" is set -- if not set it to 8\n\t\tthis._UUIDLength = (typeof(pSettings) === 'object') && (pSettings.hasOwnProperty('UUIDLength')) ? (pSettings.UUIDLength + 0) : 8;\n\t\t// Dictionary for \"Random UUID Mode\"\n\t\tthis._UUIDRandomDictionary = (typeof(pSettings) === 'object') && (pSettings.hasOwnProperty('UUIDDictionary')) ? (pSettings.UUIDDictionary + 0) : '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n\n\t\tthis.randomByteGenerator = new libRandomByteGenerator();\n\n\t\t// Lookup table for hex codes\n\t\tthis._HexLookup = [];\n\t\tfor (let i = 0; i < 256; ++i)\n\t\t{\n\t\t\tthis._HexLookup[i] = (i + 0x100).toString(16).substr(1);\n\t\t}\n\t}\n\n\t// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n\tbytesToUUID(pBuffer)\n\t{\n\t\tlet i = 0;\n\t\t// join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n\t\treturn ([\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], \n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]]\n\t\t\t\t]).join('');\n\t}\n\n\t// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n\tgenerateUUIDv4()\n\t{\n\t\tlet tmpBuffer = new Array(16);\n\t\tvar tmpRandomBytes = this.randomByteGenerator.generate();\n\n\t\t// Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\t\ttmpRandomBytes[6] = (tmpRandomBytes[6] & 0x0f) | 0x40;\n\t\ttmpRandomBytes[8] = (tmpRandomBytes[8] & 0x3f) | 0x80;\n\n\t\treturn this.bytesToUUID(tmpRandomBytes);\n\t}\n\n\t// Simple random UUID generation\n\tgenerateRandom()\n\t{\n\t\tlet tmpUUID = '';\n\n\t\tfor (let i = 0; i < this._UUIDLength; i++)\n\t\t{\n\t\t\ttmpUUID += this._UUIDRandomDictionary.charAt(Math.floor(Math.random() * (this._UUIDRandomDictionary.length-1)));\n\t\t}\n\n\t\treturn tmpUUID;\n\t}\n\n\t// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n\tgetUUID()\n\t{\n\t\tif (this._UUIDModeRandom)\n\t\t{\n\t\t\treturn this.generateRandom();\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.generateUUIDv4();\n\t\t}\n\t}\n}\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new FableUUID(pSettings);\n}\n\n\nmodule.exports = FableUUID;\nmodule.exports.new = autoConstruct;\n\n},{\"./Fable-UUID-Random.js\":26}],28:[function(require,module,exports){\n(function (process){(function (){\n// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n\n}).call(this)}).call(this,require('_process'))\n\n},{\"_process\":32}],29:[function(require,module,exports){\n/**\n* Precedent Meta-Templating\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Process text streams, parsing out meta-template expressions.\n*/\nvar libWordTree = require(`./WordTree.js`);\nvar libStringParser = require(`./StringParser.js`);\n\nclass Precedent\n{\n\t/**\n\t * Precedent Constructor\n\t */\n\tconstructor()\n\t{\n\t\tthis.WordTree = new libWordTree();\n\t\t\n\t\tthis.StringParser = new libStringParser();\n\n\t\tthis.ParseTree = this.WordTree.ParseTree;\n\t}\n\t\n\t/**\n\t * Add a Pattern to the Parse Tree\n\t * @method addPattern\n\t * @param {Object} pTree - A node on the parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @param {number} pIndex - callback function\n\t * @return {bool} True if adding the pattern was successful\n\t */\n\taddPattern(pPatternStart, pPatternEnd, pParser)\n\t{\n\t\treturn this.WordTree.addPattern(pPatternStart, pPatternEnd, pParser);\n\t}\n\t\n\t/**\n\t * Parse a string with the existing parse tree\n\t * @method parseString\n\t * @param {string} pString - The string to parse\n\t * @return {string} The result from the parser\n\t */\n\tparseString(pString)\n\t{\n\t\treturn this.StringParser.parseString(pString, this.ParseTree);\n\t}\n}\n\nmodule.exports = Precedent;\n\n},{\"./StringParser.js\":30,\"./WordTree.js\":31}],30:[function(require,module,exports){\n/**\n* String Parser\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Parse a string, properly processing each matched token in the word tree.\n*/\n\nclass StringParser\n{\n\t/**\n\t * StringParser Constructor\n\t */\n\tconstructor()\n\t{\n\t}\n\t\n\t/**\n\t * Create a fresh parsing state object to work with.\n\t * @method newParserState\n\t * @param {Object} pParseTree - A node on the parse tree to begin parsing from (usually root)\n\t * @return {Object} A new parser state object for running a character parser on\n\t * @private\n\t */\n\tnewParserState (pParseTree)\n\t{\n\t\treturn (\n\t\t{\n\t\t\tParseTree: pParseTree,\n\n\t\t\tOutput: '',\n\t\t\tOutputBuffer: '',\n\n\t\t\tPattern: false,\n\n\t\t\tPatternMatch: false,\n\t\t\tPatternMatchOutputBuffer: ''\n\t\t});\n\t}\n\t\t\n\t/**\n\t * Assign a node of the parser tree to be the next potential match.\n\t * If the node has a PatternEnd property, it is a valid match and supercedes the last valid match (or becomes the initial match).\n\t * @method assignNode\n\t * @param {Object} pNode - A node on the parse tree to assign\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tassignNode (pNode, pParserState)\n\t{\n\t\tpParserState.PatternMatch = pNode;\n\n\t\t// If the pattern has a END we can assume it has a parse function...\n\t\tif (pParserState.PatternMatch.hasOwnProperty('PatternEnd'))\n\t\t{\n\t\t\t// ... this is the legitimate start of a pattern.\n\t\t\tpParserState.Pattern = pParserState.PatternMatch;\n\t\t}\n\t}\n\t\n\t/**\n\t * Append a character to the output buffer in the parser state.\n\t * This output buffer is used when a potential match is being explored, or a match is being explored.\n\t * @method appendOutputBuffer\n\t * @param {string} pCharacter - The character to append\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tappendOutputBuffer (pCharacter, pParserState)\n\t{\n\t\tpParserState.OutputBuffer += pCharacter;\n\t}\n\t\n\t/**\n\t * Flush the output buffer to the output and clear it.\n\t * @method flushOutputBuffer\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tflushOutputBuffer (pParserState)\n\t{\n\t\tpParserState.Output += pParserState.OutputBuffer;\n\t\tpParserState.OutputBuffer = '';\n\t}\n\n\t\n\t/**\n\t * Check if the pattern has ended.  If it has, properly flush the buffer and start looking for new patterns.\n\t * @method checkPatternEnd\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tcheckPatternEnd (pParserState)\n\t{\n\t\tif ((pParserState.OutputBuffer.length >= pParserState.Pattern.PatternEnd.length+pParserState.Pattern.PatternStart.length) && \n\t\t\t(pParserState.OutputBuffer.substr(-pParserState.Pattern.PatternEnd.length) === pParserState.Pattern.PatternEnd))\n\t\t{\n\t\t\t// ... this is the end of a pattern, cut off the end tag and parse it.\n\t\t\t// Trim the start and end tags off the output buffer now\n\t\t\tpParserState.OutputBuffer = pParserState.Pattern.Parse(pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStart.length, pParserState.OutputBuffer.length - (pParserState.Pattern.PatternStart.length+pParserState.Pattern.PatternEnd.length)));\n\t\t\t// Flush the output buffer.\n\t\t\tthis.flushOutputBuffer(pParserState);\n\t\t\t// End pattern mode\n\t\t\tpParserState.Pattern = false;\n\t\t\tpParserState.PatternMatch = false;\n\t\t}\n\t}\n\t\n\t/**\n\t * Parse a character in the buffer.\n\t * @method parseCharacter\n\t * @param {string} pCharacter - The character to append\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tparseCharacter (pCharacter, pParserState)\n\t{\n\t\t// (1) If we aren't in a pattern match, and we aren't potentially matching, and this may be the start of a new pattern....\n\t\tif (!pParserState.PatternMatch && pParserState.ParseTree.hasOwnProperty(pCharacter))\n\t\t{\n\t\t\t// ... assign the node as the matched node.\n\t\t\tthis.assignNode(pParserState.ParseTree[pCharacter], pParserState);\n\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t}\n\t\t// (2) If we are in a pattern match (actively seeing if this is part of a new pattern token)\n\t\telse if (pParserState.PatternMatch)\n\t\t{\n\t\t\t// If the pattern has a subpattern with this key\n\t\t\tif (pParserState.PatternMatch.hasOwnProperty(pCharacter))\n\t\t\t{\n\t\t\t\t// Continue matching patterns.\n\t\t\t\tthis.assignNode(pParserState.PatternMatch[pCharacter], pParserState);\n\t\t\t}\n\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\tif (pParserState.Pattern)\n\t\t\t{\n\t\t\t\t// ... Check if this is the end of the pattern (if we are matching a valid pattern)...\n\t\t\t\tthis.checkPatternEnd(pParserState);\n\t\t\t}\n\t\t}\n\t\t// (3) If we aren't in a pattern match or pattern, and this isn't the start of a new pattern (RAW mode)....\n\t\telse\n\t\t{\n\t\t\tpParserState.Output += pCharacter;\n\t\t}\n\t}\n\t\n\t/**\n\t * Parse a string for matches, and process any template segments that occur.\n\t * @method parseString\n\t * @param {string} pString - The string to parse.\n\t * @param {Object} pParseTree - The parse tree to begin parsing from (usually root)\n\t */\n\tparseString (pString, pParseTree)\n\t{\n\t\tlet tmpParserState = this.newParserState(pParseTree);\n\n\t\tfor (var i = 0; i < pString.length; i++)\n\t\t{\n\t\t\t// TODO: This is not fast.\n\t\t\tthis.parseCharacter(pString[i], tmpParserState);\n\t\t}\n\t\t\n\t\tthis.flushOutputBuffer(tmpParserState);\n\t\t\n\t\treturn tmpParserState.Output;\n\t}\n}\n\nmodule.exports = StringParser;\n\n},{}],31:[function(require,module,exports){\n/**\n* Word Tree\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Create a tree (directed graph) of Javascript objects, one character per object.\n*/\n\nclass WordTree\n{\n\t/**\n\t * WordTree Constructor\n\t */\n\tconstructor()\n\t{\n\t\tthis.ParseTree = {};\n\t}\n\t\n\t/** \n\t * Add a child character to a Parse Tree node\n\t * @method addChild\n\t * @param {Object} pTree - A parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @param {number} pIndex - The index of the character in the pattern\n\t * @returns {Object} The resulting leaf node that was added (or found)\n\t * @private\n\t */\n\taddChild (pTree, pPattern, pIndex)\n\t{\n\t\tif (!pTree.hasOwnProperty(pPattern[pIndex]))\n\t\t\tpTree[pPattern[pIndex]] = {};\n\t\t\n\t\treturn pTree[pPattern[pIndex]];\n\t}\n\t\n\t/** Add a Pattern to the Parse Tree\n\t * @method addPattern\n\t * @param {Object} pPatternStart - The starting string for the pattern (e.g. \"${\")\n\t * @param {string} pPatternEnd - The ending string for the pattern (e.g. \"}\")\n\t * @param {number} pParser - The function to parse if this is the matched pattern, once the Pattern End is met.  If this is a string, a simple replacement occurs.\n\t * @return {bool} True if adding the pattern was successful\n\t */\n\taddPattern (pPatternStart, pPatternEnd, pParser)\n\t{\n\t\tif (pPatternStart.length < 1)\n\t\t\treturn false;\n\n\t\tif ((typeof(pPatternEnd) === 'string') && (pPatternEnd.length < 1))\n\t\t\treturn false;\n\n\t\tlet tmpLeaf = this.ParseTree;\n\n\t\t// Add the tree of leaves iteratively\n\t\tfor (var i = 0; i < pPatternStart.length; i++)\n\t\t\ttmpLeaf = this.addChild(tmpLeaf, pPatternStart, i);\n\n\t\ttmpLeaf.PatternStart = pPatternStart;\n\t\ttmpLeaf.PatternEnd = ((typeof(pPatternEnd) === 'string') && (pPatternEnd.length > 0)) ? pPatternEnd : pPatternStart;\n\t\ttmpLeaf.Parse = (typeof(pParser) === 'function') ? pParser : \n\t\t\t\t\t\t(typeof(pParser) === 'string') ? () => { return pParser; } :\n\t\t\t\t\t\t(pData) => { return pData; };\n\n\t\treturn true;\n\t}\n}\n\nmodule.exports = WordTree;\n\n},{}],32:[function(require,module,exports){\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],33:[function(require,module,exports){\n(function (setImmediate,clearImmediate){(function (){\nvar nextTick = require('process/browser.js').nextTick;\nvar apply = Function.prototype.apply;\nvar slice = Array.prototype.slice;\nvar immediateIds = {};\nvar nextImmediateId = 0;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) { timeout.close(); };\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// That's not how node.js implements it but the exposed api is the same.\nexports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n  var id = nextImmediateId++;\n  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n  immediateIds[id] = true;\n\n  nextTick(function onNextTick() {\n    if (immediateIds[id]) {\n      // fn.call() is faster so we optimize for the common use-case\n      // @see http://jsperf.com/call-apply-segu\n      if (args) {\n        fn.apply(null, args);\n      } else {\n        fn.call(null);\n      }\n      // Prevent ids from leaking\n      exports.clearImmediate(id);\n    }\n  });\n\n  return id;\n};\n\nexports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n  delete immediateIds[id];\n};\n}).call(this)}).call(this,require(\"timers\").setImmediate,require(\"timers\").clearImmediate)\n\n},{\"process/browser.js\":32,\"timers\":33}],34:[function(require,module,exports){\nvar libNPMModuleWrapper = require('./Fable.js');\n\nif ((typeof(window) === 'object') && !window.hasOwnProperty('Fable'))\n{\n\twindow.Fable = libNPMModuleWrapper;\n}\n\nmodule.exports = libNPMModuleWrapper;\n},{\"./Fable.js\":40}],35:[function(require,module,exports){\nconst _OperationStatePrototype = JSON.stringify(\n{\n\t\"Metadata\": {\n\t\t\"GUID\": false,\n\t\t\"Hash\": false,\n\n\t\t\"Title\": \"\",\n\t\t\"Summary\": \"\",\n\n\t\t\"Version\": 0\n\t},\n\t\"Status\": {\n        \"Completed\": false,\n\n        \"CompletionProgress\": 0,\n        \"CompletionTimeElapsed\": 0,\n\n        \"Steps\": 1,\n        \"StepsCompleted\": 0,\n\n        \"StartTime\": 0,\n        \"EndTime\": 0\n\t},\n\t\"Errors\": [],\n\t\"Log\": []\n});\n\nclass FableOperation\n{\n\tconstructor(pFable, pOperationName, pOperationHash)\n\t{\n\t\tthis.fable = pFable;\n\n\t\tthis.name = pOperationName;\n\n\t\tthis.state = JSON.parse(_OperationStatePrototype);\n\n\t\tthis.state.Metadata.GUID = this.fable.getUUID();\n\t\tthis.state.Metadata.Hash = this.state.GUID;\n\n\t\tif (typeof(pOperationHash) == 'string')\n\t\t{\n\t\t\tthis.state.Metadata.Hash = pOperationHash;\n\t\t}\n\t}\n\n\tget GUID()\n\t{\n\t\treturn this.state.Metadata.GUID;\n\t}\n\n\tget Hash()\n\t{\n\t\treturn this.state.Metadata.Hash;\n\t}\n\n\tget log()\n\t{\n\t\treturn this;\n\t}\n\n\twriteOperationLog(pLogLevel, pLogText, pLogObject)\n\t{\n\t\tthis.state.Log.push(`${new Date().toUTCString()} [${pLogLevel}]: ${pLogText}`);\n\n\t\tif (typeof(pLogObject) == 'object')\n\t\t{\n\t\t\tthis.state.Log.push(JSON.stringify(pLogObject));\n\t\t}\n\t}\n\n\twriteOperationErrors(pLogText, pLogObject)\n\t{\n\t\tthis.state.Errors.push(`${pLogText}`);\n\n\t\tif (typeof(pLogObject) == 'object')\n\t\t{\n\t\t\tthis.state.Errors.push(JSON.stringify(pLogObject));\n\t\t}\n\t}\n\n\ttrace(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('TRACE', pLogText, pLogObject);\n\t\tthis.fable.log.trace(pLogText, pLogObject);\n\t}\n\n\tdebug(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('DEBUG', pLogText, pLogObject);\n\t\tthis.fable.log.debug(pLogText, pLogObject);\n\t}\n\n\tinfo(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('INFO', pLogText, pLogObject);\n\t\tthis.fable.log.info(pLogText, pLogObject);\n\t}\n\n\twarn(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('WARN', pLogText, pLogObject);\n\t\tthis.fable.log.warn(pLogText, pLogObject);\n\t}\n\n\terror(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('ERROR', pLogText, pLogObject);\n\t\tthis.writeOperationErrors(pLogText, pLogObject);\n\t\tthis.fable.log.error(pLogText, pLogObject);\n\t}\n\n\tfatal(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('FATAL', pLogText, pLogObject);\n\t\tthis.writeOperationErrors(pLogText, pLogObject);\n\t\tthis.fable.log.fatal(pLogText, pLogObject);\n\t}\n}\n\nmodule.exports = FableOperation;\n},{}],36:[function(require,module,exports){\nconst libFableServiceBase = require('./Fable-ServiceProviderBase.js');\n\nclass FableServiceTemplate extends libFableServiceBase\n{\n\t// Underscore and lodash have a behavior, _.template, which compiles a\n\t// string-based template with code snippets into simple executable pieces,\n\t// with the added twist of returning a precompiled function ready to go.\n\t//\n\t// NOTE: This does not implement underscore escape expressions\n\t// NOTE: This does not implement underscore magic browser variable assignment\n\t//\n\t// This is an implementation of that.\n\t// TODO: Make this use precedent, add configuration, add debugging.\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n        super(pFable, pOptions, pServiceHash);\n\n        this.serviceType = 'Template';\n\n\t\t// These are the exact regex's used in lodash/underscore\n\t\t// TODO: Switch this to precedent\n\t\tthis.Matchers = (\n\t\t\t{\n\t\t\t\tEvaluate: /<%([\\s\\S]+?)%>/g,\n\t\t\t\tInterpolate: /<%=([\\s\\S]+?)%>/g,\n\t\t\t\tEscaper: /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g,\n\t\t\t\tUnescaper: /\\\\(\\\\|'|r|n|t|u2028|u2029)/g,\n\t\t\t\t// This is how underscore does it, so we are keeping it for now.\n\t\t\t\tGuaranteedNonMatch: /.^/\n\t\t\t});\n\n\t\t// This is a helper for the escaper and unescaper functions.\n\t\t// Right now we are going to keep what underscore is doing, but, not forever.\n\t\tthis.templateEscapes = {\n\t\t\t'\\\\': '\\\\',\n\t\t\t\"'\": \"'\",\n\t\t\t'r': '\\r',\n\t\t\t'\\r': 'r',\n\t\t\t'n': '\\n',\n\t\t\t'\\n': 'n',\n\t\t\t't': '\\t',\n\t\t\t'\\t': 't',\n\t\t\t'u2028': '\\u2028',\n\t\t\t'\\u2028': 'u2028',\n\t\t\t'u2029': '\\u2029',\n\t\t\t'\\u2029': 'u2029'\n\t\t};\n\n\t\t// This is defined as such to underscore that it is a dynamic programming\n\t\t// function on this class.\n\t\tthis.renderFunction = false;\n        this.templateString = false;\n\t}\n\n\trenderTemplate(pData)\n\t{\n\t\treturn this.renderFunction(pData);\n\t}\n\n\ttemplateFunction(pData)\n\t{\n\t\tlet fRenderTemplateBound = this.renderTemplate.bind(this);\n\t\treturn fRenderTemplateBound;\n\t}\n\n\tbuildTemplateFunction(pTemplateText, pData)\n\t{\n\t\t// For now this is being kept in a weird form ... this is to mimic the old\n\t\t// underscore code until this is rewritten using precedent.\n\t\tthis.TemplateSource = \"__p+='\" + pTemplateText\n\t\t\t.replace(this.Matchers.Escaper,\n\t\t\t\t(pMatch)=>\n\t\t\t\t{\n\t\t\t\t\treturn `\\\\${this.templateEscapes[pMatch]}`;\n\t\t\t\t})\n\t\t\t.replace(this.Matchers.Interpolate || this.Matchers.GuaranteedNonMatch,\n\t\t\t\t(pMatch, pCode) =>\n\t\t\t\t{\n\t\t\t\t\treturn `'+\\n(${decodeURIComponent(pCode)})+\\n'`;\n\t\t\t\t})\n\t\t\t.replace(this.Matchers.Evaluate || this.Matchers.GuaranteedNonMatch,\n\t\t\t\t(pMatch, pCode) =>\n\t\t\t\t{\n\t\t\t\t\treturn `';\\n${decodeURIComponent(pCode)}\\n;__p+='`;\n\t\t\t\t}) + `';\\n`;\n\n\n\t\tthis.TemplateSource = `with(pTemplateDataObject||{}){\\n${this.TemplateSource}}\\n`;\n\t\tthis.TemplateSource = `var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};\\n${this.TemplateSource}return __p;\\n`;\n\n\t\tthis.renderFunction = new Function('pTemplateDataObject', this.TemplateSource);\n\n\t\tif (typeof(pData) != 'undefined')\n\t\t{\n\t\t\treturn this.renderFunction(pData);\n\t\t}\n\n\t\t// Provide the compiled function source as a convenience for build time\n\t\t// precompilation.\n\t\tthis.TemplateSourceCompiled = 'function(obj){\\n' + this.TemplateSource + '}';\n\n\t\treturn this.templateFunction();\n\t}\n}\n\nmodule.exports = FableServiceTemplate;\n},{\"./Fable-ServiceProviderBase.js\":38}],37:[function(require,module,exports){\n/**\n* Fable Application Services Management\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\nconst libFableServiceBase = require('./Fable-ServiceProviderBase.js');\n\nclass FableService\n{\n\tconstructor(pFable)\n\t{\n\t\tthis.fable = pFable;\n\n\t\tthis.serviceTypes = [];\n\n\t\t// A map of instantiated services\n\t\tthis.services = {};\n\n\t\t// A map of the default instantiated service by type\n\t\tthis.defaultServices = {};\n\n\t\t// A map of class constructors for services\n\t\tthis.serviceClasses = {};\n\t}\n\n\taddServiceType(pServiceType, pServiceClass)\n\t{\n\t\t// Add the type to the list of types\n\t\tthis.serviceTypes.push(pServiceType);\n\n\t\t// Add the container for instantiated services to go in\n\t\tthis.services[pServiceType] = {};\n\n\t\tif ((typeof(pServiceClass) == 'function') && (pServiceClass.prototype instanceof libFableServiceBase))\n\t\t{\n\t\t\t// Add the class to the list of classes\n\t\t\tthis.serviceClasses[pServiceType] = pServiceClass;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Add the base class to the list of classes\n\t\t\tthis.serviceClasses[pServiceType] = libFableServiceBase;\n\t\t}\n\t}\n\n\tinstantiateServiceProvider(pServiceType, pOptions, pCustomServiceHash)\n\t{\n\t\t// Instantiate the service\n\t\tlet tmpService = this.instantiateServiceProviderWithoutRegistration(pServiceType, pOptions, pCustomServiceHash);\n\n\t\t// Add the service to the service map\n\t\tthis.services[pServiceType][tmpService.Hash] = tmpService;\n\n\t\t// If this is the first service of this type, make it the default\n\t\tif (!this.defaultServices.hasOwnProperty(pServiceType))\n\t\t{\n\t\t\tthis.defaultServices[pServiceType] = tmpService;\n\t\t}\n\n\t\treturn tmpService;\n\t}\n\n\t// Create a service provider but don't register it to live forever in fable.services\n\tinstantiateServiceProviderWithoutRegistration(pServiceType, pOptions, pCustomServiceHash)\n\t{\n\t\t// Instantiate the service\n\t\tlet tmpService = new this.serviceClasses[pServiceType](this.fable, pOptions, pCustomServiceHash);\n\t\treturn tmpService;\n\t}\n\n\tsetDefaultServiceInstantiation(pServiceType, pServiceHash)\n\t{\n\t\tif (this.services[pServiceType].hasOwnProperty(pServiceHash))\n\t\t{\n\t\t\tthis.defaultServices[pServiceType] = this.services[pServiceType][pServiceHash];\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n}\n\nmodule.exports = FableService;\n\nmodule.exports.ServiceProviderBase = libFableServiceBase;\n},{\"./Fable-ServiceProviderBase.js\":38}],38:[function(require,module,exports){\n/**\n* Fable Service Base\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\nclass FableServiceProviderBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tthis.fable = pFable;\n\n\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions : {};\n\n        this.serviceType = 'Unknown';\n\n        this.UUID = pFable.getUUID();\n\n        this.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash : `${this.UUID}`;\n\t}\n}\n\nmodule.exports = FableServiceProviderBase;\n\n},{}],39:[function(require,module,exports){\n// TODO: These are still pretty big -- consider the smaller polyfills\nconst libAsyncWaterfall = require('async.waterfall');\nconst libAsyncEachLimit = require('async.eachlimit');\n\nclass FableUtility\n{\n\tconstructor(pFable)\n\t{\n\t\tthis.fable = pFable;\n\n\t\tthis.templates = {};\n\n\t\t// These two functions are used extensively throughout\n\t\tthis.waterfall = libAsyncWaterfall;\n\t\tthis.eachLimit = libAsyncEachLimit;\n\t}\n\n\t// Underscore and lodash have a behavior, _.extend, which merges objects.\n\t// Now that es6 gives us this, use the native thingy.\n\textend(pDestinationObject, ...pSourceObjects)\n\t{\n\t\treturn Object.assign(pDestinationObject, ...pSourceObjects);\n\t}\n\n\t// Underscore and lodash have a behavior, _.template, which compiles a\n\t// string-based template with code snippets into simple executable pieces,\n\t// with the added twist of returning a precompiled function ready to go.\n\ttemplate(pTemplateText, pData)\n\t{\n\t\tlet tmpTemplate = this.fable.serviceManager.instantiateServiceProviderWithoutRegistration('Template');\n\n\t\treturn tmpTemplate.buildTemplateFunction(pTemplateText, pData);\n\t}\n\n\t// Build a template function from a template hash, and, register it with the service provider\n\tbuildHashedTemplate(pTemplateHash, pTemplateText, pData)\n\t{\n\t\tlet tmpTemplate = this.fable.serviceManager.instantiateServiceProvider('Template', {}, pTemplateHash);\n\n\t\tthis.templates[pTemplateHash] = tmpTemplate.buildTemplateFunction(pTemplateText, pData);\n\n\t\treturn this.templates[pTemplateHash];\n\t}\n\n\t// This is a safe, modern version of chunk from underscore\n\t// Algorithm pulled from a mix of these two polyfills:\n\t// https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_chunk\n\t// https://youmightnotneed.com/lodash\n\t// This implementation was most tolerant in browsers.  Uglify can fix the rest.\n\tchunk (pInput, pChunkSize, pChunkCache)\n\t{\n\t\tlet tmpInputArray = [...pInput];\n\t\t// Note lodash defaults to 1, underscore defaults to 0\n\t\tlet tmpChunkSize = (typeof(pChunkSize) == 'number') ? pChunkSize : 0;\n\t\tlet tmpChunkCache = (typeof(pChunkCache) != 'undefined') ? pChunkCache : [];\n\n\t\tif (tmpChunkSize <= 0)\n\t\t{\n\t\t\treturn tmpChunkCache;\n\t\t}\n\n\t\twhile (tmpInputArray.length)\n\t\t{\n\t\t\ttmpChunkCache.push(tmpInputArray.splice(0, tmpChunkSize));\n\t\t}\n\n\t\treturn tmpChunkCache;\n\t}\n}\n\nmodule.exports = FableUtility;\n},{\"async.eachlimit\":1,\"async.waterfall\":15}],40:[function(require,module,exports){\n/**\n* Fable Application Services Support Library\n* @license MIT\n* @author <steven@velozo.com>\n*/\nconst libFableSettings = require('fable-settings');\nconst libFableUUID = require('fable-uuid');\nconst libFableLog = require('fable-log');\n\nconst libFableUtility = require('./Fable-Utility.js');\nconst libFableServiceManager = require('./Fable-ServiceManager.js');\n\nconst libFableServiceTemplate = require('./Fable-Service-Template.js');\n\nconst libFableOperation = require('./Fable-Operation.js');\n\nclass Fable\n{\n\tconstructor(pSettings)\n\t{\n\t\tlet tmpSettings = new libFableSettings(pSettings);\n\n\t\tthis.settingsManager = tmpSettings;\n\n\t\t// Instantiate the UUID generator\n\t\tthis.libUUID = new libFableUUID(this.settingsManager.settings);\n\n\t\tthis.log = new libFableLog(this.settingsManager.settings);\n\t\tthis.log.initialize();\n\n\t\t// Built-in utility belt functions\n\t\tthis.Utility = new libFableUtility(this);\n\n\t\t// Built-in dependencies\n\t\tthis.Dependencies = (\n\t\t\t{\n\t\t\t\tprecedent: libFableSettings.precedent\n\t\t\t});\n\n\t\t// Location for Operation state\n\t\tthis.Operations = {};\n\n\t\tthis.serviceManager = new libFableServiceManager(this);\n\n\t\tthis.serviceManager.addServiceType('Template', libFableServiceTemplate);\n\n\t\tthis.services = this.serviceManager.services;\n\t\tthis.defaultServices = this.serviceManager.defaultServices;\n\t}\n\n\tget settings()\n\t{\n\t\treturn this.settingsManager.settings;\n\t}\n\n\tget fable()\n\t{\n\t\treturn this;\n\t}\n\n\tgetUUID()\n\t{\n\t\treturn this.libUUID.getUUID();\n\t}\n\n\tcreateOperation(pOperationName, pOperationHash)\n\t{\n\t\tlet tmpOperation = new libFableOperation(this, pOperationName, pOperationHash);\n\n\t\tif (this.Operations.hasOwnProperty(tmpOperation.Hash))\n\t\t{\n\t\t\t// Uh Oh ...... Operation Hash Collision!\n\t\t\t// TODO: What to do?!\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.Operations[tmpOperation.Hash] = tmpOperation;\n\t\t}\n\n\t\treturn tmpOperation;\n\t}\n\n\tgetOperation(pOperationHash)\n\t{\n\t\tif (!this.Operations.hasOwnProperty(pOperationHash))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.Operations[pOperationHash];\n\t\t}\n\t}\n}\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new Fable(pSettings);\n}\n\nmodule.exports = Fable;\nmodule.exports.new = autoConstruct;\n\nmodule.exports.LogProviderBase = libFableLog.LogProviderBase;\nmodule.exports.ServiceProviderBase = libFableServiceManager.ServiceProviderBase;\n\nmodule.exports.precedent = libFableSettings.precedent;\n},{\"./Fable-Operation.js\":35,\"./Fable-Service-Template.js\":36,\"./Fable-ServiceManager.js\":37,\"./Fable-Utility.js\":39,\"fable-log\":22,\"fable-settings\":25,\"fable-uuid\":27}]},{},[34])(34)\n});\n\n","(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","'use strict';\n\nvar eachOfLimit = require('async.util.eachoflimit');\nvar withoutIndex = require('async.util.withoutindex');\n\nmodule.exports = function eachLimit(arr, limit, iterator, cb) {\n    return eachOfLimit(limit)(arr, withoutIndex(iterator), cb);\n};\n","'use strict';\n\nmodule.exports = function(tasks) {\n    function makeCallback(index) {\n        function fn() {\n            if (tasks.length) {\n                tasks[index].apply(null, arguments);\n            }\n            return fn.next();\n        }\n        fn.next = function() {\n            return (index < tasks.length - 1) ? makeCallback(index + 1) : null;\n        };\n        return fn;\n    }\n    return makeCallback(0);\n};\n","var once = require('async.util.once');\nvar noop = require('async.util.noop');\nvar onlyOnce = require('async.util.onlyonce');\nvar keyIterator = require('async.util.keyiterator');\n\nmodule.exports = function eachOfLimit(limit) {\n    return function(obj, iterator, cb) {\n        cb = once(cb || noop);\n        obj = obj || [];\n        var nextKey = keyIterator(obj);\n        if (limit <= 0) {\n            return cb(null);\n        }\n        var done = false;\n        var running = 0;\n        var errored = false;\n\n        (function replenish() {\n            if (done && running <= 0) {\n                return cb(null);\n            }\n\n            while (running < limit && !errored) {\n                var key = nextKey();\n                if (key === null) {\n                    done = true;\n                    if (running <= 0) {\n                        cb(null);\n                    }\n                    return;\n                }\n                running += 1;\n                iterator(obj[key], key, onlyOnce(function(err) {\n                    running -= 1;\n                    if (err) {\n                        cb(err);\n                        errored = true;\n                    } else {\n                        replenish();\n                    }\n                }));\n            }\n        })();\n    };\n};\n","'use strict';\nvar setImmediate = require('async.util.setimmediate');\nvar restParam = require('async.util.restparam');\n\nmodule.exports = function(fn) {\n    return restParam(function(args) {\n        var callback = args.pop();\n        args.push(function() {\n            var innerArgs = arguments;\n            if (sync) {\n                setImmediate(function() {\n                    callback.apply(null, innerArgs);\n                });\n            } else {\n                callback.apply(null, innerArgs);\n            }\n        });\n        var sync = true;\n        fn.apply(this, args);\n        sync = false;\n    });\n};\n","'use strict';\n\nmodule.exports = Array.isArray || function isArray(obj) {\n    return Object.prototype.toString.call(obj) === '[object Array]';\n};\n","'use strict';\n\nvar isArray = require('async.util.isarray');\n\nmodule.exports = function isArrayLike(arr) {\n    return isArray(arr) || (\n        // has a positive integer length property\n        typeof arr.length === 'number' &&\n        arr.length >= 0 &&\n        arr.length % 1 === 0\n    );\n};\n","'use strict';\n\nvar _keys = require('async.util.keys');\nvar isArrayLike = require('async.util.isarraylike');\n\nmodule.exports = function keyIterator(coll) {\n    var i = -1;\n    var len;\n    var keys;\n    if (isArrayLike(coll)) {\n        len = coll.length;\n        return function next() {\n            i++;\n            return i < len ? i : null;\n        };\n    } else {\n        keys = _keys(coll);\n        len = keys.length;\n        return function next() {\n            i++;\n            return i < len ? keys[i] : null;\n        };\n    }\n};\n","'use strict';\n\nmodule.exports = Object.keys || function keys(obj) {\n    var _keys = [];\n    for (var k in obj) {\n        if (obj.hasOwnProperty(k)) {\n            _keys.push(k);\n        }\n    }\n    return _keys;\n};\n","'use strict';\n\nmodule.exports = function noop () {};\n","'use strict';\n\nmodule.exports = function once(fn) {\n    return function() {\n        if (fn === null) return;\n        fn.apply(this, arguments);\n        fn = null;\n    };\n};\n","'use strict';\n\nmodule.exports = function only_once(fn) {\n    return function() {\n        if (fn === null) throw new Error('Callback was already called.');\n        fn.apply(this, arguments);\n        fn = null;\n    };\n};\n","'use strict';\nmodule.exports = function restParam(func, startIndex) {\n    startIndex = startIndex == null ? func.length - 1 : +startIndex;\n    return function() {\n        var length = Math.max(arguments.length - startIndex, 0);\n        var rest = new Array(length);\n        for (var index = 0; index < length; index++) {\n            rest[index] = arguments[index + startIndex];\n        }\n        switch (startIndex) {\n            case 0:\n                return func.call(this, rest);\n            case 1:\n                return func.call(this, arguments[0], rest);\n        }\n    };\n};\n","'use strict';\n\nvar _setImmediate = typeof setImmediate === 'function' && setImmediate;\nvar fallback = function(fn) {\n    setTimeout(fn, 0);\n};\n\nmodule.exports = function setImmediate(fn) {\n    // not a direct alias for IE10 compatibility\n    return (_setImmediate || fallback)(fn);\n};\n","'use strict';\n\nmodule.exports = function withoutIndex(iterator) {\n    return function(value, index, callback) {\n        return iterator(value, callback);\n    };\n};\n","'use strict';\n\nvar once = require('async.util.once');\nvar noop = require('async.util.noop');\nvar isArray = require('async.util.isarray');\nvar restParam = require('async.util.restparam');\nvar ensureAsync = require('async.util.ensureasync');\nvar iterator = require('async.iterator');\n\nmodule.exports = function(tasks, cb) {\n    cb = once(cb || noop);\n    if (!isArray(tasks)) return cb(new Error('First argument to waterfall must be an array of functions'));\n    if (!tasks.length) return cb();\n\n    function wrapIterator(iterator) {\n        return restParam(function(err, args) {\n            if (err) {\n                cb.apply(null, [err].concat(args));\n            } else {\n                var next = iterator.next();\n                if (next) {\n                    args.push(wrapIterator(next));\n                } else {\n                    args.push(cb);\n                }\n                ensureAsync(iterator).apply(null, args);\n            }\n        });\n    }\n    wrapIterator(iterator(tasks))();\n};\n","/**\n* Base Logger Class\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\nclass BaseLogger\n{\n\tconstructor(pLogStreamSettings, pFableLog)\n\t{\n\t\t// This should not possibly be able to be instantiated without a settings object\n\t\tthis._Settings = (typeof(pLogStreamSettings) == 'object') ? pLogStreamSettings : {};\n\n\t\t// The base logger does nothing but associate a UUID with itself\n\t\t// We added this as the mechanism for tracking loggers to allow multiple simultaneous streams\n\t\t// to the same provider.\n\t\tthis.loggerUUID = this.generateInsecureUUID();\n\n\t\t// Eventually we can use this array to ompute which levels the provider allows.\n\t\t// For now it's just used to precompute some string concatenations.\n\t\tthis.levels = (\n\t\t\t[\n\t\t\t\t\"trace\",\n\t\t\t\t\"debug\",\n\t\t\t\t\"info\",\n\t\t\t\t\"warn\",\n\t\t\t\t\"error\",\n\t\t\t\t\"fatal\"\n\t\t\t]);\n\t}\n\n\t// This is meant to generate programmatically insecure UUIDs to identify loggers\n\tgenerateInsecureUUID()\n\t{\n\t\tlet tmpDate = new Date().getTime();\n\t\tlet tmpUUID = 'LOGSTREAM-xxxxxx-yxxxxx'.replace(/[xy]/g,\n\t\t\t\t(pCharacter) =>\n\t\t\t\t{\n\t\t\t\t\t// Funny algorithm from w3resource that is twister-ish without the deep math and security\n\t\t\t\t\t// ..but good enough for unique log stream identifiers\n\t\t\t\t\tlet tmpRandomData = (tmpDate + Math.random()*16)%16 | 0;\n\t\t\t\t\ttmpDate = Math.floor(tmpDate/16);\n\n\t\t\t\t\treturn (pCharacter =='x' ? tmpRandomData : (tmpRandomData&0x3|0x8)).toString(16);\n\t\t\t\t});\n\t\treturn tmpUUID;\n\t}\n\n\tinitialize()\n\t{\n\t\t// No operation.\n\t}\n\n\ttrace(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"trace\", pLogText, pLogObject);\n\t}\n\n\tdebug(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"debug\", pLogText, pLogObject);\n\t}\n\n\tinfo(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"info\", pLogText, pLogObject);\n\t}\n\n\twarn(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"warn\", pLogText, pLogObject);\n\t}\n\n\terror(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"error\", pLogText, pLogObject);\n\t}\n\n\tfatal(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"fatal\", pLogText, pLogObject);\n\t}\n\n\twrite(pLogLevel, pLogText, pLogObject)\n\t{\n\t\t// The base logger does nothing.\n\t\treturn true;\n\t}\n}\n\nmodule.exports = BaseLogger;\n","/**\n* Default Logger Provider Function\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\n// Return the providers that are available without extensions loaded\ngetDefaultProviders = () =>\n{\n\tlet tmpDefaultProviders = {};\n\n\ttmpDefaultProviders.console = require('./Fable-Log-Logger-Console.js');\n\n\ttmpDefaultProviders.default = tmpDefaultProviders.console;\n\n\treturn tmpDefaultProviders;\n}\n\nmodule.exports = getDefaultProviders();","module.exports=[\n    {\n        \"loggertype\": \"console\",\n        \"streamtype\": \"console\",\n        \"level\": \"trace\"\n    }\n]","let libBaseLogger = require('./Fable-Log-BaseLogger.js');\n\nclass ConsoleLogger extends libBaseLogger\n{\n\tconstructor(pLogStreamSettings, pFableLog)\n\t{\n\t\tsuper(pLogStreamSettings);\n\n\t\tthis._ShowTimeStamps = this._Settings.hasOwnProperty('showtimestamps') ? (this._Settings.showtimestamps == true) : true;\n\t\tthis._FormattedTimeStamps = this._Settings.hasOwnProperty('formattedtimestamps') ? (this._Settings.formattedtimestamps == true) : true;\n\n\t\tthis._ContextMessage = this._Settings.hasOwnProperty('Context') ? `(${this._Settings.Context})` : \n\t\t\t\t\t\t\t\tpFableLog._Settings.hasOwnProperty('Product') ? `(${pFableLog._Settings.Product})` :\n\t\t\t\t\t\t\t\t'Unnamed_Log_Context';\n\n\t\t// Allow the user to decide what gets output to the console\n\t\tthis._OutputLogLinesToConsole = this._Settings.hasOwnProperty('outputloglinestoconsole') ? this._Settings.outputloglinestoconsole : true;\n\t\tthis._OutputObjectsToConsole = this._Settings.hasOwnProperty('outputobjectstoconsole') ? this._Settings.outputobjectstoconsole : true;\n\n\t\t// Precompute the prefix for each level\n\t\tthis.prefixCache = {};\n\t\tfor (let i = 0; i <= this.levels.length; i++)\n\t\t{\n\t\t\tthis.prefixCache[this.levels[i]] = `[${this.levels[i]}] ${this._ContextMessage}: `;\n\n\t\t\tif (this._ShowTimeStamps)\n\t\t\t{\n\t\t\t\t// If there is a timestamp we need a to prepend space before the prefixcache string, since the timestamp comes first\n\t\t\t\tthis.prefixCache[this.levels[i]] = ' '+this.prefixCache[this.levels[i]];\n\t\t\t}\n\t\t}\n\t}\n\n\twrite(pLevel, pLogText, pObject)\n\t{\n\t\tlet tmpTimeStamp = '';\n\t\tif (this._ShowTimeStamps && this._FormattedTimeStamps)\n\t\t{\n\t\t\ttmpTimeStamp = (new Date()).toISOString();\n\t\t}\n\t\telse if (this._ShowTimeStamps)\n\t\t{\n\t\t\ttmpTimeStamp = +new Date();\n\t\t}\n\n\t\tlet tmpLogLine = `${tmpTimeStamp}${this.prefixCache[pLevel]}${pLogText}`;\n\n\t\tif (this._OutputLogLinesToConsole)\n\t\t{\n\t\t\tconsole.log(tmpLogLine);\n\t\t}\n\n\t\t// Write out the object on a separate line if it is passed in\n\t\tif (this._OutputObjectsToConsole && (typeof(pObject) !== 'undefined'))\n\t\t{\n\t\t\tconsole.log(JSON.stringify(pObject, null, 2));\n\t\t}\n\n\t\t// Provide an easy way to be overridden and be consistent\n\t\treturn tmpLogLine;\n\t}\n}\n\nmodule.exports = ConsoleLogger;","const libConsoleLog = require('./Fable-Log-Logger-Console.js');\nconst libFS = require('fs');\nconst libPath = require('path');\n\nclass SimpleFlatFileLogger extends libConsoleLog\n{\n\tconstructor(pLogStreamSettings, pFableLog)\n\t{\n\t\tsuper(pLogStreamSettings, pFableLog);\n\n\t\t// If a path isn't provided for the logfile, it tries to use the ProductName or Context\n\t\tthis.logFileRawPath = (this._Settings.hasOwnProperty('path')) ? this._Settings.path : `./${this._ContextMessage}.log`;\n\t\tthis.logFilePath = libPath.normalize(this.logFileRawPath);\n\n\t\tthis.logFileStreamOptions = (this._Settings.hasOwnProperty('fileStreamoptions')) ? this._Settings.fileStreamOptions : (\n\t\t\t{\n\t\t\t\t\"flags\": \"a\",\n\t\t\t\t\"encoding\": \"utf8\"\n\t\t\t})\n\n\t\tthis.fileWriter = libFS.createWriteStream(this.logFilePath, this.logFileStreamOptions);\n\n\t\tthis.activelyWriting = false;\n\n\t\tthis.logLineStrings = [];\n\t\tthis.logObjectStrings = [];\n\n\t\tthis.defaultWriteCompleteCallback = ()=>{};\n\t\tthis.defaultBufferFlushCallback = ()=>{};\n\t}\n\n\tcloseWriter(fCloseComplete)\n\t{\n\t\tlet tmpCloseComplete = (typeof(fCloseComplete) == 'function') ? fCloseComplete : ()=>{};\n\t\tif (this.fileWriter)\n\t\t{\n\t\t\tthis.fileWriter.end('\\n');\n\t\t\treturn this.fileWriter.once('finish', tmpCloseComplete.bind(this));\n\t\t}\n\t};\n\n\tcompleteBufferFlushToLogFile(fFlushComplete)\n\t{\n\t\tthis.activelyWriting = false;\n\t\tlet tmpFlushComplete = (typeof(fFlushComplete) == 'function') ? fFlushComplete : this.defaultBufferFlushCallback;\n\n\t\tif (this.logLineStrings.length > 0)\n\t\t{\n\t\t\tthis.flushBufferToLogFile(tmpFlushComplete);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn tmpFlushComplete();\n\t\t}\n\t}\n\n\tflushBufferToLogFile(fFlushComplete)\n\t{\n\t\tif (!this.activelyWriting)\n\t\t{\n\t\t\t// Only want to be writing one thing at a time....\n\t\t\tthis.activelyWriting = true;\n\n\t\t\tlet tmpFlushComplete = (typeof(fFlushComplete) == 'function') ? fFlushComplete : this.defaultBufferFlushCallback;\n\n\t\t\t// Get the current buffer arrays.  These should always have matching number of elements.\n\t\t\tlet tmpLineStrings = this.logLineStrings;\n\t\t\tlet tmpObjectStrings = this.logObjectStrings;\n\n\t\t\t// Reset these to be filled while we process this queue...\n\t\t\tthis.logLineStrings = [];\n\t\t\tthis.logObjectStrings = [];\n\n\t\t\t// This is where we will put each line before writing it to the file...\n\t\t\tlet tmpConstructedBufferOutputString = '';\n\n\t\t\tfor (let i = 0; i < tmpLineStrings.length; i++)\n\t\t\t{\n\t\t\t\t// TODO: Windows Newline?   ....... yo no se!\n\t\t\t\ttmpConstructedBufferOutputString += `${tmpLineStrings[i]}\\n`;\n\t\t\t\tif (tmpObjectStrings[i] !== false)\n\t\t\t\t{\n\t\t\t\t\ttmpConstructedBufferOutputString += `${tmpObjectStrings[i]}\\n`;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!this.fileWriter.write(tmpConstructedBufferOutputString, 'utf8'))\n\t\t\t{\n\t\t\t\t// If the streamwriter returns false, we need to wait for it to drain.\n\t\t\t\tthis.fileWriter.once('drain', this.completeBufferFlushToLogFile.bind(this, tmpFlushComplete));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn this.completeBufferFlushToLogFile(tmpFlushComplete);\n\t\t\t}\n\t\t}\n\t}\n\n\twrite(pLevel, pLogText, pObject)\n\t{\n\t\tlet tmpLogLine = super.write(pLevel, pLogText, pObject);\n\n\t\t// Use a very simple array as the write buffer\n\t\tthis.logLineStrings.push(tmpLogLine);\n\n\t\t// Write out the object on a separate line if it is passed in\n\t\tif (typeof(pObject) !== 'undefined')\n\t\t{\n\t\t\tthis.logObjectStrings.push(JSON.stringify(pObject, null, 4));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logObjectStrings.push(false);\n\t\t}\n\n\t\tthis.flushBufferToLogFile();\n\t}\n}\n\nmodule.exports = SimpleFlatFileLogger;","/**\n* Fable Logging Add-on\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable Logger\n*/\n\n/**\n* Fable Solution Log Wrapper Main Class\n*\n* @class FableLog\n* @constructor\n*/\nclass FableLog\n{\n\tconstructor(pFableSettings, pFable)\n\t{\n\t\tlet tmpSettings = (typeof(pFableSettings) === 'object') ? pFableSettings : {}\n\t\tthis._Settings = tmpSettings;\n\n\t\tthis._Providers = require('./Fable-Log-DefaultProviders-Node.js');\n\n\t\tthis._StreamDefinitions = (tmpSettings.hasOwnProperty('LogStreams')) ? tmpSettings.LogStreams : require('./Fable-Log-DefaultStreams.json');\n\n\t\tthis.logStreams = [];\n\n\t\t// This object gets decorated for one-time instantiated providers that\n\t\t//  have multiple outputs, such as bunyan.\n\t\tthis.logProviders = {};\n\n\t\t// A hash list of the GUIDs for each log stream, so they can't be added to the set more than one time\n\t\tthis.activeLogStreams = {};\n\n\t\tthis.logStreamsTrace = [];\n\t\tthis.logStreamsDebug = [];\n\t\tthis.logStreamsInfo = [];\n\t\tthis.logStreamsWarn = [];\n\t\tthis.logStreamsError = [];\n\t\tthis.logStreamsFatal = [];\n\n\t\tthis.datumDecorator = (pDatum) => pDatum;\n\n\t\tthis.uuid = (typeof(tmpSettings.Product) === 'string') ? tmpSettings.Product : 'Default';\n\t}\n\n\taddLogger(pLogger, pLevel)\n\t{\n\t\t// Bail out if we've already created one.\n\t\tif (this.activeLogStreams.hasOwnProperty(pLogger.loggerUUID))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// Add it to the streams and to the mutex\n\t\tthis.logStreams.push(pLogger);\n\t\tthis.activeLogStreams[pLogger.loggerUUID] = true;\n\n\t\t// Make sure a kosher level was passed in\n\t\tswitch (pLevel)\n\t\t{\n\t\t\tcase 'trace':\n\t\t\t\tthis.logStreamsTrace.push(pLogger);\n\t\t\tcase 'debug':\n\t\t\t\tthis.logStreamsDebug.push(pLogger);\n\t\t\tcase 'info':\n\t\t\t\tthis.logStreamsInfo.push(pLogger);\n\t\t\tcase 'warn':\n\t\t\t\tthis.logStreamsWarn.push(pLogger);\n\t\t\tcase 'error':\n\t\t\t\tthis.logStreamsError.push(pLogger);\n\t\t\tcase 'fatal':\n\t\t\t\tthis.logStreamsFatal.push(pLogger);\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tsetDatumDecorator(fDatumDecorator)\n\t{\n\t\tif (typeof(fDatumDecorator) === 'function')\n\t\t{\n\t\t\tthis.datumDecorator = fDatumDecorator;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.datumDecorator = (pDatum) => pDatum;\n\t\t}\n\t}\n\n\ttrace(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsTrace.length; i++)\n\t\t{\n\t\t\tthis.logStreamsTrace[i].trace(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tdebug(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsDebug.length; i++)\n\t\t{\n\t\t\tthis.logStreamsDebug[i].debug(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tinfo(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsInfo.length; i++)\n\t\t{\n\t\t\tthis.logStreamsInfo[i].info(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\twarn(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsWarn.length; i++)\n\t\t{\n\t\t\tthis.logStreamsWarn[i].warn(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\terror(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsError.length; i++)\n\t\t{\n\t\t\tthis.logStreamsError[i].error(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tfatal(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsFatal.length; i++)\n\t\t{\n\t\t\tthis.logStreamsFatal[i].fatal(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tinitialize()\n\t{\n\t\t// \"initialize\" each logger as defined in the logging parameters\n\t\tfor (let i = 0; i < this._StreamDefinitions.length; i++)\n\t\t{\n\t\t\tlet tmpStreamDefinition = Object.assign({loggertype:'default',streamtype:'console',level:'info'},this._StreamDefinitions[i]);\n\n\t\t\tif (!this._Providers.hasOwnProperty(tmpStreamDefinition.loggertype))\n\t\t\t{\n\t\t\t\tconsole.log(`Error initializing log stream: bad loggertype in stream definition ${JSON.stringify(tmpStreamDefinition)}`);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.addLogger(new this._Providers[tmpStreamDefinition.loggertype](tmpStreamDefinition, this), tmpStreamDefinition.level);\n\t\t\t}\n\t\t}\n\n\t\t// Now initialize each one.\n\t\tfor (let i = 0; i < this.logStreams.length; i++)\n\t\t{\n\t\t\tthis.logStreams[i].initialize();\n\t\t}\n\t}\n\n\tlogTime(pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time';\n\t\tlet tmpTime = new Date();\n\t\tthis.info(`${tmpMessage} ${tmpTime} (epoch ${+tmpTime})`, pDatum);\n\t}\n\n\t// Get a timestamp\n\tgetTimeStamp()\n\t{\n\t\treturn +new Date();\n\t}\n\n\tgetTimeDelta(pTimeStamp)\n\t{\n\t\tlet tmpEndTime = +new Date();\n\t\treturn tmpEndTime-pTimeStamp;\n\t}\n\n\t// Log the delta between a timestamp, and now with a message\n\tlogTimeDelta(pTimeDelta, pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time Measurement';\n\t\tlet tmpDatum = (typeof(pDatum) === 'object') ? pDatum : {};\n\n\t\tlet tmpEndTime = +new Date();\n\n\t\tthis.info(`${tmpMessage} logged at (epoch ${+tmpEndTime}) took (${pTimeDelta}ms)`, pDatum);\n\t}\n\n\tlogTimeDeltaHuman(pTimeDelta, pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time Measurement';\n\n\t\tlet tmpEndTime = +new Date();\n\n\t\tlet tmpMs = parseInt(pTimeDelta%1000);\n\t\tlet tmpSeconds = parseInt((pTimeDelta/1000)%60);\n\t\tlet tmpMinutes = parseInt((pTimeDelta/(1000*60))%60);\n\t\tlet tmpHours = parseInt(pTimeDelta/(1000*60*60));\n\n\t\ttmpMs = (tmpMs < 10) ? \"00\"+tmpMs : (tmpMs < 100) ? \"0\"+tmpMs : tmpMs;\n\t\ttmpSeconds = (tmpSeconds < 10) ? \"0\"+tmpSeconds : tmpSeconds;\n\t\ttmpMinutes = (tmpMinutes < 10) ? \"0\"+tmpMinutes : tmpMinutes;\n\t\ttmpHours = (tmpHours < 10) ? \"0\"+tmpHours : tmpHours;\n\n\t\tthis.info(`${tmpMessage} logged at (epoch ${+tmpEndTime}) took (${pTimeDelta}ms) or (${tmpHours}:${tmpMinutes}:${tmpSeconds}.${tmpMs})`, pDatum);\n\t}\n\n\tlogTimeDeltaRelative(pStartTime, pMessage, pDatum)\n\t{\n\t\tthis.logTimeDelta(this.getTimeDelta(pStartTime), pMessage, pDatum);\n\t}\n\n\tlogTimeDeltaRelativeHuman(pStartTime, pMessage, pDatum)\n\t{\n\t\tthis.logTimeDeltaHuman(this.getTimeDelta(pStartTime), pMessage, pDatum);\n\t}\n}\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new FableLog(pSettings);\n}\n\n\nmodule.exports = FableLog;\nmodule.exports.new = autoConstruct;\nmodule.exports.LogProviderBase = require('./Fable-Log-BaseLogger.js');\nmodule.exports.LogProviderConsole = require('./Fable-Log-Logger-Console.js');\nmodule.exports.LogProviderConsole = require('./Fable-Log-Logger-SimpleFlatFile.js');\n","module.exports={\n\t\"Product\": \"ApplicationNameHere\",\n\t\"ProductVersion\": \"0.0.0\",\n\n\t\"ConfigFile\": false,\n\n\t\"LogStreams\":\n\t[\n\t\t{\n\t\t\t\"level\": \"trace\"\n\t\t}\n\t]\n}\n","/**\n* Fable Settings Template Processor\n*\n* This class allows environment variables to come in via templated expressions, and defaults to be set.\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable Settings\n*/\n\nclass FableSettingsTemplateProcessor\n{\n\tconstructor(pDependencies)\n\t{\n        // Use a no-dependencies templating engine to parse out environment variables\n\t\tthis.templateProcessor = new pDependencies.precedent();\n\n        // TODO: Make the environment variable wrap expression demarcation characters configurable?\n\t\tthis.templateProcessor.addPattern('${', '}',\n\t\t\t(pTemplateValue)=>\n\t\t\t{\n\t\t\t\tlet tmpTemplateValue = pTemplateValue.trim();\n\n\t\t\t\tlet tmpSeparatorIndex = tmpTemplateValue.indexOf('|');\n\n\t\t\t\t// If there is no pipe, the default value will end up being whatever the variable name is.\n\t\t\t\tlet tmpDefaultValue = tmpTemplateValue.substring(tmpSeparatorIndex+1);\n\n\t\t\t\tlet tmpEnvironmentVariableName = (tmpSeparatorIndex > -1) ? tmpTemplateValue.substring(0, tmpSeparatorIndex) : tmpTemplateValue;\n\n\t\t\t\tif (process.env.hasOwnProperty(tmpEnvironmentVariableName))\n\t\t\t\t{\n\t\t\t\t\treturn process.env[tmpEnvironmentVariableName];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn tmpDefaultValue;\n\t\t\t\t}\n\t\t\t});\n    }\n\n    parseSetting(pString)\n    {\n        return this.templateProcessor.parseString(pString);\n    }\n}\n\nmodule.exports = FableSettingsTemplateProcessor;","/**\n* Fable Settings Add-on\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable Settings\n*/\n\nconst libPrecedent = require('precedent');\nconst libFableSettingsTemplateProcessor = require('./Fable-Settings-TemplateProcessor.js');\n\nclass FableSettings\n{\n\tconstructor(pFableSettings)\n\t{\n\t\t// Expose the dependencies for downstream re-use\n\t\tthis.dependencies = (\n\t\t\t{\n\t\t\t\tprecedent: libPrecedent\n\t\t\t});\n\n\t\t// Initialize the settings value template processor\n\t\tthis.settingsTemplateProcessor = new libFableSettingsTemplateProcessor(this.dependencies);\n\n\t\t// set straight away so anything that uses it respects the initial setting\n\t\tthis._configureEnvTemplating(pFableSettings);\n\n\t\tthis.default = this.buildDefaultSettings();\n\n\t\t// Construct a new settings object\n\t\tlet tmpSettings = this.merge(pFableSettings, this.buildDefaultSettings());\n\n\t\t// The base settings object (what they were on initialization, before other actors have altered them)\n\t\tthis.base = JSON.parse(JSON.stringify(tmpSettings));\n\n\t\tif (tmpSettings.DefaultConfigFile)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// If there is a DEFAULT configuration file, try to load and merge it.\n\t\t\t\ttmpSettings = this.merge(require(tmpSettings.DefaultConfigFile), tmpSettings);\n\t\t\t}\n\t\t\tcatch (pException)\n\t\t\t{\n\t\t\t\t// Why this?  Often for an app we want settings to work out of the box, but\n\t\t\t\t// would potentially want to have a config file for complex settings.\n\t\t\t\tconsole.log('Fable-Settings Warning: Default configuration file specified but there was a problem loading it.  Falling back to base.');\n\t\t\t\tconsole.log('     Loading Exception: '+pException);\n\t\t\t}\n\t\t}\n\n\t\tif (tmpSettings.ConfigFile)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// If there is a configuration file, try to load and merge it.\n\t\t\t\ttmpSettings = this.merge(require(tmpSettings.ConfigFile), tmpSettings);\n\t\t\t}\n\t\t\tcatch (pException)\n\t\t\t{\n\t\t\t\t// Why this?  Often for an app we want settings to work out of the box, but\n\t\t\t\t// would potentially want to have a config file for complex settings.\n\t\t\t\tconsole.log('Fable-Settings Warning: Configuration file specified but there was a problem loading it.  Falling back to base.');\n\t\t\t\tconsole.log('     Loading Exception: '+pException);\n\t\t\t}\n\t\t}\n\n\t\tthis.settings = tmpSettings;\n\t}\n\n\t// Build a default settings object.  Use the JSON jimmy to ensure it is always a new object.\n\tbuildDefaultSettings()\n\t{\n\t\treturn JSON.parse(JSON.stringify(require('./Fable-Settings-Default')));\n\t}\n\n\t// Update the configuration for environment variable templating based on the current settings object\n\t_configureEnvTemplating(pSettings)\n\t{\n\t\t// default environment variable templating to on\n\t\tthis._PerformEnvTemplating = !pSettings || pSettings.NoEnvReplacement !== true;\n\t}\n\n\t// Resolve (recursive) any environment variables found in settings object.\n\t_resolveEnv(pSettings)\n\t{\n\t\tfor (const tmpKey in pSettings)\n\t\t{\n\t\t\tif (typeof(pSettings[tmpKey]) === 'object')\n\t\t\t{\n\t\t\t\tthis._resolveEnv(pSettings[tmpKey]);\n\t\t\t}\n\t\t\telse if (typeof(pSettings[tmpKey]) === 'string')\n\t\t\t{\n\t\t\t\tpSettings[tmpKey] = this.settingsTemplateProcessor.parseSetting(pSettings[tmpKey]);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Check to see if a value is an object (but not an array).\n\t */\n\t_isObject(value)\n\t{\n\t\treturn typeof(value) === 'object' && !Array.isArray(value);\n\t}\n\n\t/**\n\t * Merge two plain objects. Keys that are objects in both will be merged property-wise.\n\t */\n\t_deepMergeObjects(toObject, fromObject)\n\t{\n\t\tif (!fromObject || !this._isObject(fromObject))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tObject.keys(fromObject).forEach((key) =>\n\t\t{\n\t\t\tconst fromValue = fromObject[key];\n\t\t\tif (this._isObject(fromValue))\n\t\t\t{\n\t\t\t\tconst toValue = toObject[key];\n\t\t\t\tif (toValue && this._isObject(toValue))\n\t\t\t\t{\n\t\t\t\t\t// both are objects, so do a recursive merge\n\t\t\t\t\tthis._deepMergeObjects(toValue, fromValue);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttoObject[key] = fromValue;\n\t\t});\n\t\treturn toObject;\n\t}\n\n\t// Merge some new object into the existing settings.\n\tmerge(pSettingsFrom, pSettingsTo)\n\t{\n\t\t// If an invalid settings from object is passed in (e.g. object constructor without passing in anything) this should still work\n\t\tlet tmpSettingsFrom = (typeof(pSettingsFrom) === 'object') ? pSettingsFrom : {};\n\t\t// Default to the settings object if none is passed in for the merge.\n\t\tlet tmpSettingsTo = (typeof(pSettingsTo) === 'object') ? pSettingsTo : this.settings;\n\n\t\t// do not mutate the From object property values\n\t\tlet tmpSettingsFromCopy = JSON.parse(JSON.stringify(tmpSettingsFrom));\n\t\ttmpSettingsTo = this._deepMergeObjects(tmpSettingsTo, tmpSettingsFromCopy);\n\n\t\tif (this._PerformEnvTemplating)\n\t\t{\n\t\t\tthis._resolveEnv(tmpSettingsTo);\n\t\t}\n\t\t// Update env tempating config, since we just updated the config object, and it may have changed\n\t\tthis._configureEnvTemplating(tmpSettingsTo);\n\n\t\treturn tmpSettingsTo;\n\t}\n\n\t// Fill in settings gaps without overwriting settings that are already there\n\tfill(pSettingsFrom)\n\t{\n\t\t// If an invalid settings from object is passed in (e.g. object constructor without passing in anything) this should still work\n\t\tlet tmpSettingsFrom = (typeof(pSettingsFrom) === 'object') ? pSettingsFrom : {};\n\n\t\t// do not mutate the From object property values\n\t\tlet tmpSettingsFromCopy = JSON.parse(JSON.stringify(tmpSettingsFrom));\n\n\t\tthis.settings = this._deepMergeObjects(tmpSettingsFromCopy, this.settings);\n\n\t\treturn this.settings;\n\t}\n};\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new FableSettings(pSettings);\n}\n\nmodule.exports = FableSettings;\nmodule.exports.new = autoConstruct;\nmodule.exports.precedent = libPrecedent;","/**\n* Random Byte Generator - Browser version\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\n// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\nclass RandomBytes\n{\n\tconstructor()\n\t{\n\n\t\t// getRandomValues needs to be invoked in a context where \"this\" is a Crypto\n\t\t// implementation. Also, find the complete implementation of crypto on IE11.\n\t\tthis.getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||\n                      \t\t(typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));\n\t}\n\n\t// WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n\tgenerateWhatWGBytes()\n\t{\n\t\tlet tmpBuffer = new Uint8Array(16); // eslint-disable-line no-undef\n\n\t\tthis.getRandomValues(tmpBuffer);\n\t\treturn tmpBuffer;\n\t}\n\n\t// Math.random()-based (RNG)\n\tgenerateRandomBytes()\n\t{\n\t\t// If all else fails, use Math.random().  It's fast, but is of unspecified\n\t\t// quality.\n\t\tlet tmpBuffer = new Uint8Array(16); // eslint-disable-line no-undef\n\n\t\tfor (let i = 0, tmpValue; i < 16; i++)\n\t\t{\n\t\t\tif ((i & 0x03) === 0)\n\t\t\t{\n\t\t\t\ttmpValue = Math.random() * 0x100000000;\n\t\t\t}\n\n\t\t\ttmpBuffer[i] = tmpValue >>> ((i & 0x03) << 3) & 0xff;\n\t\t}\n\n\t\treturn tmpBuffer;\n\t}\n\n\tgenerate()\n\t{\n\t\tif (this.getRandomValues)\n\t\t{\n\t\t\treturn this.generateWhatWGBytes();\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.generateRandomBytes();\n\t\t}\n\t}\n}\n\nmodule.exports = RandomBytes;\n","/**\n* Fable UUID Generator\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable UUID\n*/\n\n/**\n* Fable Solution UUID Generation Main Class\n*\n* @class FableUUID\n* @constructor\n*/\n\nvar libRandomByteGenerator = require('./Fable-UUID-Random.js')\n\nclass FableUUID\n{\n\tconstructor(pSettings)\n\t{\n\t\t// Determine if the module is in \"Random UUID Mode\" which means just use the random character function rather than the v4 random UUID spec.\n\t\t// Note this allows UUIDs of various lengths (including very short ones) although guaranteed uniqueness goes downhill fast.\n\t\tthis._UUIDModeRandom = (typeof(pSettings) === 'object') && (pSettings.hasOwnProperty('UUIDModeRandom')) ? (pSettings.UUIDModeRandom == true) : false;\n\t\t// These two properties are only useful if we are in Random mode.  Otherwise it generates a v4 spec\n\t\t// Length for \"Random UUID Mode\" is set -- if not set it to 8\n\t\tthis._UUIDLength = (typeof(pSettings) === 'object') && (pSettings.hasOwnProperty('UUIDLength')) ? (pSettings.UUIDLength + 0) : 8;\n\t\t// Dictionary for \"Random UUID Mode\"\n\t\tthis._UUIDRandomDictionary = (typeof(pSettings) === 'object') && (pSettings.hasOwnProperty('UUIDDictionary')) ? (pSettings.UUIDDictionary + 0) : '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n\n\t\tthis.randomByteGenerator = new libRandomByteGenerator();\n\n\t\t// Lookup table for hex codes\n\t\tthis._HexLookup = [];\n\t\tfor (let i = 0; i < 256; ++i)\n\t\t{\n\t\t\tthis._HexLookup[i] = (i + 0x100).toString(16).substr(1);\n\t\t}\n\t}\n\n\t// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n\tbytesToUUID(pBuffer)\n\t{\n\t\tlet i = 0;\n\t\t// join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n\t\treturn ([\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], \n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]]\n\t\t\t\t]).join('');\n\t}\n\n\t// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n\tgenerateUUIDv4()\n\t{\n\t\tlet tmpBuffer = new Array(16);\n\t\tvar tmpRandomBytes = this.randomByteGenerator.generate();\n\n\t\t// Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\t\ttmpRandomBytes[6] = (tmpRandomBytes[6] & 0x0f) | 0x40;\n\t\ttmpRandomBytes[8] = (tmpRandomBytes[8] & 0x3f) | 0x80;\n\n\t\treturn this.bytesToUUID(tmpRandomBytes);\n\t}\n\n\t// Simple random UUID generation\n\tgenerateRandom()\n\t{\n\t\tlet tmpUUID = '';\n\n\t\tfor (let i = 0; i < this._UUIDLength; i++)\n\t\t{\n\t\t\ttmpUUID += this._UUIDRandomDictionary.charAt(Math.floor(Math.random() * (this._UUIDRandomDictionary.length-1)));\n\t\t}\n\n\t\treturn tmpUUID;\n\t}\n\n\t// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n\tgetUUID()\n\t{\n\t\tif (this._UUIDModeRandom)\n\t\t{\n\t\t\treturn this.generateRandom();\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.generateUUIDv4();\n\t\t}\n\t}\n}\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new FableUUID(pSettings);\n}\n\n\nmodule.exports = FableUUID;\nmodule.exports.new = autoConstruct;\n","// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n","/**\n* Precedent Meta-Templating\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Process text streams, parsing out meta-template expressions.\n*/\nvar libWordTree = require(`./WordTree.js`);\nvar libStringParser = require(`./StringParser.js`);\n\nclass Precedent\n{\n\t/**\n\t * Precedent Constructor\n\t */\n\tconstructor()\n\t{\n\t\tthis.WordTree = new libWordTree();\n\t\t\n\t\tthis.StringParser = new libStringParser();\n\n\t\tthis.ParseTree = this.WordTree.ParseTree;\n\t}\n\t\n\t/**\n\t * Add a Pattern to the Parse Tree\n\t * @method addPattern\n\t * @param {Object} pTree - A node on the parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @param {number} pIndex - callback function\n\t * @return {bool} True if adding the pattern was successful\n\t */\n\taddPattern(pPatternStart, pPatternEnd, pParser)\n\t{\n\t\treturn this.WordTree.addPattern(pPatternStart, pPatternEnd, pParser);\n\t}\n\t\n\t/**\n\t * Parse a string with the existing parse tree\n\t * @method parseString\n\t * @param {string} pString - The string to parse\n\t * @return {string} The result from the parser\n\t */\n\tparseString(pString)\n\t{\n\t\treturn this.StringParser.parseString(pString, this.ParseTree);\n\t}\n}\n\nmodule.exports = Precedent;\n","/**\n* String Parser\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Parse a string, properly processing each matched token in the word tree.\n*/\n\nclass StringParser\n{\n\t/**\n\t * StringParser Constructor\n\t */\n\tconstructor()\n\t{\n\t}\n\t\n\t/**\n\t * Create a fresh parsing state object to work with.\n\t * @method newParserState\n\t * @param {Object} pParseTree - A node on the parse tree to begin parsing from (usually root)\n\t * @return {Object} A new parser state object for running a character parser on\n\t * @private\n\t */\n\tnewParserState (pParseTree)\n\t{\n\t\treturn (\n\t\t{\n\t\t\tParseTree: pParseTree,\n\n\t\t\tOutput: '',\n\t\t\tOutputBuffer: '',\n\n\t\t\tPattern: false,\n\n\t\t\tPatternMatch: false,\n\t\t\tPatternMatchOutputBuffer: ''\n\t\t});\n\t}\n\t\t\n\t/**\n\t * Assign a node of the parser tree to be the next potential match.\n\t * If the node has a PatternEnd property, it is a valid match and supercedes the last valid match (or becomes the initial match).\n\t * @method assignNode\n\t * @param {Object} pNode - A node on the parse tree to assign\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tassignNode (pNode, pParserState)\n\t{\n\t\tpParserState.PatternMatch = pNode;\n\n\t\t// If the pattern has a END we can assume it has a parse function...\n\t\tif (pParserState.PatternMatch.hasOwnProperty('PatternEnd'))\n\t\t{\n\t\t\t// ... this is the legitimate start of a pattern.\n\t\t\tpParserState.Pattern = pParserState.PatternMatch;\n\t\t}\n\t}\n\t\n\t/**\n\t * Append a character to the output buffer in the parser state.\n\t * This output buffer is used when a potential match is being explored, or a match is being explored.\n\t * @method appendOutputBuffer\n\t * @param {string} pCharacter - The character to append\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tappendOutputBuffer (pCharacter, pParserState)\n\t{\n\t\tpParserState.OutputBuffer += pCharacter;\n\t}\n\t\n\t/**\n\t * Flush the output buffer to the output and clear it.\n\t * @method flushOutputBuffer\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tflushOutputBuffer (pParserState)\n\t{\n\t\tpParserState.Output += pParserState.OutputBuffer;\n\t\tpParserState.OutputBuffer = '';\n\t}\n\n\t\n\t/**\n\t * Check if the pattern has ended.  If it has, properly flush the buffer and start looking for new patterns.\n\t * @method checkPatternEnd\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tcheckPatternEnd (pParserState)\n\t{\n\t\tif ((pParserState.OutputBuffer.length >= pParserState.Pattern.PatternEnd.length+pParserState.Pattern.PatternStart.length) && \n\t\t\t(pParserState.OutputBuffer.substr(-pParserState.Pattern.PatternEnd.length) === pParserState.Pattern.PatternEnd))\n\t\t{\n\t\t\t// ... this is the end of a pattern, cut off the end tag and parse it.\n\t\t\t// Trim the start and end tags off the output buffer now\n\t\t\tpParserState.OutputBuffer = pParserState.Pattern.Parse(pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStart.length, pParserState.OutputBuffer.length - (pParserState.Pattern.PatternStart.length+pParserState.Pattern.PatternEnd.length)));\n\t\t\t// Flush the output buffer.\n\t\t\tthis.flushOutputBuffer(pParserState);\n\t\t\t// End pattern mode\n\t\t\tpParserState.Pattern = false;\n\t\t\tpParserState.PatternMatch = false;\n\t\t}\n\t}\n\t\n\t/**\n\t * Parse a character in the buffer.\n\t * @method parseCharacter\n\t * @param {string} pCharacter - The character to append\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tparseCharacter (pCharacter, pParserState)\n\t{\n\t\t// (1) If we aren't in a pattern match, and we aren't potentially matching, and this may be the start of a new pattern....\n\t\tif (!pParserState.PatternMatch && pParserState.ParseTree.hasOwnProperty(pCharacter))\n\t\t{\n\t\t\t// ... assign the node as the matched node.\n\t\t\tthis.assignNode(pParserState.ParseTree[pCharacter], pParserState);\n\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t}\n\t\t// (2) If we are in a pattern match (actively seeing if this is part of a new pattern token)\n\t\telse if (pParserState.PatternMatch)\n\t\t{\n\t\t\t// If the pattern has a subpattern with this key\n\t\t\tif (pParserState.PatternMatch.hasOwnProperty(pCharacter))\n\t\t\t{\n\t\t\t\t// Continue matching patterns.\n\t\t\t\tthis.assignNode(pParserState.PatternMatch[pCharacter], pParserState);\n\t\t\t}\n\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\tif (pParserState.Pattern)\n\t\t\t{\n\t\t\t\t// ... Check if this is the end of the pattern (if we are matching a valid pattern)...\n\t\t\t\tthis.checkPatternEnd(pParserState);\n\t\t\t}\n\t\t}\n\t\t// (3) If we aren't in a pattern match or pattern, and this isn't the start of a new pattern (RAW mode)....\n\t\telse\n\t\t{\n\t\t\tpParserState.Output += pCharacter;\n\t\t}\n\t}\n\t\n\t/**\n\t * Parse a string for matches, and process any template segments that occur.\n\t * @method parseString\n\t * @param {string} pString - The string to parse.\n\t * @param {Object} pParseTree - The parse tree to begin parsing from (usually root)\n\t */\n\tparseString (pString, pParseTree)\n\t{\n\t\tlet tmpParserState = this.newParserState(pParseTree);\n\n\t\tfor (var i = 0; i < pString.length; i++)\n\t\t{\n\t\t\t// TODO: This is not fast.\n\t\t\tthis.parseCharacter(pString[i], tmpParserState);\n\t\t}\n\t\t\n\t\tthis.flushOutputBuffer(tmpParserState);\n\t\t\n\t\treturn tmpParserState.Output;\n\t}\n}\n\nmodule.exports = StringParser;\n","/**\n* Word Tree\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Create a tree (directed graph) of Javascript objects, one character per object.\n*/\n\nclass WordTree\n{\n\t/**\n\t * WordTree Constructor\n\t */\n\tconstructor()\n\t{\n\t\tthis.ParseTree = {};\n\t}\n\t\n\t/** \n\t * Add a child character to a Parse Tree node\n\t * @method addChild\n\t * @param {Object} pTree - A parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @param {number} pIndex - The index of the character in the pattern\n\t * @returns {Object} The resulting leaf node that was added (or found)\n\t * @private\n\t */\n\taddChild (pTree, pPattern, pIndex)\n\t{\n\t\tif (!pTree.hasOwnProperty(pPattern[pIndex]))\n\t\t\tpTree[pPattern[pIndex]] = {};\n\t\t\n\t\treturn pTree[pPattern[pIndex]];\n\t}\n\t\n\t/** Add a Pattern to the Parse Tree\n\t * @method addPattern\n\t * @param {Object} pPatternStart - The starting string for the pattern (e.g. \"${\")\n\t * @param {string} pPatternEnd - The ending string for the pattern (e.g. \"}\")\n\t * @param {number} pParser - The function to parse if this is the matched pattern, once the Pattern End is met.  If this is a string, a simple replacement occurs.\n\t * @return {bool} True if adding the pattern was successful\n\t */\n\taddPattern (pPatternStart, pPatternEnd, pParser)\n\t{\n\t\tif (pPatternStart.length < 1)\n\t\t\treturn false;\n\n\t\tif ((typeof(pPatternEnd) === 'string') && (pPatternEnd.length < 1))\n\t\t\treturn false;\n\n\t\tlet tmpLeaf = this.ParseTree;\n\n\t\t// Add the tree of leaves iteratively\n\t\tfor (var i = 0; i < pPatternStart.length; i++)\n\t\t\ttmpLeaf = this.addChild(tmpLeaf, pPatternStart, i);\n\n\t\ttmpLeaf.PatternStart = pPatternStart;\n\t\ttmpLeaf.PatternEnd = ((typeof(pPatternEnd) === 'string') && (pPatternEnd.length > 0)) ? pPatternEnd : pPatternStart;\n\t\ttmpLeaf.Parse = (typeof(pParser) === 'function') ? pParser : \n\t\t\t\t\t\t(typeof(pParser) === 'string') ? () => { return pParser; } :\n\t\t\t\t\t\t(pData) => { return pData; };\n\n\t\treturn true;\n\t}\n}\n\nmodule.exports = WordTree;\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","var nextTick = require('process/browser.js').nextTick;\nvar apply = Function.prototype.apply;\nvar slice = Array.prototype.slice;\nvar immediateIds = {};\nvar nextImmediateId = 0;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) { timeout.close(); };\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// That's not how node.js implements it but the exposed api is the same.\nexports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n  var id = nextImmediateId++;\n  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n  immediateIds[id] = true;\n\n  nextTick(function onNextTick() {\n    if (immediateIds[id]) {\n      // fn.call() is faster so we optimize for the common use-case\n      // @see http://jsperf.com/call-apply-segu\n      if (args) {\n        fn.apply(null, args);\n      } else {\n        fn.call(null);\n      }\n      // Prevent ids from leaking\n      exports.clearImmediate(id);\n    }\n  });\n\n  return id;\n};\n\nexports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n  delete immediateIds[id];\n};","var libNPMModuleWrapper = require('./Fable.js');\n\nif ((typeof(window) === 'object') && !window.hasOwnProperty('Fable'))\n{\n\twindow.Fable = libNPMModuleWrapper;\n}\n\nmodule.exports = libNPMModuleWrapper;","const _OperationStatePrototype = JSON.stringify(\n{\n\t\"Metadata\": {\n\t\t\"GUID\": false,\n\t\t\"Hash\": false,\n\n\t\t\"Title\": \"\",\n\t\t\"Summary\": \"\",\n\n\t\t\"Version\": 0\n\t},\n\t\"Status\": {\n        \"Completed\": false,\n\n        \"CompletionProgress\": 0,\n        \"CompletionTimeElapsed\": 0,\n\n        \"Steps\": 1,\n        \"StepsCompleted\": 0,\n\n        \"StartTime\": 0,\n        \"EndTime\": 0\n\t},\n\t\"Errors\": [],\n\t\"Log\": []\n});\n\nclass FableOperation\n{\n\tconstructor(pFable, pOperationName, pOperationHash)\n\t{\n\t\tthis.fable = pFable;\n\n\t\tthis.name = pOperationName;\n\n\t\tthis.state = JSON.parse(_OperationStatePrototype);\n\n\t\tthis.state.Metadata.GUID = this.fable.getUUID();\n\t\tthis.state.Metadata.Hash = this.state.GUID;\n\n\t\tif (typeof(pOperationHash) == 'string')\n\t\t{\n\t\t\tthis.state.Metadata.Hash = pOperationHash;\n\t\t}\n\t}\n\n\tget GUID()\n\t{\n\t\treturn this.state.Metadata.GUID;\n\t}\n\n\tget Hash()\n\t{\n\t\treturn this.state.Metadata.Hash;\n\t}\n\n\tget log()\n\t{\n\t\treturn this;\n\t}\n\n\twriteOperationLog(pLogLevel, pLogText, pLogObject)\n\t{\n\t\tthis.state.Log.push(`${new Date().toUTCString()} [${pLogLevel}]: ${pLogText}`);\n\n\t\tif (typeof(pLogObject) == 'object')\n\t\t{\n\t\t\tthis.state.Log.push(JSON.stringify(pLogObject));\n\t\t}\n\t}\n\n\twriteOperationErrors(pLogText, pLogObject)\n\t{\n\t\tthis.state.Errors.push(`${pLogText}`);\n\n\t\tif (typeof(pLogObject) == 'object')\n\t\t{\n\t\t\tthis.state.Errors.push(JSON.stringify(pLogObject));\n\t\t}\n\t}\n\n\ttrace(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('TRACE', pLogText, pLogObject);\n\t\tthis.fable.log.trace(pLogText, pLogObject);\n\t}\n\n\tdebug(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('DEBUG', pLogText, pLogObject);\n\t\tthis.fable.log.debug(pLogText, pLogObject);\n\t}\n\n\tinfo(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('INFO', pLogText, pLogObject);\n\t\tthis.fable.log.info(pLogText, pLogObject);\n\t}\n\n\twarn(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('WARN', pLogText, pLogObject);\n\t\tthis.fable.log.warn(pLogText, pLogObject);\n\t}\n\n\terror(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('ERROR', pLogText, pLogObject);\n\t\tthis.writeOperationErrors(pLogText, pLogObject);\n\t\tthis.fable.log.error(pLogText, pLogObject);\n\t}\n\n\tfatal(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('FATAL', pLogText, pLogObject);\n\t\tthis.writeOperationErrors(pLogText, pLogObject);\n\t\tthis.fable.log.fatal(pLogText, pLogObject);\n\t}\n}\n\nmodule.exports = FableOperation;","const libFableServiceBase = require('./Fable-ServiceProviderBase.js');\n\nclass FableServiceTemplate extends libFableServiceBase\n{\n\t// Underscore and lodash have a behavior, _.template, which compiles a\n\t// string-based template with code snippets into simple executable pieces,\n\t// with the added twist of returning a precompiled function ready to go.\n\t//\n\t// NOTE: This does not implement underscore escape expressions\n\t// NOTE: This does not implement underscore magic browser variable assignment\n\t//\n\t// This is an implementation of that.\n\t// TODO: Make this use precedent, add configuration, add debugging.\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n        super(pFable, pOptions, pServiceHash);\n\n        this.serviceType = 'Template';\n\n\t\t// These are the exact regex's used in lodash/underscore\n\t\t// TODO: Switch this to precedent\n\t\tthis.Matchers = (\n\t\t\t{\n\t\t\t\tEvaluate: /<%([\\s\\S]+?)%>/g,\n\t\t\t\tInterpolate: /<%=([\\s\\S]+?)%>/g,\n\t\t\t\tEscaper: /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g,\n\t\t\t\tUnescaper: /\\\\(\\\\|'|r|n|t|u2028|u2029)/g,\n\t\t\t\t// This is how underscore does it, so we are keeping it for now.\n\t\t\t\tGuaranteedNonMatch: /.^/\n\t\t\t});\n\n\t\t// This is a helper for the escaper and unescaper functions.\n\t\t// Right now we are going to keep what underscore is doing, but, not forever.\n\t\tthis.templateEscapes = {\n\t\t\t'\\\\': '\\\\',\n\t\t\t\"'\": \"'\",\n\t\t\t'r': '\\r',\n\t\t\t'\\r': 'r',\n\t\t\t'n': '\\n',\n\t\t\t'\\n': 'n',\n\t\t\t't': '\\t',\n\t\t\t'\\t': 't',\n\t\t\t'u2028': '\\u2028',\n\t\t\t'\\u2028': 'u2028',\n\t\t\t'u2029': '\\u2029',\n\t\t\t'\\u2029': 'u2029'\n\t\t};\n\n\t\t// This is defined as such to underscore that it is a dynamic programming\n\t\t// function on this class.\n\t\tthis.renderFunction = false;\n        this.templateString = false;\n\t}\n\n\trenderTemplate(pData)\n\t{\n\t\treturn this.renderFunction(pData);\n\t}\n\n\ttemplateFunction(pData)\n\t{\n\t\tlet fRenderTemplateBound = this.renderTemplate.bind(this);\n\t\treturn fRenderTemplateBound;\n\t}\n\n\tbuildTemplateFunction(pTemplateText, pData)\n\t{\n\t\t// For now this is being kept in a weird form ... this is to mimic the old\n\t\t// underscore code until this is rewritten using precedent.\n\t\tthis.TemplateSource = \"__p+='\" + pTemplateText\n\t\t\t.replace(this.Matchers.Escaper,\n\t\t\t\t(pMatch)=>\n\t\t\t\t{\n\t\t\t\t\treturn `\\\\${this.templateEscapes[pMatch]}`;\n\t\t\t\t})\n\t\t\t.replace(this.Matchers.Interpolate || this.Matchers.GuaranteedNonMatch,\n\t\t\t\t(pMatch, pCode) =>\n\t\t\t\t{\n\t\t\t\t\treturn `'+\\n(${decodeURIComponent(pCode)})+\\n'`;\n\t\t\t\t})\n\t\t\t.replace(this.Matchers.Evaluate || this.Matchers.GuaranteedNonMatch,\n\t\t\t\t(pMatch, pCode) =>\n\t\t\t\t{\n\t\t\t\t\treturn `';\\n${decodeURIComponent(pCode)}\\n;__p+='`;\n\t\t\t\t}) + `';\\n`;\n\n\n\t\tthis.TemplateSource = `with(pTemplateDataObject||{}){\\n${this.TemplateSource}}\\n`;\n\t\tthis.TemplateSource = `var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};\\n${this.TemplateSource}return __p;\\n`;\n\n\t\tthis.renderFunction = new Function('pTemplateDataObject', this.TemplateSource);\n\n\t\tif (typeof(pData) != 'undefined')\n\t\t{\n\t\t\treturn this.renderFunction(pData);\n\t\t}\n\n\t\t// Provide the compiled function source as a convenience for build time\n\t\t// precompilation.\n\t\tthis.TemplateSourceCompiled = 'function(obj){\\n' + this.TemplateSource + '}';\n\n\t\treturn this.templateFunction();\n\t}\n}\n\nmodule.exports = FableServiceTemplate;","/**\n* Fable Application Services Management\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\nconst libFableServiceBase = require('./Fable-ServiceProviderBase.js');\n\nclass FableService\n{\n\tconstructor(pFable)\n\t{\n\t\tthis.fable = pFable;\n\n\t\tthis.serviceTypes = [];\n\n\t\t// A map of instantiated services\n\t\tthis.services = {};\n\n\t\t// A map of the default instantiated service by type\n\t\tthis.defaultServices = {};\n\n\t\t// A map of class constructors for services\n\t\tthis.serviceClasses = {};\n\t}\n\n\taddServiceType(pServiceType, pServiceClass)\n\t{\n\t\t// Add the type to the list of types\n\t\tthis.serviceTypes.push(pServiceType);\n\n\t\t// Add the container for instantiated services to go in\n\t\tthis.services[pServiceType] = {};\n\n\t\tif ((typeof(pServiceClass) == 'function') && (pServiceClass.prototype instanceof libFableServiceBase))\n\t\t{\n\t\t\t// Add the class to the list of classes\n\t\t\tthis.serviceClasses[pServiceType] = pServiceClass;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Add the base class to the list of classes\n\t\t\tthis.serviceClasses[pServiceType] = libFableServiceBase;\n\t\t}\n\t}\n\n\tinstantiateServiceProvider(pServiceType, pOptions, pCustomServiceHash)\n\t{\n\t\t// Instantiate the service\n\t\tlet tmpService = this.instantiateServiceProviderWithoutRegistration(pServiceType, pOptions, pCustomServiceHash);\n\n\t\t// Add the service to the service map\n\t\tthis.services[pServiceType][tmpService.Hash] = tmpService;\n\n\t\t// If this is the first service of this type, make it the default\n\t\tif (!this.defaultServices.hasOwnProperty(pServiceType))\n\t\t{\n\t\t\tthis.defaultServices[pServiceType] = tmpService;\n\t\t}\n\n\t\treturn tmpService;\n\t}\n\n\t// Create a service provider but don't register it to live forever in fable.services\n\tinstantiateServiceProviderWithoutRegistration(pServiceType, pOptions, pCustomServiceHash)\n\t{\n\t\t// Instantiate the service\n\t\tlet tmpService = new this.serviceClasses[pServiceType](this.fable, pOptions, pCustomServiceHash);\n\t\treturn tmpService;\n\t}\n\n\tsetDefaultServiceInstantiation(pServiceType, pServiceHash)\n\t{\n\t\tif (this.services[pServiceType].hasOwnProperty(pServiceHash))\n\t\t{\n\t\t\tthis.defaultServices[pServiceType] = this.services[pServiceType][pServiceHash];\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n}\n\nmodule.exports = FableService;\n\nmodule.exports.ServiceProviderBase = libFableServiceBase;","/**\n* Fable Service Base\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\nclass FableServiceProviderBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tthis.fable = pFable;\n\n\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions : {};\n\n        this.serviceType = 'Unknown';\n\n        this.UUID = pFable.getUUID();\n\n        this.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash : `${this.UUID}`;\n\t}\n}\n\nmodule.exports = FableServiceProviderBase;\n","// TODO: These are still pretty big -- consider the smaller polyfills\nconst libAsyncWaterfall = require('async.waterfall');\nconst libAsyncEachLimit = require('async.eachlimit');\n\nclass FableUtility\n{\n\tconstructor(pFable)\n\t{\n\t\tthis.fable = pFable;\n\n\t\tthis.templates = {};\n\n\t\t// These two functions are used extensively throughout\n\t\tthis.waterfall = libAsyncWaterfall;\n\t\tthis.eachLimit = libAsyncEachLimit;\n\t}\n\n\t// Underscore and lodash have a behavior, _.extend, which merges objects.\n\t// Now that es6 gives us this, use the native thingy.\n\textend(pDestinationObject, ...pSourceObjects)\n\t{\n\t\treturn Object.assign(pDestinationObject, ...pSourceObjects);\n\t}\n\n\t// Underscore and lodash have a behavior, _.template, which compiles a\n\t// string-based template with code snippets into simple executable pieces,\n\t// with the added twist of returning a precompiled function ready to go.\n\ttemplate(pTemplateText, pData)\n\t{\n\t\tlet tmpTemplate = this.fable.serviceManager.instantiateServiceProviderWithoutRegistration('Template');\n\n\t\treturn tmpTemplate.buildTemplateFunction(pTemplateText, pData);\n\t}\n\n\t// Build a template function from a template hash, and, register it with the service provider\n\tbuildHashedTemplate(pTemplateHash, pTemplateText, pData)\n\t{\n\t\tlet tmpTemplate = this.fable.serviceManager.instantiateServiceProvider('Template', {}, pTemplateHash);\n\n\t\tthis.templates[pTemplateHash] = tmpTemplate.buildTemplateFunction(pTemplateText, pData);\n\n\t\treturn this.templates[pTemplateHash];\n\t}\n\n\t// This is a safe, modern version of chunk from underscore\n\t// Algorithm pulled from a mix of these two polyfills:\n\t// https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_chunk\n\t// https://youmightnotneed.com/lodash\n\t// This implementation was most tolerant in browsers.  Uglify can fix the rest.\n\tchunk (pInput, pChunkSize, pChunkCache)\n\t{\n\t\tlet tmpInputArray = [...pInput];\n\t\t// Note lodash defaults to 1, underscore defaults to 0\n\t\tlet tmpChunkSize = (typeof(pChunkSize) == 'number') ? pChunkSize : 0;\n\t\tlet tmpChunkCache = (typeof(pChunkCache) != 'undefined') ? pChunkCache : [];\n\n\t\tif (tmpChunkSize <= 0)\n\t\t{\n\t\t\treturn tmpChunkCache;\n\t\t}\n\n\t\twhile (tmpInputArray.length)\n\t\t{\n\t\t\ttmpChunkCache.push(tmpInputArray.splice(0, tmpChunkSize));\n\t\t}\n\n\t\treturn tmpChunkCache;\n\t}\n}\n\nmodule.exports = FableUtility;","/**\n* Fable Application Services Support Library\n* @license MIT\n* @author <steven@velozo.com>\n*/\nconst libFableSettings = require('fable-settings');\nconst libFableUUID = require('fable-uuid');\nconst libFableLog = require('fable-log');\n\nconst libFableUtility = require('./Fable-Utility.js');\nconst libFableServiceManager = require('./Fable-ServiceManager.js');\n\nconst libFableServiceTemplate = require('./Fable-Service-Template.js');\n\nconst libFableOperation = require('./Fable-Operation.js');\n\nclass Fable\n{\n\tconstructor(pSettings)\n\t{\n\t\tlet tmpSettings = new libFableSettings(pSettings);\n\n\t\tthis.settingsManager = tmpSettings;\n\n\t\t// Instantiate the UUID generator\n\t\tthis.libUUID = new libFableUUID(this.settingsManager.settings);\n\n\t\tthis.log = new libFableLog(this.settingsManager.settings);\n\t\tthis.log.initialize();\n\n\t\t// Built-in utility belt functions\n\t\tthis.Utility = new libFableUtility(this);\n\n\t\t// Built-in dependencies\n\t\tthis.Dependencies = (\n\t\t\t{\n\t\t\t\tprecedent: libFableSettings.precedent\n\t\t\t});\n\n\t\t// Location for Operation state\n\t\tthis.Operations = {};\n\n\t\tthis.serviceManager = new libFableServiceManager(this);\n\n\t\tthis.serviceManager.addServiceType('Template', libFableServiceTemplate);\n\n\t\tthis.services = this.serviceManager.services;\n\t\tthis.defaultServices = this.serviceManager.defaultServices;\n\t}\n\n\tget settings()\n\t{\n\t\treturn this.settingsManager.settings;\n\t}\n\n\tget fable()\n\t{\n\t\treturn this;\n\t}\n\n\tgetUUID()\n\t{\n\t\treturn this.libUUID.getUUID();\n\t}\n\n\tcreateOperation(pOperationName, pOperationHash)\n\t{\n\t\tlet tmpOperation = new libFableOperation(this, pOperationName, pOperationHash);\n\n\t\tif (this.Operations.hasOwnProperty(tmpOperation.Hash))\n\t\t{\n\t\t\t// Uh Oh ...... Operation Hash Collision!\n\t\t\t// TODO: What to do?!\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.Operations[tmpOperation.Hash] = tmpOperation;\n\t\t}\n\n\t\treturn tmpOperation;\n\t}\n\n\tgetOperation(pOperationHash)\n\t{\n\t\tif (!this.Operations.hasOwnProperty(pOperationHash))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.Operations[pOperationHash];\n\t\t}\n\t}\n}\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new Fable(pSettings);\n}\n\nmodule.exports = Fable;\nmodule.exports.new = autoConstruct;\n\nmodule.exports.LogProviderBase = libFableLog.LogProviderBase;\nmodule.exports.ServiceProviderBase = libFableServiceManager.ServiceProviderBase;\n\nmodule.exports.precedent = libFableSettings.precedent;"]}